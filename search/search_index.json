{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dewret DEclarative Workflow REndering Tool Pron : durr-it, like \"durable\" Introduction Dewret allows certain workflows written in a dynamic style to be rendered to a static representation. Advantages of doing so include: git-versionable workflows : while code can be versioned, the changes of a dynamic workflow do not necessarily clearly correspond to changes in the executed workflow. This maintains a precise trackable history. plan and play : the workflow can be rapidly iterated, analysed and optimized before it is sent for real execution on expensive or restricted HPC hardware. optimization : creating the workflow explicitly opens up possibilities for static analysis and refactoring before real execution. debugging : a number of classes of workflow planning bugs will not appear until late in a simulation run that might take days or weeks. This catches them before startup. continuous integration and testing : complex dynamic workflows can be rapidly sense-checked in CI without needing all the hardware and internal algorithms present to run them. Documentation For further information, see the documentation . Developer Set up For development with conda, run the relevant script in .set_up","title":"Home"},{"location":"#dewret","text":"DEclarative Workflow REndering Tool Pron : durr-it, like \"durable\"","title":"dewret"},{"location":"#introduction","text":"Dewret allows certain workflows written in a dynamic style to be rendered to a static representation. Advantages of doing so include: git-versionable workflows : while code can be versioned, the changes of a dynamic workflow do not necessarily clearly correspond to changes in the executed workflow. This maintains a precise trackable history. plan and play : the workflow can be rapidly iterated, analysed and optimized before it is sent for real execution on expensive or restricted HPC hardware. optimization : creating the workflow explicitly opens up possibilities for static analysis and refactoring before real execution. debugging : a number of classes of workflow planning bugs will not appear until late in a simulation run that might take days or weeks. This catches them before startup. continuous integration and testing : complex dynamic workflows can be rapidly sense-checked in CI without needing all the hardware and internal algorithms present to run them.","title":"Introduction"},{"location":"#documentation","text":"For further information, see the documentation .","title":"Documentation"},{"location":"#developer-set-up","text":"For development with conda, run the relevant script in .set_up","title":"Developer Set up"},{"location":"docs/comparison/","text":"Dewret Comparison Guide Synopsis Dewret occupies a unique position in the workflow ecosystem as a general-purpose Python-to-workflow compiler . It's not a replacement for execution engines or orchestrators, but rather a tool that makes writing portable workflows as easy as writing Python code. This makes it ideal for scenarios where workflow portability, standards compliance, and developer productivity are paramount. Overview This guide compares Dewret with leading workflow creation and orchestration tools, highlighting the unique value proposition and trade-offs of each approach. As explained above, Dewret is not a workflow execution engine - it uses dask internally - so, strictly, comparisons are between each engine and Dewret-plus-any-execution-backend (e.g. cwltool ). Quick Comparison Matrix Tool Type Primary Use Case Language Execution Model Portability Dewret Workflow Compiler Multi-platform workflows Python Renders to static High (CWL, Snakemake) Dask Parallel Computing Data processing Python Dynamic execution Low Prefect Orchestrator Data pipelines Python Dynamic execution Medium CWL Workflow Language Portable workflows YAML/JSON Static declaration High Kubeflow ML Platform ML pipelines Python/YAML Kubernetes-native Medium Kedro ML Framework Data science projects Python Dynamic execution Low Airflow Orchestrator ETL/scheduling Python Dynamic DAGs Low Snakemake Workflow Engine Bioinformatics Python/DSL Static rules Medium Nextflow Workflow Engine Scientific computing Groovy DSL Static declaration Medium Detailed Comparisons Dewret vs Dask Dask is a parallel computing library for Python that Dewret uses as its backend. Aspect Dewret Dask Purpose Workflow rendering Parallel execution Output Static workflow files Computed results Execution Via workflow engines Direct Python runtime Debugging Both static & dynamic Dynamic only Portability High (multiple formats) Python environments only When to use Dewret over Dask: - Need to run workflows on non-Python infrastructure - Require workflow versioning and reproducibility - Want to leverage workflow engine optimizations - Need to comply with workflow standards (CWL) When to use Dask over Dewret: - Interactive data analysis - Real-time computation needs - Python-only environments - No need for workflow portability Dewret vs Prefect Prefect is a workflow orchestration platform focused on operational reliability. Aspect Dewret Prefect Focus Workflow authoring Workflow orchestration Architecture Compiler/renderer Runtime orchestrator Deployment Any CWL/Snakemake runner Prefect infrastructure State Management Delegated to engine Built-in with UI Error Handling Static validation Runtime retry logic When to use Dewret over Prefect: - Need vendor-independent workflows - Want static workflow analysis - Require specific execution engines - Focus on scientific/HPC workloads When to use Prefect over Dewret: - Need sophisticated orchestration features - Want built-in monitoring/alerting - Require dynamic workflow modification - Focus on data engineering pipelines Dewret vs CWL (Common Workflow Language) CWL is the standard Dewret renders to, but can be written directly. Aspect Dewret Native CWL Authoring Python code YAML/JSON Learning Curve Low (Python) High (DSL) Flexibility High (full Python) Limited (declarative) Verbosity Concise Verbose Tooling Python ecosystem CWL-specific tools When to use Dewret over native CWL: - Team knows Python, not CWL - Need rapid prototyping - Want type checking and IDE support - Require code generation/metaprogramming When to use native CWL over Dewret: - Already have CWL expertise - Need fine-grained CWL control - Contributing to CWL workflows - Maximum standard compliance Dewret vs Kubeflow Kubeflow is a comprehensive ML platform for Kubernetes. Aspect Dewret Kubeflow Scope Workflow definition Full ML platform Infrastructure Any Kubernetes only Components Workflow compiler Pipelines, serving, training Complexity Lightweight Enterprise-scale Target Users Developers/Scientists ML Engineers/Ops When to use Dewret over Kubeflow: - Not committed to Kubernetes - Want simpler deployment - Need multi-platform workflows - Focus on workflow authoring When to use Kubeflow over Dewret: - Already on Kubernetes - Need full ML platform features - Want integrated model serving - Require multi-tenant capabilities Dewret vs Kedro Kedro is a Python framework for creating reproducible data science code. Aspect Dewret Kedro Philosophy Workflow rendering Project template Structure Task-based Node/Pipeline based Execution External engines Python runtime Data Management External Built-in catalog Best Practices Workflow portability Code organization When to use Dewret over Kedro: - Need cross-platform execution - Want static workflow outputs - Require workflow engine features - Focus on computational workflows When to use Kedro over Dewret: - Want opinionated project structure - Need integrated data versioning - Building ML products - Team collaboration focus Dewret vs Apache Airflow Airflow is a platform for programmatically authoring and scheduling workflows. Aspect Dewret Airflow Primary Use Workflow compilation Workflow scheduling DAG Definition Python \u2192 static Python (dynamic) Scheduling External Built-in scheduler UI None (uses engine UI) Comprehensive web UI Scale Depends on engine Proven at scale When to use Dewret over Airflow: - Need portable workflows - Want static analysis - Require specific compute environments - Focus on scientific computing When to use Airflow over Dewret: - Need scheduling capabilities - Want operational monitoring - Require dynamic DAGs - ETL/data engineering focus Dewret vs Snakemake Snakemake is a workflow engine that Dewret can render to. Aspect Dewret Native Snakemake Language Pure Python Python + DSL Rule Definition Functions Rule syntax Flexibility Full Python Limited to rules Learning Python only Snakemake syntax Features Via rendering Native features When to use Dewret over native Snakemake: - Prefer pure Python syntax - Need multiple output formats - Want Python tooling/IDE support - Require programmatic generation When to use native Snakemake over Dewret: - Already know Snakemake - Need Snakemake-specific features - Want direct rule control - Bioinformatics workflows Dewret vs Nextflow Nextflow is a DSL for data-driven computational pipelines. Aspect Dewret Nextflow Language Python Groovy-based DSL Paradigm Task graphs Dataflow programming Containers Via engines Native support Cloud Via engines Built-in providers Community Python ecosystem Bioinformatics focus When to use Dewret over Nextflow: - Team knows Python, not Groovy - Need multiple workflow formats - Want Python library integration - Broader than bioinformatics When to use Nextflow over Dewret: - Bioinformatics workflows - Need dataflow paradigm - Want built-in cloud support - Established Nextflow pipelines Summary: When to Choose Dewret Choose Dewret when you need: \u2705 Portability First - Workflows must run on multiple platforms - Vendor independence is critical - Standards compliance required \u2705 Python-Native Development - Team has Python expertise - Need IDE support and tooling - Want to leverage Python ecosystem \u2705 Static Workflow Benefits - Version control for workflows - Pre-execution validation - Workflow optimization opportunities \u2705 Scientific Computing Focus - HPC environments - Reproducible research - Cross-institutional collaboration Consider alternatives when you need: \u274c Runtime Orchestration - Complex scheduling requirements - Dynamic workflow modification - Built-in monitoring/alerting \u274c Platform-Specific Features - Kubernetes-native (Kubeflow) - Cloud-specific (Nextflow) - Scheduling-focused (Airflow) \u274c Immediate Execution - Interactive analysis (Dask) - Real-time processing - No workflow persistence needed","title":"Comparison"},{"location":"docs/comparison/#dewret-comparison-guide","text":"","title":"Dewret Comparison Guide"},{"location":"docs/comparison/#synopsis","text":"Dewret occupies a unique position in the workflow ecosystem as a general-purpose Python-to-workflow compiler . It's not a replacement for execution engines or orchestrators, but rather a tool that makes writing portable workflows as easy as writing Python code. This makes it ideal for scenarios where workflow portability, standards compliance, and developer productivity are paramount.","title":"Synopsis"},{"location":"docs/comparison/#overview","text":"This guide compares Dewret with leading workflow creation and orchestration tools, highlighting the unique value proposition and trade-offs of each approach. As explained above, Dewret is not a workflow execution engine - it uses dask internally - so, strictly, comparisons are between each engine and Dewret-plus-any-execution-backend (e.g. cwltool ).","title":"Overview"},{"location":"docs/comparison/#quick-comparison-matrix","text":"Tool Type Primary Use Case Language Execution Model Portability Dewret Workflow Compiler Multi-platform workflows Python Renders to static High (CWL, Snakemake) Dask Parallel Computing Data processing Python Dynamic execution Low Prefect Orchestrator Data pipelines Python Dynamic execution Medium CWL Workflow Language Portable workflows YAML/JSON Static declaration High Kubeflow ML Platform ML pipelines Python/YAML Kubernetes-native Medium Kedro ML Framework Data science projects Python Dynamic execution Low Airflow Orchestrator ETL/scheduling Python Dynamic DAGs Low Snakemake Workflow Engine Bioinformatics Python/DSL Static rules Medium Nextflow Workflow Engine Scientific computing Groovy DSL Static declaration Medium","title":"Quick Comparison Matrix"},{"location":"docs/comparison/#detailed-comparisons","text":"","title":"Detailed Comparisons"},{"location":"docs/comparison/#dewret-vs-dask","text":"Dask is a parallel computing library for Python that Dewret uses as its backend. Aspect Dewret Dask Purpose Workflow rendering Parallel execution Output Static workflow files Computed results Execution Via workflow engines Direct Python runtime Debugging Both static & dynamic Dynamic only Portability High (multiple formats) Python environments only When to use Dewret over Dask: - Need to run workflows on non-Python infrastructure - Require workflow versioning and reproducibility - Want to leverage workflow engine optimizations - Need to comply with workflow standards (CWL) When to use Dask over Dewret: - Interactive data analysis - Real-time computation needs - Python-only environments - No need for workflow portability","title":"Dewret vs Dask"},{"location":"docs/comparison/#dewret-vs-prefect","text":"Prefect is a workflow orchestration platform focused on operational reliability. Aspect Dewret Prefect Focus Workflow authoring Workflow orchestration Architecture Compiler/renderer Runtime orchestrator Deployment Any CWL/Snakemake runner Prefect infrastructure State Management Delegated to engine Built-in with UI Error Handling Static validation Runtime retry logic When to use Dewret over Prefect: - Need vendor-independent workflows - Want static workflow analysis - Require specific execution engines - Focus on scientific/HPC workloads When to use Prefect over Dewret: - Need sophisticated orchestration features - Want built-in monitoring/alerting - Require dynamic workflow modification - Focus on data engineering pipelines","title":"Dewret vs Prefect"},{"location":"docs/comparison/#dewret-vs-cwl-common-workflow-language","text":"CWL is the standard Dewret renders to, but can be written directly. Aspect Dewret Native CWL Authoring Python code YAML/JSON Learning Curve Low (Python) High (DSL) Flexibility High (full Python) Limited (declarative) Verbosity Concise Verbose Tooling Python ecosystem CWL-specific tools When to use Dewret over native CWL: - Team knows Python, not CWL - Need rapid prototyping - Want type checking and IDE support - Require code generation/metaprogramming When to use native CWL over Dewret: - Already have CWL expertise - Need fine-grained CWL control - Contributing to CWL workflows - Maximum standard compliance","title":"Dewret vs CWL (Common Workflow Language)"},{"location":"docs/comparison/#dewret-vs-kubeflow","text":"Kubeflow is a comprehensive ML platform for Kubernetes. Aspect Dewret Kubeflow Scope Workflow definition Full ML platform Infrastructure Any Kubernetes only Components Workflow compiler Pipelines, serving, training Complexity Lightweight Enterprise-scale Target Users Developers/Scientists ML Engineers/Ops When to use Dewret over Kubeflow: - Not committed to Kubernetes - Want simpler deployment - Need multi-platform workflows - Focus on workflow authoring When to use Kubeflow over Dewret: - Already on Kubernetes - Need full ML platform features - Want integrated model serving - Require multi-tenant capabilities","title":"Dewret vs Kubeflow"},{"location":"docs/comparison/#dewret-vs-kedro","text":"Kedro is a Python framework for creating reproducible data science code. Aspect Dewret Kedro Philosophy Workflow rendering Project template Structure Task-based Node/Pipeline based Execution External engines Python runtime Data Management External Built-in catalog Best Practices Workflow portability Code organization When to use Dewret over Kedro: - Need cross-platform execution - Want static workflow outputs - Require workflow engine features - Focus on computational workflows When to use Kedro over Dewret: - Want opinionated project structure - Need integrated data versioning - Building ML products - Team collaboration focus","title":"Dewret vs Kedro"},{"location":"docs/comparison/#dewret-vs-apache-airflow","text":"Airflow is a platform for programmatically authoring and scheduling workflows. Aspect Dewret Airflow Primary Use Workflow compilation Workflow scheduling DAG Definition Python \u2192 static Python (dynamic) Scheduling External Built-in scheduler UI None (uses engine UI) Comprehensive web UI Scale Depends on engine Proven at scale When to use Dewret over Airflow: - Need portable workflows - Want static analysis - Require specific compute environments - Focus on scientific computing When to use Airflow over Dewret: - Need scheduling capabilities - Want operational monitoring - Require dynamic DAGs - ETL/data engineering focus","title":"Dewret vs Apache Airflow"},{"location":"docs/comparison/#dewret-vs-snakemake","text":"Snakemake is a workflow engine that Dewret can render to. Aspect Dewret Native Snakemake Language Pure Python Python + DSL Rule Definition Functions Rule syntax Flexibility Full Python Limited to rules Learning Python only Snakemake syntax Features Via rendering Native features When to use Dewret over native Snakemake: - Prefer pure Python syntax - Need multiple output formats - Want Python tooling/IDE support - Require programmatic generation When to use native Snakemake over Dewret: - Already know Snakemake - Need Snakemake-specific features - Want direct rule control - Bioinformatics workflows","title":"Dewret vs Snakemake"},{"location":"docs/comparison/#dewret-vs-nextflow","text":"Nextflow is a DSL for data-driven computational pipelines. Aspect Dewret Nextflow Language Python Groovy-based DSL Paradigm Task graphs Dataflow programming Containers Via engines Native support Cloud Via engines Built-in providers Community Python ecosystem Bioinformatics focus When to use Dewret over Nextflow: - Team knows Python, not Groovy - Need multiple workflow formats - Want Python library integration - Broader than bioinformatics When to use Nextflow over Dewret: - Bioinformatics workflows - Need dataflow paradigm - Want built-in cloud support - Established Nextflow pipelines","title":"Dewret vs Nextflow"},{"location":"docs/comparison/#summary-when-to-choose-dewret","text":"","title":"Summary: When to Choose Dewret"},{"location":"docs/comparison/#choose-dewret-when-you-need","text":"\u2705 Portability First - Workflows must run on multiple platforms - Vendor independence is critical - Standards compliance required \u2705 Python-Native Development - Team has Python expertise - Need IDE support and tooling - Want to leverage Python ecosystem \u2705 Static Workflow Benefits - Version control for workflows - Pre-execution validation - Workflow optimization opportunities \u2705 Scientific Computing Focus - HPC environments - Reproducible research - Cross-institutional collaboration","title":"Choose Dewret when you need:"},{"location":"docs/comparison/#consider-alternatives-when-you-need","text":"\u274c Runtime Orchestration - Complex scheduling requirements - Dynamic workflow modification - Built-in monitoring/alerting \u274c Platform-Specific Features - Kubernetes-native (Kubeflow) - Cloud-specific (Nextflow) - Scheduling-focused (Airflow) \u274c Immediate Execution - Interactive analysis (Dask) - Real-time processing - No workflow persistence needed","title":"Consider alternatives when you need:"},{"location":"docs/eager_execution/","text":"Debug Task Execution at Render Time Description The --eager flag is designed to help users debug tasks and workflows during render time, before the final CWL (or other) workflow is generated. Normally, dewret builds a lazy task graph that is rendered into a declarative workflow (e.g., CWL, Snakemake). However, this can make debugging difficult, since no code is actually executed during rendering. With --eager , dewret will: Directly execute the task using the provided inputs Print the result to the terminal Bypass the lazy rendering pipeline This allows you to: - Test tasks in isolation - Verify that input arguments are valid - Inspect real outputs before committing to workflow generation Usage When using eager evaluation, dewret will evaluate and execute the workflow immediately , rather than generating a declarative workflow. This is useful for debugging and inspecting runtime behavior. Simple workflow or task Given the following workflow: # eager_demo.py from dewret.tasks import ( workflow , task , ) @task () def sum ( left : int , right : int ) -> int : print ( \"left\" , left ) print ( \"right\" , right ) return left + right @workflow () def black_total ( hearts : int , clubs : int , spades : int , diamonds : int ) -> int : print ( \"hearts\" , hearts ) print ( \"spades\" , spades ) print ( \"diamonds\" , diamonds ) print ( \"clubs\" , clubs ) return sum ( left = spades , right = clubs ) Run a single task via CLI: python -m dewret --eager eager_demo.py sum \"left:10\" \"right:11\" Output: {'left': 10, 'right': 11} {'left': <class 'int'>, 'right': <class 'int'>, 'return': <class 'int'>} left 10 right 11 21 Run the full workflow via CLI: python -m dewret --eager eager_demo.py black_total \"hearts:10\" \"spades:11\" \"diamonds:12\" \"clubs:13\" Output: {'hearts': 10, 'spades': 11, 'diamonds': 12, 'clubs': 13} {'hearts': <class 'int'>, 'clubs': <class 'int'>, 'spades': <class 'int'>, 'diamonds': <class 'int'>, 'return': <class 'int'>} hearts 10 spades 11 diamonds 12 clubs 13 {'left': 11, 'right': 13} {'left': <class 'int'>, 'right': <class 'int'>, 'return': <class 'int'>} left 11 right 13 24 Debugging workflows with custom objects For more complex cases using factories or dataclasses, use eager evaluation in code like this: >>> from attrs import define >>> from dewret.core import set_configuration >>> from dewret.tasks import workflow , factory , task >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> Pack = factory ( PackResult ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... print ( \"left\" , left ) ... print ( \"right\" , right ) ... return left + right >>> @workflow () ... def black_total ( pack : PackResult ) -> int : ... print ( \"pack\" , type ( pack )) ... print ( \"hearts\" , pack . hearts ) ... print ( \"spades\" , pack . spades ) ... print ( \"diamonds\" , pack . diamonds ) ... print ( \"clubs\" , pack . clubs ) ... return sum ( left = pack . spades , right = pack . clubs ) >>> with set_configuration ( eager = True ): ... pack = Pack ( hearts = 13 , spades = 13 , diamonds = 13 , clubs = 13 ) ... output = black_total ( pack = pack ) ... print ( \"output\" , output ) pack < class ' __main__ . PackResult '> hearts 13 spades 13 diamonds 13 clubs 13 left 13 right 13 output 26 Debugging with eager on VS code","title":"Eager Execution"},{"location":"docs/eager_execution/#debug-task-execution-at-render-time","text":"","title":"Debug Task Execution at Render Time"},{"location":"docs/eager_execution/#description","text":"The --eager flag is designed to help users debug tasks and workflows during render time, before the final CWL (or other) workflow is generated. Normally, dewret builds a lazy task graph that is rendered into a declarative workflow (e.g., CWL, Snakemake). However, this can make debugging difficult, since no code is actually executed during rendering. With --eager , dewret will: Directly execute the task using the provided inputs Print the result to the terminal Bypass the lazy rendering pipeline This allows you to: - Test tasks in isolation - Verify that input arguments are valid - Inspect real outputs before committing to workflow generation","title":"Description"},{"location":"docs/eager_execution/#usage","text":"When using eager evaluation, dewret will evaluate and execute the workflow immediately , rather than generating a declarative workflow. This is useful for debugging and inspecting runtime behavior.","title":"Usage"},{"location":"docs/eager_execution/#simple-workflow-or-task","text":"Given the following workflow: # eager_demo.py from dewret.tasks import ( workflow , task , ) @task () def sum ( left : int , right : int ) -> int : print ( \"left\" , left ) print ( \"right\" , right ) return left + right @workflow () def black_total ( hearts : int , clubs : int , spades : int , diamonds : int ) -> int : print ( \"hearts\" , hearts ) print ( \"spades\" , spades ) print ( \"diamonds\" , diamonds ) print ( \"clubs\" , clubs ) return sum ( left = spades , right = clubs ) Run a single task via CLI: python -m dewret --eager eager_demo.py sum \"left:10\" \"right:11\" Output: {'left': 10, 'right': 11} {'left': <class 'int'>, 'right': <class 'int'>, 'return': <class 'int'>} left 10 right 11 21 Run the full workflow via CLI: python -m dewret --eager eager_demo.py black_total \"hearts:10\" \"spades:11\" \"diamonds:12\" \"clubs:13\" Output: {'hearts': 10, 'spades': 11, 'diamonds': 12, 'clubs': 13} {'hearts': <class 'int'>, 'clubs': <class 'int'>, 'spades': <class 'int'>, 'diamonds': <class 'int'>, 'return': <class 'int'>} hearts 10 spades 11 diamonds 12 clubs 13 {'left': 11, 'right': 13} {'left': <class 'int'>, 'right': <class 'int'>, 'return': <class 'int'>} left 11 right 13 24","title":"Simple workflow or task"},{"location":"docs/eager_execution/#debugging-workflows-with-custom-objects","text":"For more complex cases using factories or dataclasses, use eager evaluation in code like this: >>> from attrs import define >>> from dewret.core import set_configuration >>> from dewret.tasks import workflow , factory , task >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> Pack = factory ( PackResult ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... print ( \"left\" , left ) ... print ( \"right\" , right ) ... return left + right >>> @workflow () ... def black_total ( pack : PackResult ) -> int : ... print ( \"pack\" , type ( pack )) ... print ( \"hearts\" , pack . hearts ) ... print ( \"spades\" , pack . spades ) ... print ( \"diamonds\" , pack . diamonds ) ... print ( \"clubs\" , pack . clubs ) ... return sum ( left = pack . spades , right = pack . clubs ) >>> with set_configuration ( eager = True ): ... pack = Pack ( hearts = 13 , spades = 13 , diamonds = 13 , clubs = 13 ) ... output = black_total ( pack = pack ) ... print ( \"output\" , output ) pack < class ' __main__ . PackResult '> hearts 13 spades 13 diamonds 13 clubs 13 left 13 right 13 output 26","title":"Debugging workflows with custom objects"},{"location":"docs/eager_execution/#debugging-with-eager-on-vs-code","text":"","title":"Debugging with eager on VS code"},{"location":"docs/glossary/","text":"Glossary Construct To construct a workflow in dewret is to pull the connected steps into a single structure. Sub Workflow A subworkflow is a nested or hierarchical workflow. It is a workflow defined within another workflow, allowing for the encapsulation and reuse of complex operations as a single, higher-level step in the parent workflow. Specific type of task designed to encapsulate multiple tasks. Nested tasks are the culmination (or result) of multiple tasks represented as a single task in a dewret workflow . Render To render a workflow is to generate an executable workflow in a specific workflow language such as CWL and Snakemake. Step A step in a dewret workflow represents a single unit of work. It contains a single task and the arguments for that task. Corresponds to a CWL Step or a Snakemake Rule Task A task is the function scheduled to be executed later. Corresponds to a CWL Process Workflow A workflow is designed to define, manage, and execute a series of tasks that make use of both local and global parameters.","title":"Glossary"},{"location":"docs/glossary/#glossary","text":"","title":"Glossary"},{"location":"docs/glossary/#construct","text":"To construct a workflow in dewret is to pull the connected steps into a single structure.","title":"Construct"},{"location":"docs/glossary/#sub-workflow","text":"A subworkflow is a nested or hierarchical workflow. It is a workflow defined within another workflow, allowing for the encapsulation and reuse of complex operations as a single, higher-level step in the parent workflow. Specific type of task designed to encapsulate multiple tasks. Nested tasks are the culmination (or result) of multiple tasks represented as a single task in a dewret workflow .","title":"Sub Workflow"},{"location":"docs/glossary/#render","text":"To render a workflow is to generate an executable workflow in a specific workflow language such as CWL and Snakemake.","title":"Render"},{"location":"docs/glossary/#step","text":"A step in a dewret workflow represents a single unit of work. It contains a single task and the arguments for that task. Corresponds to a CWL Step or a Snakemake Rule","title":"Step"},{"location":"docs/glossary/#task","text":"A task is the function scheduled to be executed later. Corresponds to a CWL Process","title":"Task"},{"location":"docs/glossary/#workflow","text":"A workflow is designed to define, manage, and execute a series of tasks that make use of both local and global parameters.","title":"Workflow"},{"location":"docs/overview/","text":"What is Dewret and Why? Executive Summary Dewret (DEclarative Workflow REndering Tool) is a Python framework that bridges the gap between dynamic, code-based workflows and static, portable workflow specifications. It enables organizations to write complex computational workflows in familiar Python syntax while automatically generating standard workflow formats (such as CWL) for execution across diverse computing environments. The Problem Organizations running computational workloads face a fundamental trade-off: Dynamic workflows (Python/Dask) are flexible and developer-friendly but lack portability, reproducibility, and optimization opportunities Static workflows (CWL/Snakemake/etc.) are portable and optimizable but require verbose YAML/DSL syntax with steep learning curves This forces teams to choose between developer productivity and operational requirements, often resulting in: Vendor lock-in to specific execution platforms Difficulty sharing workflows across teams and institutions Inability to leverage workflow-specific optimizations Challenges with reproducibility and version control The Dewret Solution Dewret eliminates this trade-off by providing a Python-first authoring experience that automatically renders to portable, standards-compliant workflows . Core Value Proposition # Write natural Python code @task () def process_data ( file : str ) -> pd . DataFrame : return pd . read_csv ( file ) @workflow () def analysis_pipeline ( data_file : str ): df = process_data ( data_file ) return analyze ( df ) \u2193 Renders automatically to \u2193 # Industry-standard CWL workflow class : Workflow cwlVersion : v1.2 steps : process_data : run : process_data.cwl in : { file : data_file } # ... complete executable workflow Key Benefits For Development Teams Familiar Syntax : Write workflows in Python using existing skills and tools Rich Type System : Leverage Python's type hints for automatic workflow validation Debugging Support : Test and debug workflows locally before deployment Code Reuse : Integrate with existing Python libraries and frameworks IDE Support : Type-hinting and eager execution simplify step debugging in IDEs For Operations Teams Multi-Platform Execution : Deploy to multiple environment types Performance Optimization : Enable workflow engines to optimize execution plans Container Support : Automatic integration with containerized environments Resource Management : Leverage workflow engine capabilities for scheduling and scaling For Organizations Vendor Independence : Avoid lock-in to specific workflow platforms Standards Compliance : Generate workflows compatible with chosen industry standards Cost Optimization : Test locally, optimize workflows before expensive HPC runs Audit Trail : Git-versionable static workflows enhance reproducibility and issue bisection Technical Architecture Lazy Evaluation Engine Built on Dask's proven lazy evaluation system, Dewret constructs workflow graphs without executing code, enabling analysis and optimization before rendering. Multi-Renderer Support CWL : Common Workflow Language for maximum portability Extensible : Plugin architecture for custom renderers Enterprise Features Early Error Detection : Catch workflow issues before resource-intensive execution Static Analysis : Enable workflow linting, security scanning, and optimization CI/CD Integration : Automated workflow testing and validation Documentation Generation : Automatic workflow documentation from code Use Cases Scientific Computing Multi-step data analysis pipelines High-performance computing workloads Cross-institutional collaboration Data Engineering ETL/ELT pipeline development Multi-cloud data processing Batch processing workflows Machine Learning Model training pipelines Feature engineering workflows MLOps automation Advanced Usage Proof-of-concept work that can be extended to full features: Graph-based Checkpointing : By knowing output goals and any memoization achieved in previous execution, with a defined \"audit log\" schema, dewret will eliminate redundant computation consistently, before reaching the executor, even for complex DAGs Multi-engine Workflows : From a single workflow in dewret, coarse- and fine-grained execution can be achieved by making the \"split-points\" between workflows on (e.g.) Argo and workflows on (e.g.) dask workers choosable at render-time. Why Dewret Now? Industry Trends Growing adoption of workflow standards Increased focus on reproducible research and FAIR data principles Multi-cloud strategies requiring portable workloads Competitive Advantage Unique Position : Only tool providing Python-native authoring with multi-format rendering Proven Foundation : Built on mature technologies (Dask, established workflow standards) Active Ecosystem : Integration with existing Python scientific computing stack Return on Investment Drivers Reduced Development Time : Far faster workflow development vs. native YAML Improved Reliability : Early error detection prevents costly HPC failures Enhanced Portability : Single codebase runs across multiple execution environments Team Efficiency : Leverage existing Python expertise instead of learning new DSLs Getting Started Dewret is available as an open-source Python package with comprehensive documentation, examples, and community support. Organizations can evaluate Dewret with existing workflows and see immediate benefits in developer productivity and workflow portability. Installation : pip install dewret Documentation : https://flaxandteal.github.io/dewret Repository : https://github.com/flaxandteal/dewret","title":"Overview"},{"location":"docs/overview/#what-is-dewret-and-why","text":"","title":"What is Dewret and Why?"},{"location":"docs/overview/#executive-summary","text":"Dewret (DEclarative Workflow REndering Tool) is a Python framework that bridges the gap between dynamic, code-based workflows and static, portable workflow specifications. It enables organizations to write complex computational workflows in familiar Python syntax while automatically generating standard workflow formats (such as CWL) for execution across diverse computing environments.","title":"Executive Summary"},{"location":"docs/overview/#the-problem","text":"Organizations running computational workloads face a fundamental trade-off: Dynamic workflows (Python/Dask) are flexible and developer-friendly but lack portability, reproducibility, and optimization opportunities Static workflows (CWL/Snakemake/etc.) are portable and optimizable but require verbose YAML/DSL syntax with steep learning curves This forces teams to choose between developer productivity and operational requirements, often resulting in: Vendor lock-in to specific execution platforms Difficulty sharing workflows across teams and institutions Inability to leverage workflow-specific optimizations Challenges with reproducibility and version control","title":"The Problem"},{"location":"docs/overview/#the-dewret-solution","text":"Dewret eliminates this trade-off by providing a Python-first authoring experience that automatically renders to portable, standards-compliant workflows .","title":"The Dewret Solution"},{"location":"docs/overview/#core-value-proposition","text":"# Write natural Python code @task () def process_data ( file : str ) -> pd . DataFrame : return pd . read_csv ( file ) @workflow () def analysis_pipeline ( data_file : str ): df = process_data ( data_file ) return analyze ( df ) \u2193 Renders automatically to \u2193 # Industry-standard CWL workflow class : Workflow cwlVersion : v1.2 steps : process_data : run : process_data.cwl in : { file : data_file } # ... complete executable workflow","title":"Core Value Proposition"},{"location":"docs/overview/#key-benefits","text":"","title":"Key Benefits"},{"location":"docs/overview/#for-development-teams","text":"Familiar Syntax : Write workflows in Python using existing skills and tools Rich Type System : Leverage Python's type hints for automatic workflow validation Debugging Support : Test and debug workflows locally before deployment Code Reuse : Integrate with existing Python libraries and frameworks IDE Support : Type-hinting and eager execution simplify step debugging in IDEs","title":"For Development Teams"},{"location":"docs/overview/#for-operations-teams","text":"Multi-Platform Execution : Deploy to multiple environment types Performance Optimization : Enable workflow engines to optimize execution plans Container Support : Automatic integration with containerized environments Resource Management : Leverage workflow engine capabilities for scheduling and scaling","title":"For Operations Teams"},{"location":"docs/overview/#for-organizations","text":"Vendor Independence : Avoid lock-in to specific workflow platforms Standards Compliance : Generate workflows compatible with chosen industry standards Cost Optimization : Test locally, optimize workflows before expensive HPC runs Audit Trail : Git-versionable static workflows enhance reproducibility and issue bisection","title":"For Organizations"},{"location":"docs/overview/#technical-architecture","text":"","title":"Technical Architecture"},{"location":"docs/overview/#lazy-evaluation-engine","text":"Built on Dask's proven lazy evaluation system, Dewret constructs workflow graphs without executing code, enabling analysis and optimization before rendering.","title":"Lazy Evaluation Engine"},{"location":"docs/overview/#multi-renderer-support","text":"CWL : Common Workflow Language for maximum portability Extensible : Plugin architecture for custom renderers","title":"Multi-Renderer Support"},{"location":"docs/overview/#enterprise-features","text":"Early Error Detection : Catch workflow issues before resource-intensive execution Static Analysis : Enable workflow linting, security scanning, and optimization CI/CD Integration : Automated workflow testing and validation Documentation Generation : Automatic workflow documentation from code","title":"Enterprise Features"},{"location":"docs/overview/#use-cases","text":"","title":"Use Cases"},{"location":"docs/overview/#scientific-computing","text":"Multi-step data analysis pipelines High-performance computing workloads Cross-institutional collaboration","title":"Scientific Computing"},{"location":"docs/overview/#data-engineering","text":"ETL/ELT pipeline development Multi-cloud data processing Batch processing workflows","title":"Data Engineering"},{"location":"docs/overview/#machine-learning","text":"Model training pipelines Feature engineering workflows MLOps automation","title":"Machine Learning"},{"location":"docs/overview/#advanced-usage","text":"Proof-of-concept work that can be extended to full features: Graph-based Checkpointing : By knowing output goals and any memoization achieved in previous execution, with a defined \"audit log\" schema, dewret will eliminate redundant computation consistently, before reaching the executor, even for complex DAGs Multi-engine Workflows : From a single workflow in dewret, coarse- and fine-grained execution can be achieved by making the \"split-points\" between workflows on (e.g.) Argo and workflows on (e.g.) dask workers choosable at render-time.","title":"Advanced Usage"},{"location":"docs/overview/#why-dewret-now","text":"","title":"Why Dewret Now?"},{"location":"docs/overview/#industry-trends","text":"Growing adoption of workflow standards Increased focus on reproducible research and FAIR data principles Multi-cloud strategies requiring portable workloads","title":"Industry Trends"},{"location":"docs/overview/#competitive-advantage","text":"Unique Position : Only tool providing Python-native authoring with multi-format rendering Proven Foundation : Built on mature technologies (Dask, established workflow standards) Active Ecosystem : Integration with existing Python scientific computing stack","title":"Competitive Advantage"},{"location":"docs/overview/#return-on-investment-drivers","text":"Reduced Development Time : Far faster workflow development vs. native YAML Improved Reliability : Early error detection prevents costly HPC failures Enhanced Portability : Single codebase runs across multiple execution environments Team Efficiency : Leverage existing Python expertise instead of learning new DSLs","title":"Return on Investment Drivers"},{"location":"docs/overview/#getting-started","text":"Dewret is available as an open-source Python package with comprehensive documentation, examples, and community support. Organizations can evaluate Dewret with existing workflows and see immediate benefits in developer productivity and workflow portability. Installation : pip install dewret Documentation : https://flaxandteal.github.io/dewret Repository : https://github.com/flaxandteal/dewret","title":"Getting Started"},{"location":"docs/quickstart/","text":"Quickstart Introduction Description Dewret is a tool designed for creating complex workflows, written in a dynamic style, to be rendered to a static representation. Dewret provides a programmatic python interface to multiple declarative workflow engines, where workflows are often written in a yaml-like syntax. It makes it easier for users to define tasks and organize them into workflows. Currently, Dewret supports two renderers: Snakemake and CWL, which generate yamls in the corresponding workflow languages. What are Workflows? Workflows are a collection of tasks or steps designed to automate complex processes. These processes are common in fields like data science, scientific computing and software development, where you can ensure automation. Traditionally, managing workflows can be challenging due to the diversity of backend systems and the complexity of configurations involved. What Makes Dewret Unique? Why should I use Dewret? Dewret stands out by providing a unified and simplified interface for workflow management, making it accessible to users with varying levels of experience. Here are some key features that make Dewret unique: Consistency : offers a consistent interface for defining tasks and workflows. Optimization : creating a declarative workflow opens up possibilities for static analysis and refactoring before execution. Customization : dewret offers the ability to create custom renderers for workflows in desired languages. This includes default support for CWL and Snakemake workflow languages. The capability to render a single workflow into multiple declarative languages enables users to experiment with different workflow engines. Git-versionable workflows : while code can be versioned, changes in a dynamic workflow may not clearly correspond to changes in the executed workflow. By defining a static workflow that is rendered from the dynamic or programmatic workflow, we maintain a precise and trackable history. Default Renderers : Snakemake and CWL. Debugging : a number of classes of workflow planning bugs will not appear until late in a simulation run that might take days or weeks. Having a declarative and static workflow definition document post-render provides enhanced possibilities for static analysis, helping to catch these issues before startup. Continuous Integration and Testing : complex dynamic workflows can be rapidly sense-checked in CI without needing all the hardware and internal algorithms present to run them. Installation for pure users If you simply want to use Dewret to run workflows, you can install it from PyPI or Conda. From PyPI: pip install dewret From Conda: conda install conda-forge::dewret Installation for developers From a cloned repository: pip install -e . Usage You can render a simple Common Workflow Language CWL workflow from a graph composed of one or more tasks as follows: # workflow.py from dewret.tasks import task @task () def increment ( num : int ) -> int : return num + 1 $ python -m dewret --pretty workflow.py increment num:3 class : Workflow cwlVersion : v1.2 outputs : out : outputSource : increment-e138626779553199eb2bd678356b640f-num type : int steps : increment-e138626779553199eb2bd678356b640f-num in : num : default : 3 out : - out run : increment By default dewret uses a dask backend so that dewret.task wraps a dask.delayed , and renders a CWL workflow. Programmatic Usage Building and rendering may be done programmatically, which provides the opportunity to use custom renderers and backends, as well as bespoke serialization or formatting. >>> import sys >>> import yaml >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> >>> @task () ... def increment ( num : int ) -> int : ... return num + 1 >>> >>> result = increment ( num = 3 ) >>> workflow = construct ( result , simplify_ids = True ) >>> cwl = render ( workflow )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : increment - 1 - num : default : 3 label : num type : int outputs : out : label : out outputSource : increment - 1 / out type : int steps : increment - 1 : in : num : source : increment - 1 - num out : - out run : increment","title":"Quickstart"},{"location":"docs/quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"docs/quickstart/#introduction","text":"","title":"Introduction"},{"location":"docs/quickstart/#description","text":"Dewret is a tool designed for creating complex workflows, written in a dynamic style, to be rendered to a static representation. Dewret provides a programmatic python interface to multiple declarative workflow engines, where workflows are often written in a yaml-like syntax. It makes it easier for users to define tasks and organize them into workflows. Currently, Dewret supports two renderers: Snakemake and CWL, which generate yamls in the corresponding workflow languages.","title":"Description"},{"location":"docs/quickstart/#what-are-workflows","text":"Workflows are a collection of tasks or steps designed to automate complex processes. These processes are common in fields like data science, scientific computing and software development, where you can ensure automation. Traditionally, managing workflows can be challenging due to the diversity of backend systems and the complexity of configurations involved.","title":"What are Workflows?"},{"location":"docs/quickstart/#what-makes-dewret-unique-why-should-i-use-dewret","text":"Dewret stands out by providing a unified and simplified interface for workflow management, making it accessible to users with varying levels of experience. Here are some key features that make Dewret unique: Consistency : offers a consistent interface for defining tasks and workflows. Optimization : creating a declarative workflow opens up possibilities for static analysis and refactoring before execution. Customization : dewret offers the ability to create custom renderers for workflows in desired languages. This includes default support for CWL and Snakemake workflow languages. The capability to render a single workflow into multiple declarative languages enables users to experiment with different workflow engines. Git-versionable workflows : while code can be versioned, changes in a dynamic workflow may not clearly correspond to changes in the executed workflow. By defining a static workflow that is rendered from the dynamic or programmatic workflow, we maintain a precise and trackable history. Default Renderers : Snakemake and CWL. Debugging : a number of classes of workflow planning bugs will not appear until late in a simulation run that might take days or weeks. Having a declarative and static workflow definition document post-render provides enhanced possibilities for static analysis, helping to catch these issues before startup. Continuous Integration and Testing : complex dynamic workflows can be rapidly sense-checked in CI without needing all the hardware and internal algorithms present to run them.","title":"What Makes Dewret Unique? Why should I use Dewret?"},{"location":"docs/quickstart/#installation-for-pure-users","text":"If you simply want to use Dewret to run workflows, you can install it from PyPI or Conda.","title":"Installation for pure users"},{"location":"docs/quickstart/#from-pypi","text":"pip install dewret","title":"From PyPI:"},{"location":"docs/quickstart/#from-conda","text":"conda install conda-forge::dewret","title":"From Conda:"},{"location":"docs/quickstart/#installation-for-developers","text":"From a cloned repository: pip install -e .","title":"Installation for developers"},{"location":"docs/quickstart/#usage","text":"You can render a simple Common Workflow Language CWL workflow from a graph composed of one or more tasks as follows: # workflow.py from dewret.tasks import task @task () def increment ( num : int ) -> int : return num + 1 $ python -m dewret --pretty workflow.py increment num:3 class : Workflow cwlVersion : v1.2 outputs : out : outputSource : increment-e138626779553199eb2bd678356b640f-num type : int steps : increment-e138626779553199eb2bd678356b640f-num in : num : default : 3 out : - out run : increment By default dewret uses a dask backend so that dewret.task wraps a dask.delayed , and renders a CWL workflow.","title":"Usage"},{"location":"docs/quickstart/#programmatic-usage","text":"Building and rendering may be done programmatically, which provides the opportunity to use custom renderers and backends, as well as bespoke serialization or formatting. >>> import sys >>> import yaml >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> >>> @task () ... def increment ( num : int ) -> int : ... return num + 1 >>> >>> result = increment ( num = 3 ) >>> workflow = construct ( result , simplify_ids = True ) >>> cwl = render ( workflow )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : increment - 1 - num : default : 3 label : num type : int outputs : out : label : out outputSource : increment - 1 / out type : int steps : increment - 1 : in : num : source : increment - 1 - num out : - out run : increment","title":"Programmatic Usage"},{"location":"docs/renderer_tutorial/","text":"Step-by-Step Guide to Writing a Custom Renderer 1. Understand the Target Workflow Language Before writing any code, it is essential to fully understand the target workflow language. This includes syntax, structure, and specific requirements. By breaking down each key dewret.workflow task into smaller components, you can better map your workflow definitions to the target language. Example: In Snakemake, a workflow task is generally created by: Defining the task. - rule process_data Defining the input required for the rule to run(dependencies). - input: \"data/raw_data.txt\" Defining the output required for the rule to be considered finished. - output: \"data/processed_data.txt\" Defining the actual work that the task will do. - in this case: shell: ... rule process_data: # Example Snakemake rule/task input: \"data/raw_data.txt\" output: output_file = \"data/processed_data.txt\" run: with open ( output.output_file, \"w\" ) as f: f.write ( \"data\" ) return output_file 2. Create WorkflowDefinition. The WorkflowDefinition class is responsible for transforming each step from a constructed dewret workflow into an executable step in the target workflow language (e.g. a Snakemake rule). This class should encapsulate workflow-level information, such as the list of steps to be executed, and any workflow-scope input/ouput. It should also contain a class method that initializes the WorkflowDefinition from an dewret Workflow (such as from_workflow below), and a method that renders the workflow as a Python dict (as in the render method below). Example: @define class WorkflowDefinition : steps : list [ StepDefinition ] # Returns a WorkflowDefinition instanace. # Steps contains all of the tasks you want to convert to the target WL tasks. @classmethod def from_workflow ( cls , workflow : Workflow ) -> \"WorkflowDefinition\" : return cls ( steps = [ StepDefinition . from_step ( step ) for step in workflow . steps ]) # Returns each task as a Snakemake executable rule. def render ( self ) -> dict [ str , RawType ]: return { f \"rule { step . name . replace ( \"-\" , \"_\" ) } \" : step . render () for step in self . steps } 3. Ensuring Our Module is Recognized as a Render Module To have our custom renderer identified by Dewret as a valid renderer, we need to implement the BaseRenderModule along with one of the two protocols: RawRenderModule or StructuredRenderModule . Implementing BaseRenderModule The BaseRenderModule defines the foundation for a custom renderer. To implement this protocol, we need to define the default_config() method, which provides default configurations for our renderer. def default_config () -> CWLRendererConfiguration : \"\"\"Default configuration for this renderer. This is a hook-like call to give a configuration dict that this renderer will respect, and sets any necessary default values. Returns: a dict with (preferably) raw type structures to enable easy setting from YAML/JSON. \"\"\" return { \"allow_complex_types\" : False , \"factories_as_params\" : False , } After implementing BaseRenderModule , you need to implement either the RawRenderModule or StructuredRenderModule protocol, depending on how you want to handle the workflow rendering. Implementing either RawRenderModule or StructuredRenderModule The StructuredRenderModule is designed for structured workflows that are directly ready to be output in the respective format (e.g., CWL, Snakemake, etc.). The key method to implement is render , which converts a workflow into a structured, serializable format. def render ( self , workflow : WorkflowProtocol , ** kwargs : RenderConfiguration ) -> dict [ str , dict [ str , RawType ]]: \"\"\"Turn a workflow into a serializable structure. Returns: one or more subworkflows with a `__root__` key representing the outermost workflow, at least. \"\"\" ... In this method: - You receive a workflow and potentially some optional configurations. - You return a dictionary where the __root__ key holds the primary workflow and any additional subworkflows are nested inside the returned structure. If you prefer more flexibility and want the structuring to be handled by the user, you can implement the RawRenderModule protocol. This requires defining the render_raw method, which converts a workflow into raw, flat strings. def render_raw ( self , workflow : WorkflowProtocol , ** kwargs : RenderConfiguration ) -> dict [ str , str ]: \"\"\"Turn a workflow into flat strings. Returns: one or more subworkflows with a `__root__` key representing the outermost workflow, at least. \"\"\" ... In this method: The workflow is rendered as raw, unstructured strings. The user is responsible for handling the structuring of the rendered output. 4. Create a StepDefinition. Create a StepsDefinition class create each of the code blocks needed for a rule(step) to be executable in Snakemake. When you have defined each block in your target workflow language task from step 1 , you can go ahead and create, for each of the code blocks required to run a Snakemake rule, a BlockDefinition to handle the rendering of each block. Example: In the Snakemake example, we have created: 1. InputDefinition - Handles the input block, which contains what is required for a rule to be executed. It also handles the params block since the code for extracting the input and params blocks is similar. 2. RunDefinition - Handles the run block which contains the instructions needed for this specific task. 3. OutputDefinition - Handles the output block which is required for the rule to be considered successfully finished. @define class StepDefinition : \"\"\"Represents a Snakemake-renderable step definition in a dewret workflow. Attributes: name (str): The name of the step. run (str): The run block definition for the step. params (List[str]): The parameter definitions for the step. output (list[str]: The output definition for the step. input (List[str]): The input definitions for the step. Methods: from_step(cls, step: Step) -> \"StepDefinition\": Constructs a StepDefinition object from a Step object, extracting step information and components from the step and converting them to Snakemake format. render(self) -> dict[str, MainTypes]: Renders the step definition as a dictionary suitable for use in Snakemake workflows. \"\"\" # You can consider each step as a separate rule. # Each field in this class represents a separate block in the rule definition name : str # name of the rule input : list [ str ] # Input block params : list [ str ] # Params block output : list [ str ] # Output block run : list [ str ] # Run block - where the instructions for the task are @classmethod def from_step ( cls , step : Step ) -> \"StepDefinition\" : \"\"\"Constructs a StepDefinition object from a Step. Args: step (Step): The Step object from which step information and components are extracted. Returns: StepDefinition: A StepDefinition object containing the converted step information and components. \"\"\" input_block = InputDefinition . from_step ( step ) . render () run_block = RunDefinition . from_task ( step . task ) . render () output_block = OutputDefinition . from_step ( step ) . render () return cls ( name = step . name , run = run_block , params = input_block [ \"params\" ], input = input_block [ \"inputs\" ], output = output_block , ) def render ( self ) -> dict [ str , MainTypes ]: \"\"\"Renders the step definition as a dictionary. Returns: dict[str, MainTypes]: A dictionary containing the components of the step definition, for use in Snakemake workflows. \"\"\" return { \"run\" : self . run , \"input\" : self . input , \"params\" : self . params , \"output\" : self . output , } 5. Create the Separate block definitions. In this step, you'll define classes to handle the rendering of each code block required for a rule (step) to be executable in the target workflow language. Each of these classes will encapsulate the logic for converting parts of a workflow step into the target language format. Example: For the Snakemake workflow language, we will define: InputDefinition: Handles the input block and parameter block. RunDefinition: Handles the run block. OutputDefinition: Handles the output block. InputDefinition: The InputDefinition class is responsible for rendering the inputs and parameters required for a Snakemake rule. @define class InputDefinition : \"\"\"Represents input and parameter definitions block for a Snakemake-renderable workflow step. Attributes: inputs (List[str]): A list of input definitions. params (List[str]): A list of parameter definitions. Methods: from_step(cls, step: Step) -> \"InputDefinition\": Constructs an InputDefinition object from a Step object, extracting inputs and parameters and converting them to Snakemake-compatible format. render(self) -> dict[str, str]: Renders the input and parameter definitions as a dictionary for use in Snakemake Input and Params blocks. \"\"\" # As we already mention input and params block have similar generation # So it made sence to encapsulate them into one Definition inputs : list [ str ] params : list [ str ] @classmethod def from_step ( cls , step : Step ) -> \"InputDefinition\" : \"\"\"Constructs an InputDefinition object from a Step. Args: step (Step): The Step object from which input and parameter block definitions are extracted. Returns: InputDefinition: An InputDefinition object. \"\"\" params = [] inputs = [] # The keys represent the names of the arguments of the @tasks in our snakemake_workflow.py. # The params represent the values. for key , param in step . arguments . items (): # We check if the param is a reference. # If it is then it's an input requirement for the rule to run, so we put it in the input block if isinstance ( param , Reference ): ref = ReferenceDefinition . from_reference ( param ) . render () . replace ( \"-\" , \"_\" ) . replace ( \"/out\" , \".output\" ) input = f \" { key } =rules. { ref } .output_file\" inputs . append ( input ) params . append ( input + \",\" ) # If it's not - we put it in the params block for use in the RunDefinition elif isinstance ( param , Raw ): customized = f \" { key } = { to_snakemake_type ( param ) } ,\" params . append ( customized ) # Since the params must be comma separated except the last one - we remove the last comma if params : params [ len ( params ) - 1 ] = params [ len ( params ) - 1 ] . replace ( \",\" , \"\" ) return cls ( inputs = inputs , params = params ) def render ( self ) -> dict [ str , list [ str ]]: \"\"\"Renders the input and parameter definitions as a dictionary. Returns: dict[str, list[MainTypes]]: A dictionary containing the input and parameter definitions, for use in Snakemake Input and Params blocks. \"\"\" return { \"inputs\" : self . inputs , \"params\" : self . params } RunDefinition: The RunDefinition class is responsible for rendering the run block, which contains the actual instructions for the task. @define class RunDefinition : # This is where we handle the execution of the task itself. \"\"\"Represents a Snakemake-renderable run block for a dewret workflow step. Attributes: method_name (str): The name of the method to be executed in the snakefile run block. rel_import (str): The relative import path of the method. args (List[str]): The arguments to be passed to the method. Methods: from_task(cls, task: Task) -> \"RunDefinition\": Constructs a RunDefinition object from a Task object, extracting method information and arguments from the task and converting them to Snakemake-compatible format. render(self) -> list[str]: A list containing the import statement and the method call statement, for use in Snakemake run block. \"\"\" method_name : str rel_import : str args : list [ str ] @classmethod def from_task ( cls , task : Task ) -> \"RunDefinition\" : \"\"\"Constructs a RunDefinition object from a Task. Args: task (Task): The Task object from which method information and arguments are extracted. Returns: RunDefinition: A RunDefinition object containing the converted method information and arguments. \"\"\" # Since we can import our snakemake_workflow.py @tasks we need the relative path relative_path = get_method_rel_path ( task . target ) # If we need to make any customization to the import rel_import = f \" { relative_path } \" args = get_method_args ( task . target ) signature = [ f \" { param_name } =params. { param_name } \" for param_name in args . parameters . keys () ] return cls ( method_name = task . name , rel_import = rel_import , args = signature ) def render ( self ) -> list [ str ]: \"\"\"Renders the run block as a list of strings. Returns: list[str]: A list containing the import statement and the method call statement, for use in Snakemake run block. \"\"\" signature = \", \" . join ( f \" { arg } \" for arg in self . args ) # The comma after the last element is mandatory for the structure of rule onces it's used in yaml.dump return [ f \"import { self . rel_import } \\n \" , f \" { self . rel_import } . { self . method_name } ( { signature } ) \\n \" , ] OutputDefinition: The OutputDefinition class is responsible for rendering the output block, which specifies the output files or results that indicate the rule has successfully completed. @define class OutputDefinition : \"\"\"Represents the output definition block for a Snakemake-renderable workflow step. Attributes: output_file (str): The output file definition. Methods: from_step(cls, step: Step) -> \"OutputDefinition\": Constructs an OutputDefinition object from a Step object, extracting and converting the output file definition to Snakemake-compatible format. render(self) -> list[str]: Renders the output definition as a list suitable for use in Snakemake Output block. \"\"\" output_file : str @classmethod def from_step ( cls , step : Step ) -> \"OutputDefinition\" : \"\"\"Constructs an OutputDefinition object from a Step. Args: step (Step): The Step object from which the output file definition is extracted. Returns: OutputDefinition: An OutputDefinition object, for use in Snakemake Output block. \"\"\" # Since snakemake commonly communicates using files. # Output file must always be called - `output_file` # Further code could be added to handled if it's a reference in case we want take care of multiple tasks writing to the same output file. output_file = step . arguments [ \"output_file\" ] if isinstance ( output_file , Raw ): args = to_snakemake_type ( output_file ) return cls ( output_file = args ) def render ( self ) -> list [ str ]: \"\"\"Renders the output definition as a list. Returns: list[str]: A list containing the output file definition, for use in a Snakemake Output block. \"\"\" # The comma after the last element is mandatory for the structure of rule onces it's used in yaml.dump # It adds the new line to the output block return [ f \"output_file= { self . output_file } \" , ] Integrate these block definitions into the StepDefinition class as demonstrated in Step 3 . Each StepDefinition will use these block definitions to render the complete step in the target workflow language. 6. Helper methods. In this step, you'll define helper methods that will assist you in converting workflow components into the target workflow language format. In our case these methods will handle type conversion, extracting method arguments, and computing relative paths. Example: We'll define the following helper methods for our Snakemake renderer: to_snakemake_type(param: Raw) -> str: Converts a raw type to a Snakemake-compatible Python type. get_method_args(func: Lazy) -> inspect.Signature: Retrieves the argument names and types of a lazy-evaluatable function. get_method_rel_path(func: Lazy) -> str: Computes the relative path of the module containing the given function. Type Conversion Helper: # Basic types returned from dewret will look like this \"str|valueOfParam\". # We'll need to convert them. def to_Snakemake_type ( param : Raw ) -> str : typ = str ( param ) if typ . __contains__ ( \"str\" ): return f '\" { typ . replace ( \"str|\" , \"\" ) } \"' elif typ . __contains__ ( \"bool\" ): return typ . replace ( \"bool|\" , \"\" ) elif typ . __contains__ ( \"dict\" ): return typ . replace ( \"dict|\" , \"\" ) elif typ . __contains__ ( \"list\" ): return typ . replace ( \"list|\" , \"\" ) elif typ . __contains__ ( \"float\" ): return typ . replace ( \"float|\" , \"\" ) elif typ . __contains__ ( \"int\" ): return typ . replace ( \"int|\" , \"\" ) else : raise TypeError ( f \"Cannot render complex type ( { typ } )\" ) Argument Extraction Helper: # We need to get the signature of the method. def get_method_args ( func : Lazy ) -> inspect . Signature : args = inspect . signature ( func ) return args Relative Path Computation Helper: # Computes the relative path def get_method_rel_path ( func : Lazy ) -> str : source_file = inspect . getsourcefile ( func ) if source_file : relative_path = os . path . relpath ( source_file , start = os . getcwd ()) module_name = os . path . splitext ( relative_path )[ 0 ] . replace ( os . path . sep , \".\" ) return module_name Imports and custom types required in the SMK example: import os import yaml import inspect import typing from attrs import define from dewret.utils import Raw , BasicType from dewret.workflow import Lazy from dewret.workflow import Reference , Workflow , Step , Task RawType = BasicType | list [ str ] | list [ \"RawType\" ] | dict [ str , \"RawType\" ] To run this example: Import the snakemake renderer into your @tasks file There's an example in snakemake_tasks.py Run it: python snakemake_tasks.py","title":"Renderer Tutorial"},{"location":"docs/renderer_tutorial/#step-by-step-guide-to-writing-a-custom-renderer","text":"","title":"Step-by-Step Guide to Writing a Custom Renderer"},{"location":"docs/renderer_tutorial/#1-understand-the-target-workflow-language","text":"Before writing any code, it is essential to fully understand the target workflow language. This includes syntax, structure, and specific requirements. By breaking down each key dewret.workflow task into smaller components, you can better map your workflow definitions to the target language.","title":"1. Understand the Target Workflow Language"},{"location":"docs/renderer_tutorial/#example","text":"In Snakemake, a workflow task is generally created by: Defining the task. - rule process_data Defining the input required for the rule to run(dependencies). - input: \"data/raw_data.txt\" Defining the output required for the rule to be considered finished. - output: \"data/processed_data.txt\" Defining the actual work that the task will do. - in this case: shell: ... rule process_data: # Example Snakemake rule/task input: \"data/raw_data.txt\" output: output_file = \"data/processed_data.txt\" run: with open ( output.output_file, \"w\" ) as f: f.write ( \"data\" ) return output_file","title":"Example:"},{"location":"docs/renderer_tutorial/#2-create-workflowdefinition","text":"The WorkflowDefinition class is responsible for transforming each step from a constructed dewret workflow into an executable step in the target workflow language (e.g. a Snakemake rule). This class should encapsulate workflow-level information, such as the list of steps to be executed, and any workflow-scope input/ouput. It should also contain a class method that initializes the WorkflowDefinition from an dewret Workflow (such as from_workflow below), and a method that renders the workflow as a Python dict (as in the render method below).","title":"2. Create WorkflowDefinition."},{"location":"docs/renderer_tutorial/#example_1","text":"@define class WorkflowDefinition : steps : list [ StepDefinition ] # Returns a WorkflowDefinition instanace. # Steps contains all of the tasks you want to convert to the target WL tasks. @classmethod def from_workflow ( cls , workflow : Workflow ) -> \"WorkflowDefinition\" : return cls ( steps = [ StepDefinition . from_step ( step ) for step in workflow . steps ]) # Returns each task as a Snakemake executable rule. def render ( self ) -> dict [ str , RawType ]: return { f \"rule { step . name . replace ( \"-\" , \"_\" ) } \" : step . render () for step in self . steps }","title":"Example:"},{"location":"docs/renderer_tutorial/#3-ensuring-our-module-is-recognized-as-a-render-module","text":"To have our custom renderer identified by Dewret as a valid renderer, we need to implement the BaseRenderModule along with one of the two protocols: RawRenderModule or StructuredRenderModule .","title":"3.  Ensuring Our Module is Recognized as a Render Module"},{"location":"docs/renderer_tutorial/#implementing-baserendermodule","text":"The BaseRenderModule defines the foundation for a custom renderer. To implement this protocol, we need to define the default_config() method, which provides default configurations for our renderer. def default_config () -> CWLRendererConfiguration : \"\"\"Default configuration for this renderer. This is a hook-like call to give a configuration dict that this renderer will respect, and sets any necessary default values. Returns: a dict with (preferably) raw type structures to enable easy setting from YAML/JSON. \"\"\" return { \"allow_complex_types\" : False , \"factories_as_params\" : False , } After implementing BaseRenderModule , you need to implement either the RawRenderModule or StructuredRenderModule protocol, depending on how you want to handle the workflow rendering.","title":"Implementing BaseRenderModule"},{"location":"docs/renderer_tutorial/#implementing-either-rawrendermodule-or-structuredrendermodule","text":"The StructuredRenderModule is designed for structured workflows that are directly ready to be output in the respective format (e.g., CWL, Snakemake, etc.). The key method to implement is render , which converts a workflow into a structured, serializable format. def render ( self , workflow : WorkflowProtocol , ** kwargs : RenderConfiguration ) -> dict [ str , dict [ str , RawType ]]: \"\"\"Turn a workflow into a serializable structure. Returns: one or more subworkflows with a `__root__` key representing the outermost workflow, at least. \"\"\" ... In this method: - You receive a workflow and potentially some optional configurations. - You return a dictionary where the __root__ key holds the primary workflow and any additional subworkflows are nested inside the returned structure. If you prefer more flexibility and want the structuring to be handled by the user, you can implement the RawRenderModule protocol. This requires defining the render_raw method, which converts a workflow into raw, flat strings. def render_raw ( self , workflow : WorkflowProtocol , ** kwargs : RenderConfiguration ) -> dict [ str , str ]: \"\"\"Turn a workflow into flat strings. Returns: one or more subworkflows with a `__root__` key representing the outermost workflow, at least. \"\"\" ... In this method: The workflow is rendered as raw, unstructured strings. The user is responsible for handling the structuring of the rendered output.","title":"Implementing either RawRenderModule or StructuredRenderModule"},{"location":"docs/renderer_tutorial/#4-create-a-stepdefinition","text":"Create a StepsDefinition class create each of the code blocks needed for a rule(step) to be executable in Snakemake. When you have defined each block in your target workflow language task from step 1 , you can go ahead and create, for each of the code blocks required to run a Snakemake rule, a BlockDefinition to handle the rendering of each block.","title":"4. Create a StepDefinition."},{"location":"docs/renderer_tutorial/#example_2","text":"In the Snakemake example, we have created: 1. InputDefinition - Handles the input block, which contains what is required for a rule to be executed. It also handles the params block since the code for extracting the input and params blocks is similar. 2. RunDefinition - Handles the run block which contains the instructions needed for this specific task. 3. OutputDefinition - Handles the output block which is required for the rule to be considered successfully finished. @define class StepDefinition : \"\"\"Represents a Snakemake-renderable step definition in a dewret workflow. Attributes: name (str): The name of the step. run (str): The run block definition for the step. params (List[str]): The parameter definitions for the step. output (list[str]: The output definition for the step. input (List[str]): The input definitions for the step. Methods: from_step(cls, step: Step) -> \"StepDefinition\": Constructs a StepDefinition object from a Step object, extracting step information and components from the step and converting them to Snakemake format. render(self) -> dict[str, MainTypes]: Renders the step definition as a dictionary suitable for use in Snakemake workflows. \"\"\" # You can consider each step as a separate rule. # Each field in this class represents a separate block in the rule definition name : str # name of the rule input : list [ str ] # Input block params : list [ str ] # Params block output : list [ str ] # Output block run : list [ str ] # Run block - where the instructions for the task are @classmethod def from_step ( cls , step : Step ) -> \"StepDefinition\" : \"\"\"Constructs a StepDefinition object from a Step. Args: step (Step): The Step object from which step information and components are extracted. Returns: StepDefinition: A StepDefinition object containing the converted step information and components. \"\"\" input_block = InputDefinition . from_step ( step ) . render () run_block = RunDefinition . from_task ( step . task ) . render () output_block = OutputDefinition . from_step ( step ) . render () return cls ( name = step . name , run = run_block , params = input_block [ \"params\" ], input = input_block [ \"inputs\" ], output = output_block , ) def render ( self ) -> dict [ str , MainTypes ]: \"\"\"Renders the step definition as a dictionary. Returns: dict[str, MainTypes]: A dictionary containing the components of the step definition, for use in Snakemake workflows. \"\"\" return { \"run\" : self . run , \"input\" : self . input , \"params\" : self . params , \"output\" : self . output , }","title":"Example:"},{"location":"docs/renderer_tutorial/#5-create-the-separate-block-definitions","text":"In this step, you'll define classes to handle the rendering of each code block required for a rule (step) to be executable in the target workflow language. Each of these classes will encapsulate the logic for converting parts of a workflow step into the target language format.","title":"5. Create the Separate block definitions."},{"location":"docs/renderer_tutorial/#example_3","text":"For the Snakemake workflow language, we will define: InputDefinition: Handles the input block and parameter block. RunDefinition: Handles the run block. OutputDefinition: Handles the output block.","title":"Example:"},{"location":"docs/renderer_tutorial/#inputdefinition","text":"The InputDefinition class is responsible for rendering the inputs and parameters required for a Snakemake rule. @define class InputDefinition : \"\"\"Represents input and parameter definitions block for a Snakemake-renderable workflow step. Attributes: inputs (List[str]): A list of input definitions. params (List[str]): A list of parameter definitions. Methods: from_step(cls, step: Step) -> \"InputDefinition\": Constructs an InputDefinition object from a Step object, extracting inputs and parameters and converting them to Snakemake-compatible format. render(self) -> dict[str, str]: Renders the input and parameter definitions as a dictionary for use in Snakemake Input and Params blocks. \"\"\" # As we already mention input and params block have similar generation # So it made sence to encapsulate them into one Definition inputs : list [ str ] params : list [ str ] @classmethod def from_step ( cls , step : Step ) -> \"InputDefinition\" : \"\"\"Constructs an InputDefinition object from a Step. Args: step (Step): The Step object from which input and parameter block definitions are extracted. Returns: InputDefinition: An InputDefinition object. \"\"\" params = [] inputs = [] # The keys represent the names of the arguments of the @tasks in our snakemake_workflow.py. # The params represent the values. for key , param in step . arguments . items (): # We check if the param is a reference. # If it is then it's an input requirement for the rule to run, so we put it in the input block if isinstance ( param , Reference ): ref = ReferenceDefinition . from_reference ( param ) . render () . replace ( \"-\" , \"_\" ) . replace ( \"/out\" , \".output\" ) input = f \" { key } =rules. { ref } .output_file\" inputs . append ( input ) params . append ( input + \",\" ) # If it's not - we put it in the params block for use in the RunDefinition elif isinstance ( param , Raw ): customized = f \" { key } = { to_snakemake_type ( param ) } ,\" params . append ( customized ) # Since the params must be comma separated except the last one - we remove the last comma if params : params [ len ( params ) - 1 ] = params [ len ( params ) - 1 ] . replace ( \",\" , \"\" ) return cls ( inputs = inputs , params = params ) def render ( self ) -> dict [ str , list [ str ]]: \"\"\"Renders the input and parameter definitions as a dictionary. Returns: dict[str, list[MainTypes]]: A dictionary containing the input and parameter definitions, for use in Snakemake Input and Params blocks. \"\"\" return { \"inputs\" : self . inputs , \"params\" : self . params }","title":"InputDefinition:"},{"location":"docs/renderer_tutorial/#rundefinition","text":"The RunDefinition class is responsible for rendering the run block, which contains the actual instructions for the task. @define class RunDefinition : # This is where we handle the execution of the task itself. \"\"\"Represents a Snakemake-renderable run block for a dewret workflow step. Attributes: method_name (str): The name of the method to be executed in the snakefile run block. rel_import (str): The relative import path of the method. args (List[str]): The arguments to be passed to the method. Methods: from_task(cls, task: Task) -> \"RunDefinition\": Constructs a RunDefinition object from a Task object, extracting method information and arguments from the task and converting them to Snakemake-compatible format. render(self) -> list[str]: A list containing the import statement and the method call statement, for use in Snakemake run block. \"\"\" method_name : str rel_import : str args : list [ str ] @classmethod def from_task ( cls , task : Task ) -> \"RunDefinition\" : \"\"\"Constructs a RunDefinition object from a Task. Args: task (Task): The Task object from which method information and arguments are extracted. Returns: RunDefinition: A RunDefinition object containing the converted method information and arguments. \"\"\" # Since we can import our snakemake_workflow.py @tasks we need the relative path relative_path = get_method_rel_path ( task . target ) # If we need to make any customization to the import rel_import = f \" { relative_path } \" args = get_method_args ( task . target ) signature = [ f \" { param_name } =params. { param_name } \" for param_name in args . parameters . keys () ] return cls ( method_name = task . name , rel_import = rel_import , args = signature ) def render ( self ) -> list [ str ]: \"\"\"Renders the run block as a list of strings. Returns: list[str]: A list containing the import statement and the method call statement, for use in Snakemake run block. \"\"\" signature = \", \" . join ( f \" { arg } \" for arg in self . args ) # The comma after the last element is mandatory for the structure of rule onces it's used in yaml.dump return [ f \"import { self . rel_import } \\n \" , f \" { self . rel_import } . { self . method_name } ( { signature } ) \\n \" , ]","title":"RunDefinition:"},{"location":"docs/renderer_tutorial/#outputdefinition","text":"The OutputDefinition class is responsible for rendering the output block, which specifies the output files or results that indicate the rule has successfully completed. @define class OutputDefinition : \"\"\"Represents the output definition block for a Snakemake-renderable workflow step. Attributes: output_file (str): The output file definition. Methods: from_step(cls, step: Step) -> \"OutputDefinition\": Constructs an OutputDefinition object from a Step object, extracting and converting the output file definition to Snakemake-compatible format. render(self) -> list[str]: Renders the output definition as a list suitable for use in Snakemake Output block. \"\"\" output_file : str @classmethod def from_step ( cls , step : Step ) -> \"OutputDefinition\" : \"\"\"Constructs an OutputDefinition object from a Step. Args: step (Step): The Step object from which the output file definition is extracted. Returns: OutputDefinition: An OutputDefinition object, for use in Snakemake Output block. \"\"\" # Since snakemake commonly communicates using files. # Output file must always be called - `output_file` # Further code could be added to handled if it's a reference in case we want take care of multiple tasks writing to the same output file. output_file = step . arguments [ \"output_file\" ] if isinstance ( output_file , Raw ): args = to_snakemake_type ( output_file ) return cls ( output_file = args ) def render ( self ) -> list [ str ]: \"\"\"Renders the output definition as a list. Returns: list[str]: A list containing the output file definition, for use in a Snakemake Output block. \"\"\" # The comma after the last element is mandatory for the structure of rule onces it's used in yaml.dump # It adds the new line to the output block return [ f \"output_file= { self . output_file } \" , ] Integrate these block definitions into the StepDefinition class as demonstrated in Step 3 . Each StepDefinition will use these block definitions to render the complete step in the target workflow language.","title":"OutputDefinition:"},{"location":"docs/renderer_tutorial/#6-helper-methods","text":"In this step, you'll define helper methods that will assist you in converting workflow components into the target workflow language format. In our case these methods will handle type conversion, extracting method arguments, and computing relative paths.","title":"6. Helper methods."},{"location":"docs/renderer_tutorial/#example_4","text":"We'll define the following helper methods for our Snakemake renderer: to_snakemake_type(param: Raw) -> str: Converts a raw type to a Snakemake-compatible Python type. get_method_args(func: Lazy) -> inspect.Signature: Retrieves the argument names and types of a lazy-evaluatable function. get_method_rel_path(func: Lazy) -> str: Computes the relative path of the module containing the given function.","title":"Example:"},{"location":"docs/renderer_tutorial/#type-conversion-helper","text":"# Basic types returned from dewret will look like this \"str|valueOfParam\". # We'll need to convert them. def to_Snakemake_type ( param : Raw ) -> str : typ = str ( param ) if typ . __contains__ ( \"str\" ): return f '\" { typ . replace ( \"str|\" , \"\" ) } \"' elif typ . __contains__ ( \"bool\" ): return typ . replace ( \"bool|\" , \"\" ) elif typ . __contains__ ( \"dict\" ): return typ . replace ( \"dict|\" , \"\" ) elif typ . __contains__ ( \"list\" ): return typ . replace ( \"list|\" , \"\" ) elif typ . __contains__ ( \"float\" ): return typ . replace ( \"float|\" , \"\" ) elif typ . __contains__ ( \"int\" ): return typ . replace ( \"int|\" , \"\" ) else : raise TypeError ( f \"Cannot render complex type ( { typ } )\" )","title":"Type Conversion Helper:"},{"location":"docs/renderer_tutorial/#argument-extraction-helper","text":"# We need to get the signature of the method. def get_method_args ( func : Lazy ) -> inspect . Signature : args = inspect . signature ( func ) return args","title":"Argument Extraction Helper:"},{"location":"docs/renderer_tutorial/#relative-path-computation-helper","text":"# Computes the relative path def get_method_rel_path ( func : Lazy ) -> str : source_file = inspect . getsourcefile ( func ) if source_file : relative_path = os . path . relpath ( source_file , start = os . getcwd ()) module_name = os . path . splitext ( relative_path )[ 0 ] . replace ( os . path . sep , \".\" ) return module_name","title":"Relative Path Computation Helper:"},{"location":"docs/renderer_tutorial/#imports-and-custom-types-required-in-the-smk-example","text":"import os import yaml import inspect import typing from attrs import define from dewret.utils import Raw , BasicType from dewret.workflow import Lazy from dewret.workflow import Reference , Workflow , Step , Task RawType = BasicType | list [ str ] | list [ \"RawType\" ] | dict [ str , \"RawType\" ]","title":"Imports and custom types required in the SMK example:"},{"location":"docs/renderer_tutorial/#to-run-this-example","text":"Import the snakemake renderer into your @tasks file There's an example in snakemake_tasks.py Run it: python snakemake_tasks.py","title":"To run this example:"},{"location":"docs/renderers/","text":"Renderers Renderers are a function that takes a task , which can be assumed to have a __workflow__ member of type Workflow , and return a YAML-serializable nested dict structure. CWL The default renderer is for the Common Workflow Language. It implements a very small subset of functionality, and is not yet strictly standards compliant. It assumes that all run names can be interpreted in the context of the workflow module's global scope. Custom ...","title":"Renderers"},{"location":"docs/renderers/#renderers","text":"Renderers are a function that takes a task , which can be assumed to have a __workflow__ member of type Workflow , and return a YAML-serializable nested dict structure.","title":"Renderers"},{"location":"docs/renderers/#cwl","text":"The default renderer is for the Common Workflow Language. It implements a very small subset of functionality, and is not yet strictly standards compliant. It assumes that all run names can be interpreted in the context of the workflow module's global scope.","title":"CWL"},{"location":"docs/renderers/#custom","text":"...","title":"Custom"},{"location":"docs/workflows/","text":"Workflows Description A dewret workflow is composed of one or more steps that may make use of both local and global parameters. Each step is defined by a dewret task that is created by using the @task() decorator, and each task may be used by multiple steps. Setup We can pull in dewret tools to produce CWL with a small number of imports. >>> import sys >>> import yaml >>> from dewret.tasks import task , construct >>> from dewret.workflow import param >>> from dewret.renderers.cwl import render Dependencies Specifying step interdependencies is possible by combining lazy-evaluated function calls. The output series of steps is not guaranteed to be in order of execution. Dewret hashes the parameters to identify and unify steps. This lets you do, for example: graph TD A[increment] --> B[double] A[increment] --> C[mod10] B[double] --> D[sum] C[mod10] --> D[sum] In code, this would be: >>> import sys >>> import yaml >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> @task () ... def increment ( num : int ) -> int : ... \"\"\"Increment an integer.\"\"\" ... return num + 1 >>> >>> @task () ... def double ( num : int ) -> int : ... \"\"\"Double an integer.\"\"\" ... return 2 * num >>> >>> @task () ... def mod10 ( num : int ) -> int : ... \"\"\"Take num mod 10.\"\"\" ... return num % 10 >>> >>> @task () ... def sum ( left : int , right : int ) -> int : ... \"\"\"Add two integers.\"\"\" ... return left + right >>> >>> result = sum ( ... left = double ( num = increment ( num = 23 )), ... right = mod10 ( num = increment ( num = 23 )) ... ) >>> wkflw = construct ( result , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : increment - 1 - num : default : 23 label : num type : int outputs : out : label : out outputSource : sum - 1 / out type : int steps : double - 1 : in : num : source : increment - 1 / out out : - out run : double increment - 1 : in : num : source : increment - 1 - num out : - out run : increment mod10 - 1 : in : num : source : increment - 1 / out out : - out run : mod10 sum - 1 : in : left : source : double - 1 / out right : source : mod10 - 1 / out out : - out run : sum Notice that the increment tasks appears twice in the CWL workflow definition, being referenced twice in the python code above. This duplication can be avoided by explicitly indicating that the parameters are the same, with the param function. >>> import sys >>> import yaml >>> from dewret.workflow import param >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> @task () ... def increment ( num : int ) -> int : ... \"\"\"Increment an integer.\"\"\" ... return num + 1 >>> >>> @task () ... def double ( num : int ) -> int : ... \"\"\"Double an integer.\"\"\" ... return 2 * num >>> >>> @task () ... def mod10 ( num : int ) -> int : ... \"\"\"Take num mod 10.\"\"\" ... return num % 10 >>> >>> @task () ... def sum ( left : int , right : int ) -> int : ... \"\"\"Add two integers.\"\"\" ... return left + right >>> >>> num = param ( \"num\" , default = 3 ) >>> result = sum ( ... left = double ( num = increment ( num = num )), ... right = mod10 ( num = increment ( num = num )) ... ) >>> wkflw = construct ( result , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : num : default : 3 label : num type : int outputs : out : label : out outputSource : sum - 1 / out type : int steps : double - 1 : in : num : source : increment - 1 / out out : - out run : double increment - 1 : in : num : source : num out : - out run : increment mod10 - 1 : in : num : source : increment - 1 / out out : - out run : mod10 sum - 1 : in : left : source : double - 1 / out right : source : mod10 - 1 / out out : - out run : sum Parameters The tool will spot global variables that you have used when building your tasks, and treat them as parameters. It will try to get the type from the typehint, or the value that you have set it to. This only works for basic types (and dict/lists of those). While global variables are implicit input to the Python function note that : in CWL, they will be rendered as explicit global input to a step as input, they are read-only, and must not be updated For example: >>> import sys >>> import yaml >>> from dewret.workflow import param >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> INPUT_NUM = 3 >>> @task () ... def rotate ( num : int ) -> int : ... \"\"\"Rotate an integer.\"\"\" ... return ( num + INPUT_NUM ) % INPUT_NUM >>> >>> result = rotate ( num = 5 ) >>> wkflw = construct ( result , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : INPUT_NUM : default : 3 label : INPUT_NUM type : int rotate - 1 - num : default : 5 label : num type : int outputs : out : label : out outputSource : rotate - 1 / out type : int steps : rotate - 1 : in : INPUT_NUM : source : INPUT_NUM num : source : rotate - 1 - num out : - out run : rotate Nested tasks When you wish to combine tasks together programmatically, you can use nested tasks. These are run at render time, not execution time. In other words, they do not appear in the final graph, and so must only combine other tasks. For example: graph TD A[rotate] --> B[rotate] B[rotate] --> C[double_rotate] As code: >>> import sys >>> import yaml >>> from dewret.core import set_configuration >>> from dewret.tasks import task , construct , workflow >>> from dewret.renderers.cwl import render >>> INPUT_NUM = 3 >>> @task () ... def rotate ( num : int ) -> int : ... \"\"\"Rotate an integer.\"\"\" ... return ( num + INPUT_NUM ) % INPUT_NUM >>> >>> @workflow () ... def double_rotate ( num : int ) -> int : ... \"\"\"Rotate an integer twice.\"\"\" ... return rotate ( num = rotate ( num = num )) >>> >>> with set_configuration ( flatten_all_nested = True ): ... result = double_rotate ( num = 3 ) ... wkflw = construct ( result , simplify_ids = True ) ... cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : INPUT_NUM : default : 3 label : INPUT_NUM type : int num : default : 3 label : num type : int outputs : out : label : out outputSource : rotate - 1 / out type : int steps : rotate - 1 : in : INPUT_NUM : source : INPUT_NUM num : source : rotate - 2 / out out : - out run : rotate rotate - 2 : in : INPUT_NUM : source : INPUT_NUM num : source : num out : - out run : rotate Note that, as with all dewret calculations, only the steps necessary to achieve the ultimate output are included in the final graph. Therefore, nested tasks must return a step execution (task that is being called) that forces any other calculations you wish to happen. In other words, if a task in a nested task does not have an impact on the return value, it will disappear . For example, the following code renders the same workflow as in the previous example: @workflow () def double_rotate ( num : int ) -> int : \"\"\"Rotate an integer twice.\"\"\" unused_var = increment ( num = num ) return rotate ( num = rotate ( num = num )) Step Output Fields Each step, by default, is treated as having a single result. However, we allow a mechanism for specifying multiple fields, using attrs or dataclasses . Where needed, fields can be accessed outside of tasks by dot notation and dewret will map that access to a specific output field in CWL. Note that in the example below, shuffle is still only seen once in the graph: graph TD A[shuffle] --> B[hearts] A[shuffle] --> C[diamonds] B[hearts] --> D[sum] C[diamonds] --> D[sum] As code: >>> import sys >>> import yaml >>> from attrs import define >>> from numpy import random >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> @task () ... def shuffle ( max_cards_per_suit : int ) -> PackResult : ... \"\"\"Fill a random pile from a card deck, suit by suit.\"\"\" ... return PackResult ( ... hearts = random . randint ( max_cards_per_suit ), ... clubs = random . randint ( max_cards_per_suit ), ... spades = random . randint ( max_cards_per_suit ), ... diamonds = random . randint ( max_cards_per_suit ) ... ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> red_total = sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . hearts , ... right = shuffle ( max_cards_per_suit = 13 ) . diamonds ... ) >>> wkflw = construct ( red_total , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : shuffle - 1 - max_cards_per_suit : default : 13 label : max_cards_per_suit type : int outputs : out : label : out outputSource : sum - 1 / out type : int steps : shuffle - 1 : in : max_cards_per_suit : source : shuffle - 1 - max_cards_per_suit out : clubs : label : clubs type : int diamonds : label : diamonds type : int hearts : label : hearts type : int spades : label : spades type : int run : shuffle sum - 1 : in : left : source : shuffle - 1 / hearts right : source : shuffle - 1 / diamonds out : - out run : sum Here, we show the same example with dataclasses . >>> import sys >>> import yaml >>> from dataclasses import dataclass >>> from numpy import random >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> @dataclass ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> @task () ... def shuffle ( max_cards_per_suit : int ) -> PackResult : ... \"\"\"Fill a random pile from a card deck, suit by suit.\"\"\" ... return PackResult ( ... hearts = random . randint ( max_cards_per_suit ), ... clubs = random . randint ( max_cards_per_suit ), ... spades = random . randint ( max_cards_per_suit ), ... diamonds = random . randint ( max_cards_per_suit ) ... ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> red_total = sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . hearts , ... right = shuffle ( max_cards_per_suit = 13 ) . diamonds ... ) >>> wkflw = construct ( red_total , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : shuffle - 1 - max_cards_per_suit : default : 13 label : max_cards_per_suit type : int outputs : out : label : out outputSource : sum - 1 / out type : int steps : shuffle - 1 : in : max_cards_per_suit : source : shuffle - 1 - max_cards_per_suit out : clubs : label : clubs type : int diamonds : label : diamonds type : int hearts : label : hearts type : int spades : label : spades type : int run : shuffle sum - 1 : in : left : source : shuffle - 1 / hearts right : source : shuffle - 1 / diamonds out : - out run : sum Subworkflow A special form of nested task is available to help divide up more complex workflows: the subworkflow . By wrapping logic in subflows, dewret will produce multiple output workflows that reference each other. >>> import sys >>> import yaml >>> from attrs import define >>> from numpy import random >>> from dewret.tasks import task , construct , workflow >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> @task () ... def shuffle ( max_cards_per_suit : int ) -> PackResult : ... \"\"\"Fill a random pile from a card deck, suit by suit.\"\"\" ... return PackResult ( ... hearts = random . randint ( max_cards_per_suit ), ... clubs = random . randint ( max_cards_per_suit ), ... spades = random . randint ( max_cards_per_suit ), ... diamonds = random . randint ( max_cards_per_suit ) ... ) >>> @workflow () ... def red_total () -> int : ... return sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . hearts , ... right = shuffle ( max_cards_per_suit = 13 ) . diamonds ... ) >>> @workflow () ... def black_total () -> int : ... return sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . spades , ... right = shuffle ( max_cards_per_suit = 13 ) . clubs ... ) >>> total = sum ( left = red_total (), right = black_total ()) >>> wkflw = construct ( total , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : {} outputs : out : label : out outputSource : sum - 1 / out type : int steps : black_total - 1 : in : {} out : - out run : black_total red_total - 1 : in : {} out : - out run : red_total sum - 1 : in : left : source : red_total - 1 / out right : source : black_total - 1 / out out : - out run : sum As we have used subworkflow to wrap the colour totals, the outer workflow contains references to them only. The subworkflows are now returned by render as a second term. >>> import sys >>> import yaml >>> from attrs import define >>> from numpy import random >>> from dewret.tasks import task , construct , workflow >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> @task () ... def shuffle ( max_cards_per_suit : int ) -> PackResult : ... \"\"\"Fill a random pile from a card deck, suit by suit.\"\"\" ... return PackResult ( ... hearts = random . randint ( max_cards_per_suit ), ... clubs = random . randint ( max_cards_per_suit ), ... spades = random . randint ( max_cards_per_suit ), ... diamonds = random . randint ( max_cards_per_suit ) ... ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> @workflow () ... def red_total () -> int : ... return sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . hearts , ... right = shuffle ( max_cards_per_suit = 13 ) . diamonds ... ) >>> @workflow () ... def black_total () -> int : ... return sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . spades , ... right = shuffle ( max_cards_per_suit = 13 ) . clubs ... ) >>> total = sum ( left = red_total (), right = black_total ()) >>> wkflw = construct ( total , simplify_ids = True ) >>> cwl = render ( wkflw ) >>> yaml . dump ( cwl [ \"red_total-1\" ], sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : {} outputs : out : label : out outputSource : sum - 1 - 1 / out type : int steps : shuffle - 1 - 1 : in : max_cards_per_suit : default : 13 out : clubs : label : clubs type : int diamonds : label : diamonds type : int hearts : label : hearts type : int spades : label : spades type : int run : shuffle sum - 1 - 1 : in : left : source : shuffle - 1 - 1 / hearts right : source : shuffle - 1 - 1 / diamonds out : - out run : sum Input Factories Sometimes we want to take complex Python input, not just raw types. Not all serialization support this, but the factory function lets us wrap a simple call, usually a constructor, that takes only raw arguments. This can then rendered as either a step or a parameter depending on whether the chosen renderer has the capability. Below is the default output, treating Pack as a task. >>> import sys >>> import yaml >>> from dewret.tasks import workflow , factory , workflow , construct , task >>> from attrs import define >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> Pack = factory ( PackResult ) >>> >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> @workflow () ... def black_total ( pack : PackResult ) -> int : ... return sum ( ... left = pack . spades , ... right = pack . clubs ... ) >>> pack = Pack ( hearts = 13 , spades = 13 , diamonds = 13 , clubs = 13 ) >>> wkflw = construct ( black_total ( pack = pack ), simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : PackResult - 1 - clubs : default : 13 label : clubs type : int PackResult - 1 - diamonds : default : 13 label : diamonds type : int PackResult - 1 - hearts : default : 13 label : hearts type : int PackResult - 1 - spades : default : 13 label : spades type : int outputs : out : label : out outputSource : black_total - 1 / out type : int steps : PackResult - 1 : in : clubs : source : PackResult - 1 - clubs diamonds : source : PackResult - 1 - diamonds hearts : source : PackResult - 1 - hearts spades : source : PackResult - 1 - spades out : clubs : label : clubs type : int diamonds : label : diamonds type : int hearts : label : hearts type : int spades : label : spades type : int run : PackResult black_total - 1 : in : pack : source : PackResult - 1 / out out : - out run : black_total The CWL renderer is also able to treat pack as a parameter, if complex types are allowed. >>> import sys >>> import yaml >>> from dewret.tasks import task , factory , workflow , construct >>> from attrs import define >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> Pack = factory ( PackResult ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> @workflow () ... def black_total ( pack : PackResult ) -> int : ... return sum ( ... left = pack . spades , ... right = pack . clubs ... ) >>> pack = Pack ( hearts = 13 , spades = 13 , diamonds = 13 , clubs = 13 ) >>> wkflw = construct ( black_total ( pack = pack ), simplify_ids = True ) >>> cwl = render ( wkflw , allow_complex_types = True , factories_as_params = True )[ \"black_total-1\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : pack : label : pack type : record outputs : out : label : out outputSource : sum - 1 - 1 / out type : int steps : sum - 1 - 1 : in : left : source : pack / spades right : source : pack / clubs out : - out run : sum","title":"Workflows"},{"location":"docs/workflows/#workflows","text":"","title":"Workflows"},{"location":"docs/workflows/#description","text":"A dewret workflow is composed of one or more steps that may make use of both local and global parameters. Each step is defined by a dewret task that is created by using the @task() decorator, and each task may be used by multiple steps.","title":"Description"},{"location":"docs/workflows/#setup","text":"We can pull in dewret tools to produce CWL with a small number of imports. >>> import sys >>> import yaml >>> from dewret.tasks import task , construct >>> from dewret.workflow import param >>> from dewret.renderers.cwl import render","title":"Setup"},{"location":"docs/workflows/#dependencies","text":"Specifying step interdependencies is possible by combining lazy-evaluated function calls. The output series of steps is not guaranteed to be in order of execution. Dewret hashes the parameters to identify and unify steps. This lets you do, for example: graph TD A[increment] --> B[double] A[increment] --> C[mod10] B[double] --> D[sum] C[mod10] --> D[sum] In code, this would be: >>> import sys >>> import yaml >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> @task () ... def increment ( num : int ) -> int : ... \"\"\"Increment an integer.\"\"\" ... return num + 1 >>> >>> @task () ... def double ( num : int ) -> int : ... \"\"\"Double an integer.\"\"\" ... return 2 * num >>> >>> @task () ... def mod10 ( num : int ) -> int : ... \"\"\"Take num mod 10.\"\"\" ... return num % 10 >>> >>> @task () ... def sum ( left : int , right : int ) -> int : ... \"\"\"Add two integers.\"\"\" ... return left + right >>> >>> result = sum ( ... left = double ( num = increment ( num = 23 )), ... right = mod10 ( num = increment ( num = 23 )) ... ) >>> wkflw = construct ( result , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : increment - 1 - num : default : 23 label : num type : int outputs : out : label : out outputSource : sum - 1 / out type : int steps : double - 1 : in : num : source : increment - 1 / out out : - out run : double increment - 1 : in : num : source : increment - 1 - num out : - out run : increment mod10 - 1 : in : num : source : increment - 1 / out out : - out run : mod10 sum - 1 : in : left : source : double - 1 / out right : source : mod10 - 1 / out out : - out run : sum Notice that the increment tasks appears twice in the CWL workflow definition, being referenced twice in the python code above. This duplication can be avoided by explicitly indicating that the parameters are the same, with the param function. >>> import sys >>> import yaml >>> from dewret.workflow import param >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> @task () ... def increment ( num : int ) -> int : ... \"\"\"Increment an integer.\"\"\" ... return num + 1 >>> >>> @task () ... def double ( num : int ) -> int : ... \"\"\"Double an integer.\"\"\" ... return 2 * num >>> >>> @task () ... def mod10 ( num : int ) -> int : ... \"\"\"Take num mod 10.\"\"\" ... return num % 10 >>> >>> @task () ... def sum ( left : int , right : int ) -> int : ... \"\"\"Add two integers.\"\"\" ... return left + right >>> >>> num = param ( \"num\" , default = 3 ) >>> result = sum ( ... left = double ( num = increment ( num = num )), ... right = mod10 ( num = increment ( num = num )) ... ) >>> wkflw = construct ( result , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : num : default : 3 label : num type : int outputs : out : label : out outputSource : sum - 1 / out type : int steps : double - 1 : in : num : source : increment - 1 / out out : - out run : double increment - 1 : in : num : source : num out : - out run : increment mod10 - 1 : in : num : source : increment - 1 / out out : - out run : mod10 sum - 1 : in : left : source : double - 1 / out right : source : mod10 - 1 / out out : - out run : sum","title":"Dependencies"},{"location":"docs/workflows/#parameters","text":"The tool will spot global variables that you have used when building your tasks, and treat them as parameters. It will try to get the type from the typehint, or the value that you have set it to. This only works for basic types (and dict/lists of those). While global variables are implicit input to the Python function note that : in CWL, they will be rendered as explicit global input to a step as input, they are read-only, and must not be updated For example: >>> import sys >>> import yaml >>> from dewret.workflow import param >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> INPUT_NUM = 3 >>> @task () ... def rotate ( num : int ) -> int : ... \"\"\"Rotate an integer.\"\"\" ... return ( num + INPUT_NUM ) % INPUT_NUM >>> >>> result = rotate ( num = 5 ) >>> wkflw = construct ( result , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : INPUT_NUM : default : 3 label : INPUT_NUM type : int rotate - 1 - num : default : 5 label : num type : int outputs : out : label : out outputSource : rotate - 1 / out type : int steps : rotate - 1 : in : INPUT_NUM : source : INPUT_NUM num : source : rotate - 1 - num out : - out run : rotate","title":"Parameters"},{"location":"docs/workflows/#nested-tasks","text":"When you wish to combine tasks together programmatically, you can use nested tasks. These are run at render time, not execution time. In other words, they do not appear in the final graph, and so must only combine other tasks. For example: graph TD A[rotate] --> B[rotate] B[rotate] --> C[double_rotate] As code: >>> import sys >>> import yaml >>> from dewret.core import set_configuration >>> from dewret.tasks import task , construct , workflow >>> from dewret.renderers.cwl import render >>> INPUT_NUM = 3 >>> @task () ... def rotate ( num : int ) -> int : ... \"\"\"Rotate an integer.\"\"\" ... return ( num + INPUT_NUM ) % INPUT_NUM >>> >>> @workflow () ... def double_rotate ( num : int ) -> int : ... \"\"\"Rotate an integer twice.\"\"\" ... return rotate ( num = rotate ( num = num )) >>> >>> with set_configuration ( flatten_all_nested = True ): ... result = double_rotate ( num = 3 ) ... wkflw = construct ( result , simplify_ids = True ) ... cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : INPUT_NUM : default : 3 label : INPUT_NUM type : int num : default : 3 label : num type : int outputs : out : label : out outputSource : rotate - 1 / out type : int steps : rotate - 1 : in : INPUT_NUM : source : INPUT_NUM num : source : rotate - 2 / out out : - out run : rotate rotate - 2 : in : INPUT_NUM : source : INPUT_NUM num : source : num out : - out run : rotate Note that, as with all dewret calculations, only the steps necessary to achieve the ultimate output are included in the final graph. Therefore, nested tasks must return a step execution (task that is being called) that forces any other calculations you wish to happen. In other words, if a task in a nested task does not have an impact on the return value, it will disappear . For example, the following code renders the same workflow as in the previous example: @workflow () def double_rotate ( num : int ) -> int : \"\"\"Rotate an integer twice.\"\"\" unused_var = increment ( num = num ) return rotate ( num = rotate ( num = num ))","title":"Nested tasks"},{"location":"docs/workflows/#step-output-fields","text":"Each step, by default, is treated as having a single result. However, we allow a mechanism for specifying multiple fields, using attrs or dataclasses . Where needed, fields can be accessed outside of tasks by dot notation and dewret will map that access to a specific output field in CWL. Note that in the example below, shuffle is still only seen once in the graph: graph TD A[shuffle] --> B[hearts] A[shuffle] --> C[diamonds] B[hearts] --> D[sum] C[diamonds] --> D[sum] As code: >>> import sys >>> import yaml >>> from attrs import define >>> from numpy import random >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> @task () ... def shuffle ( max_cards_per_suit : int ) -> PackResult : ... \"\"\"Fill a random pile from a card deck, suit by suit.\"\"\" ... return PackResult ( ... hearts = random . randint ( max_cards_per_suit ), ... clubs = random . randint ( max_cards_per_suit ), ... spades = random . randint ( max_cards_per_suit ), ... diamonds = random . randint ( max_cards_per_suit ) ... ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> red_total = sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . hearts , ... right = shuffle ( max_cards_per_suit = 13 ) . diamonds ... ) >>> wkflw = construct ( red_total , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : shuffle - 1 - max_cards_per_suit : default : 13 label : max_cards_per_suit type : int outputs : out : label : out outputSource : sum - 1 / out type : int steps : shuffle - 1 : in : max_cards_per_suit : source : shuffle - 1 - max_cards_per_suit out : clubs : label : clubs type : int diamonds : label : diamonds type : int hearts : label : hearts type : int spades : label : spades type : int run : shuffle sum - 1 : in : left : source : shuffle - 1 / hearts right : source : shuffle - 1 / diamonds out : - out run : sum Here, we show the same example with dataclasses . >>> import sys >>> import yaml >>> from dataclasses import dataclass >>> from numpy import random >>> from dewret.tasks import task , construct >>> from dewret.renderers.cwl import render >>> @dataclass ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> @task () ... def shuffle ( max_cards_per_suit : int ) -> PackResult : ... \"\"\"Fill a random pile from a card deck, suit by suit.\"\"\" ... return PackResult ( ... hearts = random . randint ( max_cards_per_suit ), ... clubs = random . randint ( max_cards_per_suit ), ... spades = random . randint ( max_cards_per_suit ), ... diamonds = random . randint ( max_cards_per_suit ) ... ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> red_total = sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . hearts , ... right = shuffle ( max_cards_per_suit = 13 ) . diamonds ... ) >>> wkflw = construct ( red_total , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : shuffle - 1 - max_cards_per_suit : default : 13 label : max_cards_per_suit type : int outputs : out : label : out outputSource : sum - 1 / out type : int steps : shuffle - 1 : in : max_cards_per_suit : source : shuffle - 1 - max_cards_per_suit out : clubs : label : clubs type : int diamonds : label : diamonds type : int hearts : label : hearts type : int spades : label : spades type : int run : shuffle sum - 1 : in : left : source : shuffle - 1 / hearts right : source : shuffle - 1 / diamonds out : - out run : sum","title":"Step Output Fields"},{"location":"docs/workflows/#subworkflow","text":"A special form of nested task is available to help divide up more complex workflows: the subworkflow . By wrapping logic in subflows, dewret will produce multiple output workflows that reference each other. >>> import sys >>> import yaml >>> from attrs import define >>> from numpy import random >>> from dewret.tasks import task , construct , workflow >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> @task () ... def shuffle ( max_cards_per_suit : int ) -> PackResult : ... \"\"\"Fill a random pile from a card deck, suit by suit.\"\"\" ... return PackResult ( ... hearts = random . randint ( max_cards_per_suit ), ... clubs = random . randint ( max_cards_per_suit ), ... spades = random . randint ( max_cards_per_suit ), ... diamonds = random . randint ( max_cards_per_suit ) ... ) >>> @workflow () ... def red_total () -> int : ... return sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . hearts , ... right = shuffle ( max_cards_per_suit = 13 ) . diamonds ... ) >>> @workflow () ... def black_total () -> int : ... return sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . spades , ... right = shuffle ( max_cards_per_suit = 13 ) . clubs ... ) >>> total = sum ( left = red_total (), right = black_total ()) >>> wkflw = construct ( total , simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : {} outputs : out : label : out outputSource : sum - 1 / out type : int steps : black_total - 1 : in : {} out : - out run : black_total red_total - 1 : in : {} out : - out run : red_total sum - 1 : in : left : source : red_total - 1 / out right : source : black_total - 1 / out out : - out run : sum As we have used subworkflow to wrap the colour totals, the outer workflow contains references to them only. The subworkflows are now returned by render as a second term. >>> import sys >>> import yaml >>> from attrs import define >>> from numpy import random >>> from dewret.tasks import task , construct , workflow >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> @task () ... def shuffle ( max_cards_per_suit : int ) -> PackResult : ... \"\"\"Fill a random pile from a card deck, suit by suit.\"\"\" ... return PackResult ( ... hearts = random . randint ( max_cards_per_suit ), ... clubs = random . randint ( max_cards_per_suit ), ... spades = random . randint ( max_cards_per_suit ), ... diamonds = random . randint ( max_cards_per_suit ) ... ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> @workflow () ... def red_total () -> int : ... return sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . hearts , ... right = shuffle ( max_cards_per_suit = 13 ) . diamonds ... ) >>> @workflow () ... def black_total () -> int : ... return sum ( ... left = shuffle ( max_cards_per_suit = 13 ) . spades , ... right = shuffle ( max_cards_per_suit = 13 ) . clubs ... ) >>> total = sum ( left = red_total (), right = black_total ()) >>> wkflw = construct ( total , simplify_ids = True ) >>> cwl = render ( wkflw ) >>> yaml . dump ( cwl [ \"red_total-1\" ], sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : {} outputs : out : label : out outputSource : sum - 1 - 1 / out type : int steps : shuffle - 1 - 1 : in : max_cards_per_suit : default : 13 out : clubs : label : clubs type : int diamonds : label : diamonds type : int hearts : label : hearts type : int spades : label : spades type : int run : shuffle sum - 1 - 1 : in : left : source : shuffle - 1 - 1 / hearts right : source : shuffle - 1 - 1 / diamonds out : - out run : sum","title":"Subworkflow"},{"location":"docs/workflows/#input-factories","text":"Sometimes we want to take complex Python input, not just raw types. Not all serialization support this, but the factory function lets us wrap a simple call, usually a constructor, that takes only raw arguments. This can then rendered as either a step or a parameter depending on whether the chosen renderer has the capability. Below is the default output, treating Pack as a task. >>> import sys >>> import yaml >>> from dewret.tasks import workflow , factory , workflow , construct , task >>> from attrs import define >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> Pack = factory ( PackResult ) >>> >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> @workflow () ... def black_total ( pack : PackResult ) -> int : ... return sum ( ... left = pack . spades , ... right = pack . clubs ... ) >>> pack = Pack ( hearts = 13 , spades = 13 , diamonds = 13 , clubs = 13 ) >>> wkflw = construct ( black_total ( pack = pack ), simplify_ids = True ) >>> cwl = render ( wkflw )[ \"__root__\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : PackResult - 1 - clubs : default : 13 label : clubs type : int PackResult - 1 - diamonds : default : 13 label : diamonds type : int PackResult - 1 - hearts : default : 13 label : hearts type : int PackResult - 1 - spades : default : 13 label : spades type : int outputs : out : label : out outputSource : black_total - 1 / out type : int steps : PackResult - 1 : in : clubs : source : PackResult - 1 - clubs diamonds : source : PackResult - 1 - diamonds hearts : source : PackResult - 1 - hearts spades : source : PackResult - 1 - spades out : clubs : label : clubs type : int diamonds : label : diamonds type : int hearts : label : hearts type : int spades : label : spades type : int run : PackResult black_total - 1 : in : pack : source : PackResult - 1 / out out : - out run : black_total The CWL renderer is also able to treat pack as a parameter, if complex types are allowed. >>> import sys >>> import yaml >>> from dewret.tasks import task , factory , workflow , construct >>> from attrs import define >>> from dewret.renderers.cwl import render >>> @define ... class PackResult : ... hearts : int ... clubs : int ... spades : int ... diamonds : int >>> >>> Pack = factory ( PackResult ) >>> @task () ... def sum ( left : int , right : int ) -> int : ... return left + right >>> >>> @workflow () ... def black_total ( pack : PackResult ) -> int : ... return sum ( ... left = pack . spades , ... right = pack . clubs ... ) >>> pack = Pack ( hearts = 13 , spades = 13 , diamonds = 13 , clubs = 13 ) >>> wkflw = construct ( black_total ( pack = pack ), simplify_ids = True ) >>> cwl = render ( wkflw , allow_complex_types = True , factories_as_params = True )[ \"black_total-1\" ] >>> yaml . dump ( cwl , sys . stdout , indent = 2 ) class : Workflow cwlVersion : v1 .2 inputs : pack : label : pack type : record outputs : out : label : out outputSource : sum - 1 - 1 / out type : int steps : sum - 1 - 1 : in : left : source : pack / spades right : source : pack / clubs out : - out run : sum","title":"Input Factories"},{"location":"reference/dewret/","text":"Module dewret dewret: DEclarative Workflow REndering Tool. Dewret allows certain workflows written in a dynamic style to be rendered to a static representation. Sub-modules dewret.annotations dewret.backends dewret.cli dewret.core dewret.render dewret.renderers dewret.tasks dewret.utils dewret.workflow","title":"Index"},{"location":"reference/dewret/#module-dewret","text":"dewret: DEclarative Workflow REndering Tool. Dewret allows certain workflows written in a dynamic style to be rendered to a static representation.","title":"Module dewret"},{"location":"reference/dewret/#sub-modules","text":"dewret.annotations dewret.backends dewret.cli dewret.core dewret.render dewret.renderers dewret.tasks dewret.utils dewret.workflow","title":"Sub-modules"},{"location":"reference/dewret/annotations/","text":"Module dewret.annotations Tooling for managing annotations. Provides FunctionAnalyser , a toolkit that takes a Callable and can interrogate it for annotations, with some intelligent searching beyond the obvious location. Variables AtRender Fixed T Classes FunctionAnalyser class FunctionAnalyser ( fn : Callable [ ... , Any ] ) Convenience class for analysing a function with reduced duplication of effort. Attributes Name Type Description Default _fn None the wrapped callable None _annotations None stored annotations for the function. None Instance variables free_vars Get the free variables for this Callable. globals Get the globals for this Callable. return_type Return type of the callable. Returns: expected type of the return value. unbound Get the globals for this Callable. Methods argument_has def argument_has ( self , arg : str , annotation : type , exhaustive : bool = False ) -> bool Check if the named argument has the given annotation. Parameters: Name Type Description Default arg None argument to retrieve. None annotation None Annotated to search for. None exhaustive None whether to check the globals and other modules. None get_all_imported_names def get_all_imported_names ( self ) -> dict [ str , tuple [ module , str ]] Find all of the annotations that were imported into this module. get_all_module_names def get_all_module_names ( self ) -> dict [ str , typing . Any ] Find all of the annotations within this module. get_argument_annotation def get_argument_annotation ( self , arg : str , exhaustive : bool = False ) -> Any Retrieve the annotations for this argument. Parameters: Name Type Description Default arg None name of the argument. None exhaustive None True if we should search outside the function itself, into the module globals, and into imported modules. None is_at_construct_arg def is_at_construct_arg ( self , arg : str , exhaustive : bool = False ) -> bool Convience function to check for AtConstruct , wrapping FunctionAnalyser.argument_has . with_new_globals def with_new_globals ( self , new_globals : dict [ str , typing . Any ] ) -> Callable [ ... , Any ] Create a Callable that will run the current Callable with new globals.","title":"Annotations"},{"location":"reference/dewret/annotations/#module-dewretannotations","text":"Tooling for managing annotations. Provides FunctionAnalyser , a toolkit that takes a Callable and can interrogate it for annotations, with some intelligent searching beyond the obvious location.","title":"Module dewret.annotations"},{"location":"reference/dewret/annotations/#variables","text":"AtRender Fixed T","title":"Variables"},{"location":"reference/dewret/annotations/#classes","text":"","title":"Classes"},{"location":"reference/dewret/annotations/#functionanalyser","text":"class FunctionAnalyser ( fn : Callable [ ... , Any ] ) Convenience class for analysing a function with reduced duplication of effort.","title":"FunctionAnalyser"},{"location":"reference/dewret/annotations/#attributes","text":"Name Type Description Default _fn None the wrapped callable None _annotations None stored annotations for the function. None","title":"Attributes"},{"location":"reference/dewret/annotations/#instance-variables","text":"free_vars Get the free variables for this Callable. globals Get the globals for this Callable. return_type Return type of the callable. Returns: expected type of the return value. unbound Get the globals for this Callable.","title":"Instance variables"},{"location":"reference/dewret/annotations/#methods","text":"","title":"Methods"},{"location":"reference/dewret/annotations/#argument_has","text":"def argument_has ( self , arg : str , annotation : type , exhaustive : bool = False ) -> bool Check if the named argument has the given annotation. Parameters: Name Type Description Default arg None argument to retrieve. None annotation None Annotated to search for. None exhaustive None whether to check the globals and other modules. None","title":"argument_has"},{"location":"reference/dewret/annotations/#get_all_imported_names","text":"def get_all_imported_names ( self ) -> dict [ str , tuple [ module , str ]] Find all of the annotations that were imported into this module.","title":"get_all_imported_names"},{"location":"reference/dewret/annotations/#get_all_module_names","text":"def get_all_module_names ( self ) -> dict [ str , typing . Any ] Find all of the annotations within this module.","title":"get_all_module_names"},{"location":"reference/dewret/annotations/#get_argument_annotation","text":"def get_argument_annotation ( self , arg : str , exhaustive : bool = False ) -> Any Retrieve the annotations for this argument. Parameters: Name Type Description Default arg None name of the argument. None exhaustive None True if we should search outside the function itself, into the module globals, and into imported modules. None","title":"get_argument_annotation"},{"location":"reference/dewret/annotations/#is_at_construct_arg","text":"def is_at_construct_arg ( self , arg : str , exhaustive : bool = False ) -> bool Convience function to check for AtConstruct , wrapping FunctionAnalyser.argument_has .","title":"is_at_construct_arg"},{"location":"reference/dewret/annotations/#with_new_globals","text":"def with_new_globals ( self , new_globals : dict [ str , typing . Any ] ) -> Callable [ ... , Any ] Create a Callable that will run the current Callable with new globals.","title":"with_new_globals"},{"location":"reference/dewret/cli/","text":"Module dewret.cli CLI for dewret. Simple CLI for running a workflow (dynamic->static) conversion. It is more likely to use this tool programmatically, but for CI and toy examples, this may be of use.","title":"CLI"},{"location":"reference/dewret/cli/#module-dewretcli","text":"CLI for dewret. Simple CLI for running a workflow (dynamic->static) conversion. It is more likely to use this tool programmatically, but for CI and toy examples, this may be of use.","title":"Module dewret.cli"},{"location":"reference/dewret/core/","text":"Module dewret.core Base classes that need to be available everywhere. Mainly tooling around configuration, protocols and superclasses for References and WorkflowComponents, that are concretized elsewhere. Variables BasicType CONFIGURATION ExprType FirmType RawType RenderConfiguration T U Functions default_construct_config def default_construct_config ( ) -> dewret . core . ConstructConfiguration Gets the default construct-time configuration. This is the primary mechanism for configuring dewret internals, so these defaults should be carefully chosen and, if they change, that likely has an impact on backwards compatibility from a SemVer perspective. Returns: configuration dictionary with default construct values. default_renderer_config def default_renderer_config ( ) -> collections . abc . Mapping [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Gets the default renderer configuration. This may be called frequently, but is cached so note that any changes to the wrapped config function will not be reflected during the process. It is a light wrapper for default_config in the supplier renderer module. Returns: the default configuration dict for the chosen renderer. get_configuration def get_configuration ( key : str ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Retrieve the configuration or (silently) return the default. Helps avoid a proliferation of set_configuration calls by not erroring if it has not been called. However, the cost is that the user may accidentally put configuration-affected logic outside a set_configuration call and be surprised that the behaviour is inexplicibly not as expected. Parameters: Name Type Description Default key None configuration key to retrieve. None get_render_configuration def get_render_configuration ( key : str ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Retrieve configuration for the active renderer. Finds the current user-set configuration, defaulting back to the chosen renderer module's declared defaults. Parameters: Name Type Description Default key None configuration key to retrieve. None set_configuration def set_configuration ( ** kwargs : *< class ' dewret . core . ConstructConfigurationTypedDict '> ) -> Iterator [ _contextvars . ContextVar [ dewret . core . GlobalConfiguration ]] Sets the construct-time configuration. This is a context manager, so that a setting can be temporarily overridden and automatically restored. set_render_configuration def set_render_configuration ( kwargs : collections . abc . Mapping [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] ) -> Iterator [ _contextvars . ContextVar [ dewret . core . GlobalConfiguration ]] Sets the render-time configuration. This is a context manager, so that a setting can be temporarily overridden and automatically restored. Returns: the yielded global configuration ContextVar. strip_annotations def strip_annotations ( parent_type : type ) -> tuple [ type , tuple [ str ]] Discovers and removes annotations from a parent type. Parameters: Name Type Description Default parent_type None a type, possibly Annotated. None Classes BaseRenderModule class BaseRenderModule ( * args , ** kwargs ) Common routines for all renderer modules. Ancestors (in MRO) typing.Protocol typing.Generic Descendants dewret.core.RawRenderModule dewret.core.StructuredRenderModule Static methods default_config def default_config ( ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Retrieve default settings. These will not change during execution, but can be overridden by dewret.core.set_render_configuration . Returns: a static, serializable dict. ConstructConfiguration class ConstructConfiguration ( flatten_all_nested : bool = False , allow_positional_args : bool = False , allow_plain_dict_fields : bool = False , field_separator : str = '/' , field_index_types : str = 'int' , simplify_ids : bool = False , eager : bool = False ) Basic configuration of the construction process. Holds configuration that may be relevant to construst(...) calls or, realistically, anything prior to rendering. It should hold generic configuration that is renderer-independent. Instance variables allow_plain_dict_fields allow_positional_args eager field_index_types field_separator flatten_all_nested simplify_ids ConstructConfigurationTypedDict class ConstructConfigurationTypedDict ( / , * args , ** kwargs ) Basic configuration of the construction process. Holds configuration that may be relevant to construst(...) calls or, realistically, anything prior to rendering. It should hold generic configuration that is renderer-independent. THIS MUST BE KEPT IDENTICAL TO ConstructConfiguration. Ancestors (in MRO) builtins.dict Methods clear def clear ( ... ) D.clear() -> None. Remove all items from D. copy def copy ( ... ) D.copy() -> a shallow copy of D fromkeys def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items def items ( ... ) D.items() -> a set-like object providing a view on D's items keys def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError. popitem def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values def values ( ... ) D.values() -> an object providing a view on D's values GlobalConfiguration class GlobalConfiguration ( construct : dewret . core . ConstructConfiguration , render : dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] ) Overall configuration structure. Having a single configuration dict allows us to manage only one ContextVar. Instance variables construct render IterableMixin class IterableMixin ( typ : type [ ~ U ] | None = None , ** kwargs : Any ) Functionality for iterating over references to give new references. Ancestors (in MRO) dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent Descendants dewret.workflow.IterableParameterReference dewret.workflow.IterableStepReference Class variables default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol Static methods class_key def class_key ( ) Nice order of classes. fromiter def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first. Examples from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4) Instance variables args Returns a tuple of arguments of 'self'. Examples from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y Notes Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression. Examples from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args) Examples from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference. Methods adjoint def adjoint ( self ) apart def apart ( self , x = None , ** args ) See the apart function in sympy.polys args_cnc def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self. Explanation self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False. Examples from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []] as_base_exp def as_base_exp ( self ) -> 'tuple[Expr, Expr]' as_coeff_Add def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation. as_coeff_Mul def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product. as_coeff_add def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ()) as_coeff_exponent def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression. as_coeff_mul def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ()) as_coefficient def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None. Examples from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I) See Also coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used as_coefficients_dict def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned. Examples from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x} as_content_primitive def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self). Examples from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y) as_dummy def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned. Examples from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r Notes Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object. as_expr def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression. Examples from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x) as_independent def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True Examples -- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b)) See Also separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul as_leading_term def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value. Examples from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2) as_numer_denom def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else. See Also normal: return a/b instead of (a, b) as_ordered_factors def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self]. as_ordered_terms def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms. Examples from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1] as_poly def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None . Explanation from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None as_powers_dict def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary. See Also as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors. as_real_imag def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z)) as_set def as_set ( self ) Rewrites Boolean expression in terms of real sets. Examples from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo)) as_terms def as_terms ( self ) Transform an expression to a list of terms. aseries def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) . Parameters self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form. Examples from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x Returns Expr Asymptotic series expansion of the expression. Notes This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self . References .. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion See Also Expr.aseries: See the docstring of this function for complete details of this wrapper. atoms def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below. Examples from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)} cancel def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys coeff def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned. Explanation When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative. Examples from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1 See Also as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used collect def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify combsimp def combsimp ( self ) See the combsimp function in sympy.simplify compare def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned. Examples from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1 conjugate def conjugate ( self ) Returns the complex conjugate of 'self'. copy def copy ( self ) could_extract_minus_sign def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False. Examples from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True count def count ( self , query ) Count the number of matching subexpressions. count_ops def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count. diff def diff ( self , * symbols , ** assumptions ) dir def dir ( self , x , cdir ) doit def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x) dummy_eq def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols. Examples from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False equals def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None. Explanation If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False. evalf def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 expand def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information. extract_additively def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None. Examples from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3 See Also extract_multiplicatively coeff as_coefficient extract_branch_factor def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2) extract_multiplicatively def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self. Examples from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6 factor def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools find def find ( self , query , group = False ) Find all subexpressions matching a query. fourier_series def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information. fps def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information. gammasimp def gammasimp ( self ) See the gammasimp function in sympy.simplify getO def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None. getn def getn ( self ) Returns the order of the expression. Explanation The order is determined either from the O(...) term. If there is no O(...) term, it returns None. Examples from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn() has def has ( self , * patterns ) Test whether any subexpression matches any of the patterns. Examples from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False has_free def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False. Examples from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True has_xfree def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches. Examples from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False integrate def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals invert def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions). See Also sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert is_algebraic_expr def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation. Examples from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True See Also is_rational_function References .. [1] https://en.wikipedia.org/wiki/Algebraic_expression is_constant def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively. Explanation If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing. Examples from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True is_hypergeometric def is_hypergeometric ( self , k ) is_meromorphic def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis. Examples from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False is_polynomial def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True). Examples from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function() is_rational_function def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True). Examples from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr(). is_same def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5). Examples In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False leadterm def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b). Examples from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2) limit def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim. lseries def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries(). match def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self Examples from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2} See Also matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching matches def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr. Examples from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c} n def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 normal def normal ( self ) Return the expression as a fraction. expression -> a/b See Also as_numer_denom: return (a, b) instead of a/b nseries def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries(). Examples from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y) nsimplify def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify powsimp def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify primitive def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float). Examples from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True radsimp def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify ratsimp def ratsimp ( self ) See the ratsimp function in sympy.simplify rcall def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z refine def refine ( self , assumption = True ) See the refine function in sympy.assumptions removeO def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one replace def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below: Examples Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1 See Also subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules rewrite def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten. Parameters args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True . Examples If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2) round def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number. Examples from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I Notes The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True separate def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify series def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised. Parameters expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated. Examples from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x Returns Expr : Expression Series expansion of the expression about x0 Raises TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object simplify def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify sort_key def sort_key ( self , order = None ) Return a sort key. Examples from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2] subs def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made. Examples from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained. See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision taylor_term def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\". to_nnf def to_nnf ( self , simplify = True ) together def together ( self , * args , ** kwargs ) See the together function in sympy.polys transpose def transpose ( self ) trigsimp def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify xreplace def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression. Parameters rule : dict-like Expresses a replacement rule Returns xreplace : the result of the replacement Examples from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),) See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves. IteratedGenerator class IteratedGenerator ( to_wrap : dewret . core . Reference [ ~ U ] ) Sentinel value for capturing that an iteration has occured without performing it. Allows us to lazily evaluate a loop, for instance, in the renderer. This may be relevant if the renderer wishes to postpone iteration to runtime, and simply record it is required, rather than evaluating the iterator. Ancestors (in MRO) typing.Generic Raw class Raw ( value : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] ) Value object for any raw types. This is able to hash raw types consistently and provides a single type for validating type-consistency. Attributes Name Type Description Default value None the real value, e.g. a str , int , ... None RawRenderModule class RawRenderModule ( * args , ** kwargs ) Render module that returns raw text. Ancestors (in MRO) dewret.core.BaseRenderModule typing.Protocol typing.Generic Static methods default_config def default_config ( ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Retrieve default settings. These will not change during execution, but can be overridden by dewret.core.set_render_configuration . Returns: a static, serializable dict. Methods render_raw def render_raw ( self , workflow : dewret . core . WorkflowProtocol , ** kwargs : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Turn a workflow into flat strings. Returns: one or more subworkflows with a __root__ key representing the outermost workflow, at least. Reference class Reference ( * args : Any , typ : type [ ~ U ] | None = None , ** kwargs : Any ) Superclass for all symbolic references to values. Ancestors (in MRO) typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent Descendants dewret.core.IterableMixin dewret.workflow.ParameterReference dewret.workflow.StepReference Class variables default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol Static methods class_key def class_key ( ) Nice order of classes. fromiter def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first. Examples from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4) Instance variables args Returns a tuple of arguments of 'self'. Examples from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y Notes Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression. Examples from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args) Examples from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference. Methods adjoint def adjoint ( self ) apart def apart ( self , x = None , ** args ) See the apart function in sympy.polys args_cnc def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self. Explanation self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False. Examples from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []] as_base_exp def as_base_exp ( self ) -> 'tuple[Expr, Expr]' as_coeff_Add def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation. as_coeff_Mul def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product. as_coeff_add def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ()) as_coeff_exponent def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression. as_coeff_mul def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ()) as_coefficient def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None. Examples from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I) See Also coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used as_coefficients_dict def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned. Examples from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x} as_content_primitive def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self). Examples from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y) as_dummy def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned. Examples from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r Notes Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object. as_expr def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression. Examples from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x) as_independent def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True Examples -- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b)) See Also separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul as_leading_term def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value. Examples from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2) as_numer_denom def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else. See Also normal: return a/b instead of (a, b) as_ordered_factors def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self]. as_ordered_terms def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms. Examples from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1] as_poly def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None . Explanation from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None as_powers_dict def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary. See Also as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors. as_real_imag def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z)) as_set def as_set ( self ) Rewrites Boolean expression in terms of real sets. Examples from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo)) as_terms def as_terms ( self ) Transform an expression to a list of terms. aseries def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) . Parameters self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form. Examples from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x Returns Expr Asymptotic series expansion of the expression. Notes This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self . References .. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion See Also Expr.aseries: See the docstring of this function for complete details of this wrapper. atoms def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below. Examples from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)} cancel def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys coeff def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned. Explanation When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative. Examples from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1 See Also as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used collect def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify combsimp def combsimp ( self ) See the combsimp function in sympy.simplify compare def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned. Examples from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1 conjugate def conjugate ( self ) Returns the complex conjugate of 'self'. copy def copy ( self ) could_extract_minus_sign def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False. Examples from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True count def count ( self , query ) Count the number of matching subexpressions. count_ops def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count. diff def diff ( self , * symbols , ** assumptions ) dir def dir ( self , x , cdir ) doit def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x) dummy_eq def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols. Examples from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False equals def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None. Explanation If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False. evalf def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 expand def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information. extract_additively def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None. Examples from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3 See Also extract_multiplicatively coeff as_coefficient extract_branch_factor def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2) extract_multiplicatively def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self. Examples from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6 factor def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools find def find ( self , query , group = False ) Find all subexpressions matching a query. fourier_series def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information. fps def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information. gammasimp def gammasimp ( self ) See the gammasimp function in sympy.simplify getO def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None. getn def getn ( self ) Returns the order of the expression. Explanation The order is determined either from the O(...) term. If there is no O(...) term, it returns None. Examples from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn() has def has ( self , * patterns ) Test whether any subexpression matches any of the patterns. Examples from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False has_free def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False. Examples from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True has_xfree def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches. Examples from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False integrate def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals invert def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions). See Also sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert is_algebraic_expr def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation. Examples from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True See Also is_rational_function References .. [1] https://en.wikipedia.org/wiki/Algebraic_expression is_constant def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively. Explanation If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing. Examples from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True is_hypergeometric def is_hypergeometric ( self , k ) is_meromorphic def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis. Examples from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False is_polynomial def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True). Examples from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function() is_rational_function def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True). Examples from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr(). is_same def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5). Examples In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False leadterm def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b). Examples from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2) limit def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim. lseries def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries(). match def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self Examples from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2} See Also matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching matches def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr. Examples from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c} n def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 normal def normal ( self ) Return the expression as a fraction. expression -> a/b See Also as_numer_denom: return (a, b) instead of a/b nseries def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries(). Examples from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y) nsimplify def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify powsimp def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify primitive def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float). Examples from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True radsimp def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify ratsimp def ratsimp ( self ) See the ratsimp function in sympy.simplify rcall def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z refine def refine ( self , assumption = True ) See the refine function in sympy.assumptions removeO def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one replace def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below: Examples Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1 See Also subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules rewrite def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten. Parameters args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True . Examples If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2) round def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number. Examples from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I Notes The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True separate def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify series def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised. Parameters expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated. Examples from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x Returns Expr : Expression Series expansion of the expression about x0 Raises TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object simplify def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify sort_key def sort_key ( self , order = None ) Return a sort key. Examples from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2] subs def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made. Examples from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained. See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision taylor_term def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\". to_nnf def to_nnf ( self , simplify = True ) together def together ( self , * args , ** kwargs ) See the together function in sympy.polys transpose def transpose ( self ) trigsimp def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify xreplace def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression. Parameters rule : dict-like Expresses a replacement rule Returns xreplace : the result of the replacement Examples from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),) See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves. RenderCall class RenderCall ( * args , ** kwargs ) Callable that will render out workflow(s). Ancestors (in MRO) typing.Protocol typing.Generic StructuredRenderModule class StructuredRenderModule ( * args , ** kwargs ) Render module that returns JSON/YAML-serializable structures. Ancestors (in MRO) dewret.core.BaseRenderModule typing.Protocol typing.Generic Static methods default_config def default_config ( ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Retrieve default settings. These will not change during execution, but can be overridden by dewret.core.set_render_configuration . Returns: a static, serializable dict. Methods render def render ( self , workflow : dewret . core . WorkflowProtocol , ** kwargs : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] ) -> dict [ str , dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]]] Turn a workflow into a serializable structure. Returns: one or more subworkflows with a __root__ key representing the outermost workflow, at least. UnevaluatableError class UnevaluatableError ( / , * args , ** kwargs ) Signposts that a user has tried to treat a reference as the real (runtime) value. For example, by comparing to a concrete integer or value, etc. Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods add_note def add_note ( ... ) Exception.add_note(note) -- add a note to the exception with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. WorkflowComponent class WorkflowComponent ( * args : Any , workflow : dewret . core . WorkflowProtocol , ** kwargs : Any ) Base class for anything directly tied to an individual Workflow . Attributes Name Type Description Default workflow None the Workflow that this is tied to. None Descendants dewret.core.Reference dewret.workflow.BaseStep dewret.workflow.ParameterReference WorkflowProtocol class WorkflowProtocol ( * args , ** kwargs ) Expected structure for a workflow. We do not expect various workflow implementations, but this allows us to define the interface expected by the core classes. Ancestors (in MRO) typing.Protocol typing.Generic Methods remap def remap ( self , name : str ) -> str Perform any name-changing for steps, etc. in the workflow. This enables, for example, simplifying all the IDs to an integer sequence. Returns: remapped name. set_result def set_result ( self , result : sympy . core . basic . Basic | list [ sympy . core . basic . Basic ] | tuple [ sympy . core . basic . Basic ] ) -> None Set the step that should produce a result for the overall workflow. simplify_ids def simplify_ids ( self , infix : list [ str ] | None = None ) -> None Drop the non-human-readable IDs if possible, in favour of integer sequences. Parameters: Name Type Description Default infix None any inherited intermediary identifiers, to allow nesting, or None. None","title":"Core"},{"location":"reference/dewret/core/#module-dewretcore","text":"Base classes that need to be available everywhere. Mainly tooling around configuration, protocols and superclasses for References and WorkflowComponents, that are concretized elsewhere.","title":"Module dewret.core"},{"location":"reference/dewret/core/#variables","text":"BasicType CONFIGURATION ExprType FirmType RawType RenderConfiguration T U","title":"Variables"},{"location":"reference/dewret/core/#functions","text":"","title":"Functions"},{"location":"reference/dewret/core/#default_construct_config","text":"def default_construct_config ( ) -> dewret . core . ConstructConfiguration Gets the default construct-time configuration. This is the primary mechanism for configuring dewret internals, so these defaults should be carefully chosen and, if they change, that likely has an impact on backwards compatibility from a SemVer perspective. Returns: configuration dictionary with default construct values.","title":"default_construct_config"},{"location":"reference/dewret/core/#default_renderer_config","text":"def default_renderer_config ( ) -> collections . abc . Mapping [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Gets the default renderer configuration. This may be called frequently, but is cached so note that any changes to the wrapped config function will not be reflected during the process. It is a light wrapper for default_config in the supplier renderer module. Returns: the default configuration dict for the chosen renderer.","title":"default_renderer_config"},{"location":"reference/dewret/core/#get_configuration","text":"def get_configuration ( key : str ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Retrieve the configuration or (silently) return the default. Helps avoid a proliferation of set_configuration calls by not erroring if it has not been called. However, the cost is that the user may accidentally put configuration-affected logic outside a set_configuration call and be surprised that the behaviour is inexplicibly not as expected. Parameters: Name Type Description Default key None configuration key to retrieve. None","title":"get_configuration"},{"location":"reference/dewret/core/#get_render_configuration","text":"def get_render_configuration ( key : str ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Retrieve configuration for the active renderer. Finds the current user-set configuration, defaulting back to the chosen renderer module's declared defaults. Parameters: Name Type Description Default key None configuration key to retrieve. None","title":"get_render_configuration"},{"location":"reference/dewret/core/#set_configuration","text":"def set_configuration ( ** kwargs : *< class ' dewret . core . ConstructConfigurationTypedDict '> ) -> Iterator [ _contextvars . ContextVar [ dewret . core . GlobalConfiguration ]] Sets the construct-time configuration. This is a context manager, so that a setting can be temporarily overridden and automatically restored.","title":"set_configuration"},{"location":"reference/dewret/core/#set_render_configuration","text":"def set_render_configuration ( kwargs : collections . abc . Mapping [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] ) -> Iterator [ _contextvars . ContextVar [ dewret . core . GlobalConfiguration ]] Sets the render-time configuration. This is a context manager, so that a setting can be temporarily overridden and automatically restored. Returns: the yielded global configuration ContextVar.","title":"set_render_configuration"},{"location":"reference/dewret/core/#strip_annotations","text":"def strip_annotations ( parent_type : type ) -> tuple [ type , tuple [ str ]] Discovers and removes annotations from a parent type. Parameters: Name Type Description Default parent_type None a type, possibly Annotated. None","title":"strip_annotations"},{"location":"reference/dewret/core/#classes","text":"","title":"Classes"},{"location":"reference/dewret/core/#baserendermodule","text":"class BaseRenderModule ( * args , ** kwargs ) Common routines for all renderer modules.","title":"BaseRenderModule"},{"location":"reference/dewret/core/#ancestors-in-mro","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#descendants","text":"dewret.core.RawRenderModule dewret.core.StructuredRenderModule","title":"Descendants"},{"location":"reference/dewret/core/#static-methods","text":"","title":"Static methods"},{"location":"reference/dewret/core/#default_config","text":"def default_config ( ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Retrieve default settings. These will not change during execution, but can be overridden by dewret.core.set_render_configuration . Returns: a static, serializable dict.","title":"default_config"},{"location":"reference/dewret/core/#constructconfiguration","text":"class ConstructConfiguration ( flatten_all_nested : bool = False , allow_positional_args : bool = False , allow_plain_dict_fields : bool = False , field_separator : str = '/' , field_index_types : str = 'int' , simplify_ids : bool = False , eager : bool = False ) Basic configuration of the construction process. Holds configuration that may be relevant to construst(...) calls or, realistically, anything prior to rendering. It should hold generic configuration that is renderer-independent.","title":"ConstructConfiguration"},{"location":"reference/dewret/core/#instance-variables","text":"allow_plain_dict_fields allow_positional_args eager field_index_types field_separator flatten_all_nested simplify_ids","title":"Instance variables"},{"location":"reference/dewret/core/#constructconfigurationtypeddict","text":"class ConstructConfigurationTypedDict ( / , * args , ** kwargs ) Basic configuration of the construction process. Holds configuration that may be relevant to construst(...) calls or, realistically, anything prior to rendering. It should hold generic configuration that is renderer-independent. THIS MUST BE KEPT IDENTICAL TO ConstructConfiguration.","title":"ConstructConfigurationTypedDict"},{"location":"reference/dewret/core/#ancestors-in-mro_1","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#methods","text":"","title":"Methods"},{"location":"reference/dewret/core/#clear","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"reference/dewret/core/#copy","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"reference/dewret/core/#fromkeys","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"reference/dewret/core/#get","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"reference/dewret/core/#items","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"reference/dewret/core/#keys","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"reference/dewret/core/#pop","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError.","title":"pop"},{"location":"reference/dewret/core/#popitem","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"reference/dewret/core/#setdefault","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"reference/dewret/core/#update","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"reference/dewret/core/#values","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"reference/dewret/core/#globalconfiguration","text":"class GlobalConfiguration ( construct : dewret . core . ConstructConfiguration , render : dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] ) Overall configuration structure. Having a single configuration dict allows us to manage only one ContextVar.","title":"GlobalConfiguration"},{"location":"reference/dewret/core/#instance-variables_1","text":"construct render","title":"Instance variables"},{"location":"reference/dewret/core/#iterablemixin","text":"class IterableMixin ( typ : type [ ~ U ] | None = None , ** kwargs : Any ) Functionality for iterating over references to give new references.","title":"IterableMixin"},{"location":"reference/dewret/core/#ancestors-in-mro_2","text":"dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#descendants_1","text":"dewret.workflow.IterableParameterReference dewret.workflow.IterableStepReference","title":"Descendants"},{"location":"reference/dewret/core/#class-variables","text":"default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol","title":"Class variables"},{"location":"reference/dewret/core/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/dewret/core/#class_key","text":"def class_key ( ) Nice order of classes.","title":"class_key"},{"location":"reference/dewret/core/#fromiter","text":"def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first.","title":"fromiter"},{"location":"reference/dewret/core/#examples","text":"from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4)","title":"Examples"},{"location":"reference/dewret/core/#instance-variables_2","text":"args Returns a tuple of arguments of 'self'.","title":"Instance variables"},{"location":"reference/dewret/core/#examples_1","text":"from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y","title":"Examples"},{"location":"reference/dewret/core/#notes","text":"Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression.","title":"Notes"},{"location":"reference/dewret/core/#examples_2","text":"from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args)","title":"Examples"},{"location":"reference/dewret/core/#examples_3","text":"from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference.","title":"Examples"},{"location":"reference/dewret/core/#methods_1","text":"","title":"Methods"},{"location":"reference/dewret/core/#adjoint","text":"def adjoint ( self )","title":"adjoint"},{"location":"reference/dewret/core/#apart","text":"def apart ( self , x = None , ** args ) See the apart function in sympy.polys","title":"apart"},{"location":"reference/dewret/core/#args_cnc","text":"def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self.","title":"args_cnc"},{"location":"reference/dewret/core/#explanation","text":"self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False.","title":"Explanation"},{"location":"reference/dewret/core/#examples_4","text":"from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []]","title":"Examples"},{"location":"reference/dewret/core/#as_base_exp","text":"def as_base_exp ( self ) -> 'tuple[Expr, Expr]'","title":"as_base_exp"},{"location":"reference/dewret/core/#as_coeff_add","text":"def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation.","title":"as_coeff_Add"},{"location":"reference/dewret/core/#as_coeff_mul","text":"def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product.","title":"as_coeff_Mul"},{"location":"reference/dewret/core/#as_coeff_add_1","text":"def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ())","title":"as_coeff_add"},{"location":"reference/dewret/core/#as_coeff_exponent","text":"def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression.","title":"as_coeff_exponent"},{"location":"reference/dewret/core/#as_coeff_mul_1","text":"def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ())","title":"as_coeff_mul"},{"location":"reference/dewret/core/#as_coefficient","text":"def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None.","title":"as_coefficient"},{"location":"reference/dewret/core/#examples_5","text":"from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I)","title":"Examples"},{"location":"reference/dewret/core/#see-also","text":"coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/core/#as_coefficients_dict","text":"def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned.","title":"as_coefficients_dict"},{"location":"reference/dewret/core/#examples_6","text":"from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x}","title":"Examples"},{"location":"reference/dewret/core/#as_content_primitive","text":"def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self).","title":"as_content_primitive"},{"location":"reference/dewret/core/#examples_7","text":"from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y)","title":"Examples"},{"location":"reference/dewret/core/#as_dummy","text":"def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned.","title":"as_dummy"},{"location":"reference/dewret/core/#examples_8","text":"from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r","title":"Examples"},{"location":"reference/dewret/core/#notes_1","text":"Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object.","title":"Notes"},{"location":"reference/dewret/core/#as_expr","text":"def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression.","title":"as_expr"},{"location":"reference/dewret/core/#examples_9","text":"from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x)","title":"Examples"},{"location":"reference/dewret/core/#as_independent","text":"def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True","title":"as_independent"},{"location":"reference/dewret/core/#examples_10","text":"-- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b))","title":"Examples"},{"location":"reference/dewret/core/#see-also_1","text":"separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul","title":"See Also"},{"location":"reference/dewret/core/#as_leading_term","text":"def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value.","title":"as_leading_term"},{"location":"reference/dewret/core/#examples_11","text":"from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2)","title":"Examples"},{"location":"reference/dewret/core/#as_numer_denom","text":"def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else.","title":"as_numer_denom"},{"location":"reference/dewret/core/#see-also_2","text":"normal: return a/b instead of (a, b)","title":"See Also"},{"location":"reference/dewret/core/#as_ordered_factors","text":"def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self].","title":"as_ordered_factors"},{"location":"reference/dewret/core/#as_ordered_terms","text":"def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms.","title":"as_ordered_terms"},{"location":"reference/dewret/core/#examples_12","text":"from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1]","title":"Examples"},{"location":"reference/dewret/core/#as_poly","text":"def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None .","title":"as_poly"},{"location":"reference/dewret/core/#explanation_1","text":"from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None","title":"Explanation"},{"location":"reference/dewret/core/#as_powers_dict","text":"def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary.","title":"as_powers_dict"},{"location":"reference/dewret/core/#see-also_3","text":"as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.","title":"See Also"},{"location":"reference/dewret/core/#as_real_imag","text":"def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z))","title":"as_real_imag"},{"location":"reference/dewret/core/#as_set","text":"def as_set ( self ) Rewrites Boolean expression in terms of real sets.","title":"as_set"},{"location":"reference/dewret/core/#examples_13","text":"from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo))","title":"Examples"},{"location":"reference/dewret/core/#as_terms","text":"def as_terms ( self ) Transform an expression to a list of terms.","title":"as_terms"},{"location":"reference/dewret/core/#aseries","text":"def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) .","title":"aseries"},{"location":"reference/dewret/core/#parameters","text":"self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form.","title":"Parameters"},{"location":"reference/dewret/core/#examples_14","text":"from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/core/#returns","text":"Expr Asymptotic series expansion of the expression.","title":"Returns"},{"location":"reference/dewret/core/#notes_2","text":"This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self .","title":"Notes"},{"location":"reference/dewret/core/#references","text":".. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion","title":"References"},{"location":"reference/dewret/core/#see-also_4","text":"Expr.aseries: See the docstring of this function for complete details of this wrapper.","title":"See Also"},{"location":"reference/dewret/core/#atoms","text":"def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below.","title":"atoms"},{"location":"reference/dewret/core/#examples_15","text":"from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)}","title":"Examples"},{"location":"reference/dewret/core/#cancel","text":"def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys","title":"cancel"},{"location":"reference/dewret/core/#coeff","text":"def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned.","title":"coeff"},{"location":"reference/dewret/core/#explanation_2","text":"When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative.","title":"Explanation"},{"location":"reference/dewret/core/#examples_16","text":"from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1","title":"Examples"},{"location":"reference/dewret/core/#see-also_5","text":"as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/core/#collect","text":"def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify","title":"collect"},{"location":"reference/dewret/core/#combsimp","text":"def combsimp ( self ) See the combsimp function in sympy.simplify","title":"combsimp"},{"location":"reference/dewret/core/#compare","text":"def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned.","title":"compare"},{"location":"reference/dewret/core/#examples_17","text":"from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1","title":"Examples"},{"location":"reference/dewret/core/#conjugate","text":"def conjugate ( self ) Returns the complex conjugate of 'self'.","title":"conjugate"},{"location":"reference/dewret/core/#copy_1","text":"def copy ( self )","title":"copy"},{"location":"reference/dewret/core/#could_extract_minus_sign","text":"def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False.","title":"could_extract_minus_sign"},{"location":"reference/dewret/core/#examples_18","text":"from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True","title":"Examples"},{"location":"reference/dewret/core/#count","text":"def count ( self , query ) Count the number of matching subexpressions.","title":"count"},{"location":"reference/dewret/core/#count_ops","text":"def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count.","title":"count_ops"},{"location":"reference/dewret/core/#diff","text":"def diff ( self , * symbols , ** assumptions )","title":"diff"},{"location":"reference/dewret/core/#dir","text":"def dir ( self , x , cdir )","title":"dir"},{"location":"reference/dewret/core/#doit","text":"def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x)","title":"doit"},{"location":"reference/dewret/core/#dummy_eq","text":"def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols.","title":"dummy_eq"},{"location":"reference/dewret/core/#examples_19","text":"from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False","title":"Examples"},{"location":"reference/dewret/core/#equals","text":"def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None.","title":"equals"},{"location":"reference/dewret/core/#explanation_3","text":"If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False.","title":"Explanation"},{"location":"reference/dewret/core/#evalf","text":"def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"evalf"},{"location":"reference/dewret/core/#parameters_1","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/core/#notes_3","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/core/#expand","text":"def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information.","title":"expand"},{"location":"reference/dewret/core/#extract_additively","text":"def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None.","title":"extract_additively"},{"location":"reference/dewret/core/#examples_20","text":"from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3","title":"Examples"},{"location":"reference/dewret/core/#see-also_6","text":"extract_multiplicatively coeff as_coefficient","title":"See Also"},{"location":"reference/dewret/core/#extract_branch_factor","text":"def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2)","title":"extract_branch_factor"},{"location":"reference/dewret/core/#extract_multiplicatively","text":"def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self.","title":"extract_multiplicatively"},{"location":"reference/dewret/core/#examples_21","text":"from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6","title":"Examples"},{"location":"reference/dewret/core/#factor","text":"def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools","title":"factor"},{"location":"reference/dewret/core/#find","text":"def find ( self , query , group = False ) Find all subexpressions matching a query.","title":"find"},{"location":"reference/dewret/core/#fourier_series","text":"def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information.","title":"fourier_series"},{"location":"reference/dewret/core/#fps","text":"def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information.","title":"fps"},{"location":"reference/dewret/core/#gammasimp","text":"def gammasimp ( self ) See the gammasimp function in sympy.simplify","title":"gammasimp"},{"location":"reference/dewret/core/#geto","text":"def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None.","title":"getO"},{"location":"reference/dewret/core/#getn","text":"def getn ( self ) Returns the order of the expression.","title":"getn"},{"location":"reference/dewret/core/#explanation_4","text":"The order is determined either from the O(...) term. If there is no O(...) term, it returns None.","title":"Explanation"},{"location":"reference/dewret/core/#examples_22","text":"from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn()","title":"Examples"},{"location":"reference/dewret/core/#has","text":"def has ( self , * patterns ) Test whether any subexpression matches any of the patterns.","title":"has"},{"location":"reference/dewret/core/#examples_23","text":"from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False","title":"Examples"},{"location":"reference/dewret/core/#has_free","text":"def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False.","title":"has_free"},{"location":"reference/dewret/core/#examples_24","text":"from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True","title":"Examples"},{"location":"reference/dewret/core/#has_xfree","text":"def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches.","title":"has_xfree"},{"location":"reference/dewret/core/#examples_25","text":"from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False","title":"Examples"},{"location":"reference/dewret/core/#integrate","text":"def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals","title":"integrate"},{"location":"reference/dewret/core/#invert","text":"def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions).","title":"invert"},{"location":"reference/dewret/core/#see-also_7","text":"sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert","title":"See Also"},{"location":"reference/dewret/core/#is_algebraic_expr","text":"def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation.","title":"is_algebraic_expr"},{"location":"reference/dewret/core/#examples_26","text":"from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True","title":"Examples"},{"location":"reference/dewret/core/#see-also_8","text":"is_rational_function","title":"See Also"},{"location":"reference/dewret/core/#references_1","text":".. [1] https://en.wikipedia.org/wiki/Algebraic_expression","title":"References"},{"location":"reference/dewret/core/#is_constant","text":"def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively.","title":"is_constant"},{"location":"reference/dewret/core/#explanation_5","text":"If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing.","title":"Explanation"},{"location":"reference/dewret/core/#examples_27","text":"from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True","title":"Examples"},{"location":"reference/dewret/core/#is_hypergeometric","text":"def is_hypergeometric ( self , k )","title":"is_hypergeometric"},{"location":"reference/dewret/core/#is_meromorphic","text":"def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis.","title":"is_meromorphic"},{"location":"reference/dewret/core/#examples_28","text":"from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False","title":"Examples"},{"location":"reference/dewret/core/#is_polynomial","text":"def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True).","title":"is_polynomial"},{"location":"reference/dewret/core/#examples_29","text":"from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function()","title":"Examples"},{"location":"reference/dewret/core/#is_rational_function","text":"def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True).","title":"is_rational_function"},{"location":"reference/dewret/core/#examples_30","text":"from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr().","title":"Examples"},{"location":"reference/dewret/core/#is_same","text":"def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).","title":"is_same"},{"location":"reference/dewret/core/#examples_31","text":"In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False","title":"Examples"},{"location":"reference/dewret/core/#leadterm","text":"def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b).","title":"leadterm"},{"location":"reference/dewret/core/#examples_32","text":"from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2)","title":"Examples"},{"location":"reference/dewret/core/#limit","text":"def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim.","title":"limit"},{"location":"reference/dewret/core/#lseries","text":"def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries().","title":"lseries"},{"location":"reference/dewret/core/#match","text":"def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self","title":"match"},{"location":"reference/dewret/core/#examples_33","text":"from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2}","title":"Examples"},{"location":"reference/dewret/core/#see-also_9","text":"matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching","title":"See Also"},{"location":"reference/dewret/core/#matches","text":"def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr.","title":"matches"},{"location":"reference/dewret/core/#examples_34","text":"from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c}","title":"Examples"},{"location":"reference/dewret/core/#n","text":"def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"n"},{"location":"reference/dewret/core/#parameters_2","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/core/#notes_4","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/core/#normal","text":"def normal ( self ) Return the expression as a fraction. expression -> a/b","title":"normal"},{"location":"reference/dewret/core/#see-also_10","text":"as_numer_denom: return (a, b) instead of a/b","title":"See Also"},{"location":"reference/dewret/core/#nseries","text":"def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries().","title":"nseries"},{"location":"reference/dewret/core/#examples_35","text":"from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y)","title":"Examples"},{"location":"reference/dewret/core/#nsimplify","text":"def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify","title":"nsimplify"},{"location":"reference/dewret/core/#powsimp","text":"def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify","title":"powsimp"},{"location":"reference/dewret/core/#primitive","text":"def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float).","title":"primitive"},{"location":"reference/dewret/core/#examples_36","text":"from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True","title":"Examples"},{"location":"reference/dewret/core/#radsimp","text":"def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify","title":"radsimp"},{"location":"reference/dewret/core/#ratsimp","text":"def ratsimp ( self ) See the ratsimp function in sympy.simplify","title":"ratsimp"},{"location":"reference/dewret/core/#rcall","text":"def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z","title":"rcall"},{"location":"reference/dewret/core/#refine","text":"def refine ( self , assumption = True ) See the refine function in sympy.assumptions","title":"refine"},{"location":"reference/dewret/core/#removeo","text":"def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one","title":"removeO"},{"location":"reference/dewret/core/#replace","text":"def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below:","title":"replace"},{"location":"reference/dewret/core/#examples_37","text":"Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1","title":"Examples"},{"location":"reference/dewret/core/#see-also_11","text":"subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules","title":"See Also"},{"location":"reference/dewret/core/#rewrite","text":"def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten.","title":"rewrite"},{"location":"reference/dewret/core/#parameters_3","text":"args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True .","title":"Parameters"},{"location":"reference/dewret/core/#examples_38","text":"If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2)","title":"Examples"},{"location":"reference/dewret/core/#round","text":"def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number.","title":"round"},{"location":"reference/dewret/core/#examples_39","text":"from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I","title":"Examples"},{"location":"reference/dewret/core/#notes_5","text":"The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True","title":"Notes"},{"location":"reference/dewret/core/#separate","text":"def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify","title":"separate"},{"location":"reference/dewret/core/#series","text":"def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised.","title":"series"},{"location":"reference/dewret/core/#parameters_4","text":"expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated.","title":"Parameters"},{"location":"reference/dewret/core/#examples_40","text":"from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/core/#returns_1","text":"Expr : Expression Series expansion of the expression about x0","title":"Returns"},{"location":"reference/dewret/core/#raises","text":"TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object","title":"Raises"},{"location":"reference/dewret/core/#simplify","text":"def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify","title":"simplify"},{"location":"reference/dewret/core/#sort_key","text":"def sort_key ( self , order = None ) Return a sort key.","title":"sort_key"},{"location":"reference/dewret/core/#examples_41","text":"from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2]","title":"Examples"},{"location":"reference/dewret/core/#subs","text":"def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made.","title":"subs"},{"location":"reference/dewret/core/#examples_42","text":"from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained.","title":"Examples"},{"location":"reference/dewret/core/#see-also_12","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision","title":"See Also"},{"location":"reference/dewret/core/#taylor_term","text":"def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\".","title":"taylor_term"},{"location":"reference/dewret/core/#to_nnf","text":"def to_nnf ( self , simplify = True )","title":"to_nnf"},{"location":"reference/dewret/core/#together","text":"def together ( self , * args , ** kwargs ) See the together function in sympy.polys","title":"together"},{"location":"reference/dewret/core/#transpose","text":"def transpose ( self )","title":"transpose"},{"location":"reference/dewret/core/#trigsimp","text":"def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify","title":"trigsimp"},{"location":"reference/dewret/core/#xreplace","text":"def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression.","title":"xreplace"},{"location":"reference/dewret/core/#parameters_5","text":"rule : dict-like Expresses a replacement rule","title":"Parameters"},{"location":"reference/dewret/core/#returns_2","text":"xreplace : the result of the replacement","title":"Returns"},{"location":"reference/dewret/core/#examples_43","text":"from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),)","title":"Examples"},{"location":"reference/dewret/core/#see-also_13","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves.","title":"See Also"},{"location":"reference/dewret/core/#iteratedgenerator","text":"class IteratedGenerator ( to_wrap : dewret . core . Reference [ ~ U ] ) Sentinel value for capturing that an iteration has occured without performing it. Allows us to lazily evaluate a loop, for instance, in the renderer. This may be relevant if the renderer wishes to postpone iteration to runtime, and simply record it is required, rather than evaluating the iterator.","title":"IteratedGenerator"},{"location":"reference/dewret/core/#ancestors-in-mro_3","text":"typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#raw","text":"class Raw ( value : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] ) Value object for any raw types. This is able to hash raw types consistently and provides a single type for validating type-consistency.","title":"Raw"},{"location":"reference/dewret/core/#attributes","text":"Name Type Description Default value None the real value, e.g. a str , int , ... None","title":"Attributes"},{"location":"reference/dewret/core/#rawrendermodule","text":"class RawRenderModule ( * args , ** kwargs ) Render module that returns raw text.","title":"RawRenderModule"},{"location":"reference/dewret/core/#ancestors-in-mro_4","text":"dewret.core.BaseRenderModule typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/dewret/core/#default_config_1","text":"def default_config ( ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Retrieve default settings. These will not change during execution, but can be overridden by dewret.core.set_render_configuration . Returns: a static, serializable dict.","title":"default_config"},{"location":"reference/dewret/core/#methods_2","text":"","title":"Methods"},{"location":"reference/dewret/core/#render_raw","text":"def render_raw ( self , workflow : dewret . core . WorkflowProtocol , ** kwargs : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Turn a workflow into flat strings. Returns: one or more subworkflows with a __root__ key representing the outermost workflow, at least.","title":"render_raw"},{"location":"reference/dewret/core/#reference","text":"class Reference ( * args : Any , typ : type [ ~ U ] | None = None , ** kwargs : Any ) Superclass for all symbolic references to values.","title":"Reference"},{"location":"reference/dewret/core/#ancestors-in-mro_5","text":"typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#descendants_2","text":"dewret.core.IterableMixin dewret.workflow.ParameterReference dewret.workflow.StepReference","title":"Descendants"},{"location":"reference/dewret/core/#class-variables_1","text":"default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol","title":"Class variables"},{"location":"reference/dewret/core/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/dewret/core/#class_key_1","text":"def class_key ( ) Nice order of classes.","title":"class_key"},{"location":"reference/dewret/core/#fromiter_1","text":"def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first.","title":"fromiter"},{"location":"reference/dewret/core/#examples_44","text":"from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4)","title":"Examples"},{"location":"reference/dewret/core/#instance-variables_3","text":"args Returns a tuple of arguments of 'self'.","title":"Instance variables"},{"location":"reference/dewret/core/#examples_45","text":"from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y","title":"Examples"},{"location":"reference/dewret/core/#notes_6","text":"Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression.","title":"Notes"},{"location":"reference/dewret/core/#examples_46","text":"from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args)","title":"Examples"},{"location":"reference/dewret/core/#examples_47","text":"from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference.","title":"Examples"},{"location":"reference/dewret/core/#methods_3","text":"","title":"Methods"},{"location":"reference/dewret/core/#adjoint_1","text":"def adjoint ( self )","title":"adjoint"},{"location":"reference/dewret/core/#apart_1","text":"def apart ( self , x = None , ** args ) See the apart function in sympy.polys","title":"apart"},{"location":"reference/dewret/core/#args_cnc_1","text":"def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self.","title":"args_cnc"},{"location":"reference/dewret/core/#explanation_6","text":"self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False.","title":"Explanation"},{"location":"reference/dewret/core/#examples_48","text":"from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []]","title":"Examples"},{"location":"reference/dewret/core/#as_base_exp_1","text":"def as_base_exp ( self ) -> 'tuple[Expr, Expr]'","title":"as_base_exp"},{"location":"reference/dewret/core/#as_coeff_add_2","text":"def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation.","title":"as_coeff_Add"},{"location":"reference/dewret/core/#as_coeff_mul_2","text":"def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product.","title":"as_coeff_Mul"},{"location":"reference/dewret/core/#as_coeff_add_3","text":"def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ())","title":"as_coeff_add"},{"location":"reference/dewret/core/#as_coeff_exponent_1","text":"def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression.","title":"as_coeff_exponent"},{"location":"reference/dewret/core/#as_coeff_mul_3","text":"def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ())","title":"as_coeff_mul"},{"location":"reference/dewret/core/#as_coefficient_1","text":"def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None.","title":"as_coefficient"},{"location":"reference/dewret/core/#examples_49","text":"from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I)","title":"Examples"},{"location":"reference/dewret/core/#see-also_14","text":"coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/core/#as_coefficients_dict_1","text":"def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned.","title":"as_coefficients_dict"},{"location":"reference/dewret/core/#examples_50","text":"from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x}","title":"Examples"},{"location":"reference/dewret/core/#as_content_primitive_1","text":"def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self).","title":"as_content_primitive"},{"location":"reference/dewret/core/#examples_51","text":"from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y)","title":"Examples"},{"location":"reference/dewret/core/#as_dummy_1","text":"def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned.","title":"as_dummy"},{"location":"reference/dewret/core/#examples_52","text":"from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r","title":"Examples"},{"location":"reference/dewret/core/#notes_7","text":"Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object.","title":"Notes"},{"location":"reference/dewret/core/#as_expr_1","text":"def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression.","title":"as_expr"},{"location":"reference/dewret/core/#examples_53","text":"from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x)","title":"Examples"},{"location":"reference/dewret/core/#as_independent_1","text":"def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True","title":"as_independent"},{"location":"reference/dewret/core/#examples_54","text":"-- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b))","title":"Examples"},{"location":"reference/dewret/core/#see-also_15","text":"separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul","title":"See Also"},{"location":"reference/dewret/core/#as_leading_term_1","text":"def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value.","title":"as_leading_term"},{"location":"reference/dewret/core/#examples_55","text":"from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2)","title":"Examples"},{"location":"reference/dewret/core/#as_numer_denom_1","text":"def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else.","title":"as_numer_denom"},{"location":"reference/dewret/core/#see-also_16","text":"normal: return a/b instead of (a, b)","title":"See Also"},{"location":"reference/dewret/core/#as_ordered_factors_1","text":"def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self].","title":"as_ordered_factors"},{"location":"reference/dewret/core/#as_ordered_terms_1","text":"def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms.","title":"as_ordered_terms"},{"location":"reference/dewret/core/#examples_56","text":"from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1]","title":"Examples"},{"location":"reference/dewret/core/#as_poly_1","text":"def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None .","title":"as_poly"},{"location":"reference/dewret/core/#explanation_7","text":"from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None","title":"Explanation"},{"location":"reference/dewret/core/#as_powers_dict_1","text":"def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary.","title":"as_powers_dict"},{"location":"reference/dewret/core/#see-also_17","text":"as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.","title":"See Also"},{"location":"reference/dewret/core/#as_real_imag_1","text":"def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z))","title":"as_real_imag"},{"location":"reference/dewret/core/#as_set_1","text":"def as_set ( self ) Rewrites Boolean expression in terms of real sets.","title":"as_set"},{"location":"reference/dewret/core/#examples_57","text":"from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo))","title":"Examples"},{"location":"reference/dewret/core/#as_terms_1","text":"def as_terms ( self ) Transform an expression to a list of terms.","title":"as_terms"},{"location":"reference/dewret/core/#aseries_1","text":"def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) .","title":"aseries"},{"location":"reference/dewret/core/#parameters_6","text":"self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form.","title":"Parameters"},{"location":"reference/dewret/core/#examples_58","text":"from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/core/#returns_3","text":"Expr Asymptotic series expansion of the expression.","title":"Returns"},{"location":"reference/dewret/core/#notes_8","text":"This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self .","title":"Notes"},{"location":"reference/dewret/core/#references_2","text":".. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion","title":"References"},{"location":"reference/dewret/core/#see-also_18","text":"Expr.aseries: See the docstring of this function for complete details of this wrapper.","title":"See Also"},{"location":"reference/dewret/core/#atoms_1","text":"def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below.","title":"atoms"},{"location":"reference/dewret/core/#examples_59","text":"from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)}","title":"Examples"},{"location":"reference/dewret/core/#cancel_1","text":"def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys","title":"cancel"},{"location":"reference/dewret/core/#coeff_1","text":"def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned.","title":"coeff"},{"location":"reference/dewret/core/#explanation_8","text":"When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative.","title":"Explanation"},{"location":"reference/dewret/core/#examples_60","text":"from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1","title":"Examples"},{"location":"reference/dewret/core/#see-also_19","text":"as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/core/#collect_1","text":"def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify","title":"collect"},{"location":"reference/dewret/core/#combsimp_1","text":"def combsimp ( self ) See the combsimp function in sympy.simplify","title":"combsimp"},{"location":"reference/dewret/core/#compare_1","text":"def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned.","title":"compare"},{"location":"reference/dewret/core/#examples_61","text":"from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1","title":"Examples"},{"location":"reference/dewret/core/#conjugate_1","text":"def conjugate ( self ) Returns the complex conjugate of 'self'.","title":"conjugate"},{"location":"reference/dewret/core/#copy_2","text":"def copy ( self )","title":"copy"},{"location":"reference/dewret/core/#could_extract_minus_sign_1","text":"def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False.","title":"could_extract_minus_sign"},{"location":"reference/dewret/core/#examples_62","text":"from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True","title":"Examples"},{"location":"reference/dewret/core/#count_1","text":"def count ( self , query ) Count the number of matching subexpressions.","title":"count"},{"location":"reference/dewret/core/#count_ops_1","text":"def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count.","title":"count_ops"},{"location":"reference/dewret/core/#diff_1","text":"def diff ( self , * symbols , ** assumptions )","title":"diff"},{"location":"reference/dewret/core/#dir_1","text":"def dir ( self , x , cdir )","title":"dir"},{"location":"reference/dewret/core/#doit_1","text":"def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x)","title":"doit"},{"location":"reference/dewret/core/#dummy_eq_1","text":"def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols.","title":"dummy_eq"},{"location":"reference/dewret/core/#examples_63","text":"from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False","title":"Examples"},{"location":"reference/dewret/core/#equals_1","text":"def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None.","title":"equals"},{"location":"reference/dewret/core/#explanation_9","text":"If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False.","title":"Explanation"},{"location":"reference/dewret/core/#evalf_1","text":"def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"evalf"},{"location":"reference/dewret/core/#parameters_7","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/core/#notes_9","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/core/#expand_1","text":"def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information.","title":"expand"},{"location":"reference/dewret/core/#extract_additively_1","text":"def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None.","title":"extract_additively"},{"location":"reference/dewret/core/#examples_64","text":"from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3","title":"Examples"},{"location":"reference/dewret/core/#see-also_20","text":"extract_multiplicatively coeff as_coefficient","title":"See Also"},{"location":"reference/dewret/core/#extract_branch_factor_1","text":"def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2)","title":"extract_branch_factor"},{"location":"reference/dewret/core/#extract_multiplicatively_1","text":"def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self.","title":"extract_multiplicatively"},{"location":"reference/dewret/core/#examples_65","text":"from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6","title":"Examples"},{"location":"reference/dewret/core/#factor_1","text":"def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools","title":"factor"},{"location":"reference/dewret/core/#find_1","text":"def find ( self , query , group = False ) Find all subexpressions matching a query.","title":"find"},{"location":"reference/dewret/core/#fourier_series_1","text":"def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information.","title":"fourier_series"},{"location":"reference/dewret/core/#fps_1","text":"def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information.","title":"fps"},{"location":"reference/dewret/core/#gammasimp_1","text":"def gammasimp ( self ) See the gammasimp function in sympy.simplify","title":"gammasimp"},{"location":"reference/dewret/core/#geto_1","text":"def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None.","title":"getO"},{"location":"reference/dewret/core/#getn_1","text":"def getn ( self ) Returns the order of the expression.","title":"getn"},{"location":"reference/dewret/core/#explanation_10","text":"The order is determined either from the O(...) term. If there is no O(...) term, it returns None.","title":"Explanation"},{"location":"reference/dewret/core/#examples_66","text":"from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn()","title":"Examples"},{"location":"reference/dewret/core/#has_1","text":"def has ( self , * patterns ) Test whether any subexpression matches any of the patterns.","title":"has"},{"location":"reference/dewret/core/#examples_67","text":"from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False","title":"Examples"},{"location":"reference/dewret/core/#has_free_1","text":"def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False.","title":"has_free"},{"location":"reference/dewret/core/#examples_68","text":"from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True","title":"Examples"},{"location":"reference/dewret/core/#has_xfree_1","text":"def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches.","title":"has_xfree"},{"location":"reference/dewret/core/#examples_69","text":"from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False","title":"Examples"},{"location":"reference/dewret/core/#integrate_1","text":"def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals","title":"integrate"},{"location":"reference/dewret/core/#invert_1","text":"def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions).","title":"invert"},{"location":"reference/dewret/core/#see-also_21","text":"sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert","title":"See Also"},{"location":"reference/dewret/core/#is_algebraic_expr_1","text":"def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation.","title":"is_algebraic_expr"},{"location":"reference/dewret/core/#examples_70","text":"from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True","title":"Examples"},{"location":"reference/dewret/core/#see-also_22","text":"is_rational_function","title":"See Also"},{"location":"reference/dewret/core/#references_3","text":".. [1] https://en.wikipedia.org/wiki/Algebraic_expression","title":"References"},{"location":"reference/dewret/core/#is_constant_1","text":"def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively.","title":"is_constant"},{"location":"reference/dewret/core/#explanation_11","text":"If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing.","title":"Explanation"},{"location":"reference/dewret/core/#examples_71","text":"from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True","title":"Examples"},{"location":"reference/dewret/core/#is_hypergeometric_1","text":"def is_hypergeometric ( self , k )","title":"is_hypergeometric"},{"location":"reference/dewret/core/#is_meromorphic_1","text":"def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis.","title":"is_meromorphic"},{"location":"reference/dewret/core/#examples_72","text":"from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False","title":"Examples"},{"location":"reference/dewret/core/#is_polynomial_1","text":"def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True).","title":"is_polynomial"},{"location":"reference/dewret/core/#examples_73","text":"from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function()","title":"Examples"},{"location":"reference/dewret/core/#is_rational_function_1","text":"def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True).","title":"is_rational_function"},{"location":"reference/dewret/core/#examples_74","text":"from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr().","title":"Examples"},{"location":"reference/dewret/core/#is_same_1","text":"def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).","title":"is_same"},{"location":"reference/dewret/core/#examples_75","text":"In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False","title":"Examples"},{"location":"reference/dewret/core/#leadterm_1","text":"def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b).","title":"leadterm"},{"location":"reference/dewret/core/#examples_76","text":"from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2)","title":"Examples"},{"location":"reference/dewret/core/#limit_1","text":"def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim.","title":"limit"},{"location":"reference/dewret/core/#lseries_1","text":"def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries().","title":"lseries"},{"location":"reference/dewret/core/#match_1","text":"def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self","title":"match"},{"location":"reference/dewret/core/#examples_77","text":"from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2}","title":"Examples"},{"location":"reference/dewret/core/#see-also_23","text":"matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching","title":"See Also"},{"location":"reference/dewret/core/#matches_1","text":"def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr.","title":"matches"},{"location":"reference/dewret/core/#examples_78","text":"from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c}","title":"Examples"},{"location":"reference/dewret/core/#n_1","text":"def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"n"},{"location":"reference/dewret/core/#parameters_8","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/core/#notes_10","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/core/#normal_1","text":"def normal ( self ) Return the expression as a fraction. expression -> a/b","title":"normal"},{"location":"reference/dewret/core/#see-also_24","text":"as_numer_denom: return (a, b) instead of a/b","title":"See Also"},{"location":"reference/dewret/core/#nseries_1","text":"def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries().","title":"nseries"},{"location":"reference/dewret/core/#examples_79","text":"from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y)","title":"Examples"},{"location":"reference/dewret/core/#nsimplify_1","text":"def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify","title":"nsimplify"},{"location":"reference/dewret/core/#powsimp_1","text":"def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify","title":"powsimp"},{"location":"reference/dewret/core/#primitive_1","text":"def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float).","title":"primitive"},{"location":"reference/dewret/core/#examples_80","text":"from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True","title":"Examples"},{"location":"reference/dewret/core/#radsimp_1","text":"def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify","title":"radsimp"},{"location":"reference/dewret/core/#ratsimp_1","text":"def ratsimp ( self ) See the ratsimp function in sympy.simplify","title":"ratsimp"},{"location":"reference/dewret/core/#rcall_1","text":"def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z","title":"rcall"},{"location":"reference/dewret/core/#refine_1","text":"def refine ( self , assumption = True ) See the refine function in sympy.assumptions","title":"refine"},{"location":"reference/dewret/core/#removeo_1","text":"def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one","title":"removeO"},{"location":"reference/dewret/core/#replace_1","text":"def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below:","title":"replace"},{"location":"reference/dewret/core/#examples_81","text":"Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1","title":"Examples"},{"location":"reference/dewret/core/#see-also_25","text":"subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules","title":"See Also"},{"location":"reference/dewret/core/#rewrite_1","text":"def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten.","title":"rewrite"},{"location":"reference/dewret/core/#parameters_9","text":"args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True .","title":"Parameters"},{"location":"reference/dewret/core/#examples_82","text":"If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2)","title":"Examples"},{"location":"reference/dewret/core/#round_1","text":"def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number.","title":"round"},{"location":"reference/dewret/core/#examples_83","text":"from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I","title":"Examples"},{"location":"reference/dewret/core/#notes_11","text":"The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True","title":"Notes"},{"location":"reference/dewret/core/#separate_1","text":"def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify","title":"separate"},{"location":"reference/dewret/core/#series_1","text":"def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised.","title":"series"},{"location":"reference/dewret/core/#parameters_10","text":"expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated.","title":"Parameters"},{"location":"reference/dewret/core/#examples_84","text":"from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/core/#returns_4","text":"Expr : Expression Series expansion of the expression about x0","title":"Returns"},{"location":"reference/dewret/core/#raises_1","text":"TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object","title":"Raises"},{"location":"reference/dewret/core/#simplify_1","text":"def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify","title":"simplify"},{"location":"reference/dewret/core/#sort_key_1","text":"def sort_key ( self , order = None ) Return a sort key.","title":"sort_key"},{"location":"reference/dewret/core/#examples_85","text":"from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2]","title":"Examples"},{"location":"reference/dewret/core/#subs_1","text":"def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made.","title":"subs"},{"location":"reference/dewret/core/#examples_86","text":"from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained.","title":"Examples"},{"location":"reference/dewret/core/#see-also_26","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision","title":"See Also"},{"location":"reference/dewret/core/#taylor_term_1","text":"def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\".","title":"taylor_term"},{"location":"reference/dewret/core/#to_nnf_1","text":"def to_nnf ( self , simplify = True )","title":"to_nnf"},{"location":"reference/dewret/core/#together_1","text":"def together ( self , * args , ** kwargs ) See the together function in sympy.polys","title":"together"},{"location":"reference/dewret/core/#transpose_1","text":"def transpose ( self )","title":"transpose"},{"location":"reference/dewret/core/#trigsimp_1","text":"def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify","title":"trigsimp"},{"location":"reference/dewret/core/#xreplace_1","text":"def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression.","title":"xreplace"},{"location":"reference/dewret/core/#parameters_11","text":"rule : dict-like Expresses a replacement rule","title":"Parameters"},{"location":"reference/dewret/core/#returns_5","text":"xreplace : the result of the replacement","title":"Returns"},{"location":"reference/dewret/core/#examples_87","text":"from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),)","title":"Examples"},{"location":"reference/dewret/core/#see-also_27","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves.","title":"See Also"},{"location":"reference/dewret/core/#rendercall","text":"class RenderCall ( * args , ** kwargs ) Callable that will render out workflow(s).","title":"RenderCall"},{"location":"reference/dewret/core/#ancestors-in-mro_6","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#structuredrendermodule","text":"class StructuredRenderModule ( * args , ** kwargs ) Render module that returns JSON/YAML-serializable structures.","title":"StructuredRenderModule"},{"location":"reference/dewret/core/#ancestors-in-mro_7","text":"dewret.core.BaseRenderModule typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/dewret/core/#default_config_2","text":"def default_config ( ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Retrieve default settings. These will not change during execution, but can be overridden by dewret.core.set_render_configuration . Returns: a static, serializable dict.","title":"default_config"},{"location":"reference/dewret/core/#methods_4","text":"","title":"Methods"},{"location":"reference/dewret/core/#render","text":"def render ( self , workflow : dewret . core . WorkflowProtocol , ** kwargs : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] ) -> dict [ str , dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]]] Turn a workflow into a serializable structure. Returns: one or more subworkflows with a __root__ key representing the outermost workflow, at least.","title":"render"},{"location":"reference/dewret/core/#unevaluatableerror","text":"class UnevaluatableError ( / , * args , ** kwargs ) Signposts that a user has tried to treat a reference as the real (runtime) value. For example, by comparing to a concrete integer or value, etc.","title":"UnevaluatableError"},{"location":"reference/dewret/core/#ancestors-in-mro_8","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/dewret/core/#methods_5","text":"","title":"Methods"},{"location":"reference/dewret/core/#add_note","text":"def add_note ( ... ) Exception.add_note(note) -- add a note to the exception","title":"add_note"},{"location":"reference/dewret/core/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dewret/core/#workflowcomponent","text":"class WorkflowComponent ( * args : Any , workflow : dewret . core . WorkflowProtocol , ** kwargs : Any ) Base class for anything directly tied to an individual Workflow .","title":"WorkflowComponent"},{"location":"reference/dewret/core/#attributes_1","text":"Name Type Description Default workflow None the Workflow that this is tied to. None","title":"Attributes"},{"location":"reference/dewret/core/#descendants_3","text":"dewret.core.Reference dewret.workflow.BaseStep dewret.workflow.ParameterReference","title":"Descendants"},{"location":"reference/dewret/core/#workflowprotocol","text":"class WorkflowProtocol ( * args , ** kwargs ) Expected structure for a workflow. We do not expect various workflow implementations, but this allows us to define the interface expected by the core classes.","title":"WorkflowProtocol"},{"location":"reference/dewret/core/#ancestors-in-mro_9","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/core/#methods_6","text":"","title":"Methods"},{"location":"reference/dewret/core/#remap","text":"def remap ( self , name : str ) -> str Perform any name-changing for steps, etc. in the workflow. This enables, for example, simplifying all the IDs to an integer sequence. Returns: remapped name.","title":"remap"},{"location":"reference/dewret/core/#set_result","text":"def set_result ( self , result : sympy . core . basic . Basic | list [ sympy . core . basic . Basic ] | tuple [ sympy . core . basic . Basic ] ) -> None Set the step that should produce a result for the overall workflow.","title":"set_result"},{"location":"reference/dewret/core/#simplify_ids","text":"def simplify_ids ( self , infix : list [ str ] | None = None ) -> None Drop the non-human-readable IDs if possible, in favour of integer sequences. Parameters: Name Type Description Default infix None any inherited intermediary identifiers, to allow nesting, or None. None","title":"simplify_ids"},{"location":"reference/dewret/render/","text":"Module dewret.render Utilities for building renderers. Provides the routines for calling varied renderers in a standard way, and for renderers to reuse to build up their own functionality. Variables T Functions base_render def base_render ( workflow : dewret . workflow . Workflow , build_cb : Callable [[ dewret . workflow . Workflow ], ~ T ] ) -> dict [ str , ~ T ] Render to a dict-like structure. Parameters: Name Type Description Default workflow None workflow to evaluate result. None build_cb None a callback to call for each workflow found. None Returns: Type Description None Reduced form as a native Python dict structure for serialization. get_render_method def get_render_method ( renderer : pathlib . Path | dewret . core . RawRenderModule | dewret . core . StructuredRenderModule , pretty : bool = False ) -> dewret . core . RenderCall Create a ready-made callable to render the workflow that is appropriate for the renderer module. Parameters: Name Type Description Default renderer None a module or path to a module. None pretty None whether the renderer should attempt to YAML-format the output (if relevant). None structured_to_raw def structured_to_raw ( rendered : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ], pretty : bool = False ) -> str Serialize a serializable structure to a string. Parameters: Name Type Description Default rendered None a possibly-nested, static basic Python structure. None pretty None whether to attempt YAML dumping with an indent of 2. None write_rendered_output def write_rendered_output ( rendered : dict [ str , str ] | dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]], output : str , opener : Callable [[ str , str ], ContextManager [ IO [ Any ]]] ) -> None Utility function to handle writing rendered output to file or stdout.","title":"Render"},{"location":"reference/dewret/render/#module-dewretrender","text":"Utilities for building renderers. Provides the routines for calling varied renderers in a standard way, and for renderers to reuse to build up their own functionality.","title":"Module dewret.render"},{"location":"reference/dewret/render/#variables","text":"T","title":"Variables"},{"location":"reference/dewret/render/#functions","text":"","title":"Functions"},{"location":"reference/dewret/render/#base_render","text":"def base_render ( workflow : dewret . workflow . Workflow , build_cb : Callable [[ dewret . workflow . Workflow ], ~ T ] ) -> dict [ str , ~ T ] Render to a dict-like structure. Parameters: Name Type Description Default workflow None workflow to evaluate result. None build_cb None a callback to call for each workflow found. None Returns: Type Description None Reduced form as a native Python dict structure for serialization.","title":"base_render"},{"location":"reference/dewret/render/#get_render_method","text":"def get_render_method ( renderer : pathlib . Path | dewret . core . RawRenderModule | dewret . core . StructuredRenderModule , pretty : bool = False ) -> dewret . core . RenderCall Create a ready-made callable to render the workflow that is appropriate for the renderer module. Parameters: Name Type Description Default renderer None a module or path to a module. None pretty None whether the renderer should attempt to YAML-format the output (if relevant). None","title":"get_render_method"},{"location":"reference/dewret/render/#structured_to_raw","text":"def structured_to_raw ( rendered : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ], pretty : bool = False ) -> str Serialize a serializable structure to a string. Parameters: Name Type Description Default rendered None a possibly-nested, static basic Python structure. None pretty None whether to attempt YAML dumping with an indent of 2. None","title":"structured_to_raw"},{"location":"reference/dewret/render/#write_rendered_output","text":"def write_rendered_output ( rendered : dict [ str , str ] | dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]], output : str , opener : Callable [[ str , str ], ContextManager [ IO [ Any ]]] ) -> None Utility function to handle writing rendered output to file or stdout.","title":"write_rendered_output"},{"location":"reference/dewret/tasks/","text":"Module dewret.tasks Abstraction layer for task operations. Access dask, or other, backends consistently using this module. It provides decorators and execution calls that manage tasks. Note that the task decorator should be called with no arguments, and will return the appropriate decorator for the current backend. Typical usage example: >>> @task () ... def increment ( num : int ) -> int : ... return num + 1 Variables DEFAULT_BACKEND EXECUTION_TIME Param RetType T construct Functions ensure_lazy def ensure_lazy ( task : Any ) -> dewret . workflow . Lazy | None Evaluate a single task for a known workflow. As we mask our lazy-evaluable functions to appear as their original types to the type system (see dewret.tasks.task ), we must cast them back, to allow the type-checker to comb the remainder of the code. Parameters: Name Type Description Default task None the suspected task to check. None Returns: Type Description None Original task, cast to a Lazy, or None. evaluate def evaluate ( task : Any , * args : Any , execute : bool = False , ** kwargs : Any ) -> Any Get a result of a task, either as a value or lazily. Parameters: Name Type Description Default task None task to evaluate None *args None other arguments to the evaluator None execute None whether or not to evaluate to obtain the final result None **kwargs None other arguments to the evaluator None Returns: Type Description None Structure of lazy evaluations if lazy, else actual result. factory def factory ( fn : collections . abc . Callable [ ... , ~ RetType ] ) -> collections . abc . Callable [ ... , ~ RetType ] Create a factory, that can be treated as complex input to a workflow. Parameters: Name Type Description Default fn None a callable to create the entity. None in_nested_task def in_nested_task ( ) -> Generator [ NoneType , NoneType , NoneType ] Informs the builder that we are within a nested task. This is only really relevant in the subworkflow context. TODO: check impact of ContextVar being thread-sensitive on build. is_in_nested_task def is_in_nested_task ( ) -> bool Check if we are within a nested task. Used, for example, to see if discovered parameters should be treated as \"local\" (i.e. should take a default to the step) or global (i.e. should be turned into a workflow parameter) if we are inside or outside a subworkflow, respectively. lazy def lazy ( ) -> collections . abc . Callable [[ collections . abc . Callable [ ... , typing . Any ]], dewret . workflow . Lazy ] Get the lazy decorator for this backend. Returns: Type Description None Real decorator for this backend. set_backend def set_backend ( backend : dewret . tasks . Backend ) -> None Choose a backend. Will raise an error if a backend is already chosen. Parameters: Name Type Description Default backend None chosen backend to use from here-on in. None task def task ( nested : bool = False , flatten_nested : bool = True , is_factory : bool = False ) -> collections . abc . Callable [[ collections . abc . Callable [ ~ Param , ~ RetType ]], collections . abc . Callable [ ~ Param , ~ RetType ]] Decorator factory abstracting backend's own task decorator. For example: >>> @task () ... def increment ( num : int ) -> int : ... return num + 1 If the backend is dask (the default), it is will evaluate this as a dask.delayed . Note that, with any backend, dewret will hijack the decorator to record the attempted evalution rather than actually evaluating the lazy function. Nonetheless, this hijacking will still be executed with the backend's lazy executor, so dask.delayed will still be called, for example, in the dask case. Parameters: Name Type Description Default nested None whether this should be executed to find other tasks. None flatten_nested None (only relevant to nested tasks) should this nested task be considered a distinct subworkflow, or is it just organizational for the outer workflow. None is_factory None whether this task should be marked as a 'factory', rather than a normal step. None Returns: Type Description None Decorator for the current backend to mark lazy-executable tasks. Raises: Type Description TypeError if arguments are missing or incorrect, in line with usual Python behaviour. unwrap def unwrap ( task : dewret . workflow . Lazy ) -> collections . abc . Callable [ ... , typing . Any ] Unwraps a lazy-evaluated function to get the function. Ideally, we could use the __wrapped__ property but not all workflow engines support this, and most importantly, dask has only done so as of 2024.03. Parameters: Name Type Description Default task None task to be unwrapped. None Returns: Type Description None Original target. Raises: Type Description RuntimeError if the task is not a wrapped function. workflow def workflow ( ) -> collections . abc . Callable [[ collections . abc . Callable [ ~ Param , ~ RetType ]], collections . abc . Callable [ ~ Param , ~ RetType ]] Shortcut for marking a task as nested. A nested task is one which calls other tasks and does not do anything else important. It will not actually get called at runtime, but should map entirely into the graph. As such, arithmetic operations on results, etc. will cause errors at render-time. Combining tasks is acceptable, and intended. The effect of the nested task will be considered equivalent to whatever reaching whatever step reference is returned at the end. >>> @task () ... def increment ( num : int ) -> int : ... return num + 1 >>> @workflow () ... def double_increment ( num : int ) -> int : ... return increment ( increment ( num = num )) Returns: Type Description None Task that runs at render, not execution, time. Classes Backend class Backend ( * args , ** kwds ) Stringy enum representing available backends. Ancestors (in MRO) enum.Enum Class variables DASK name value TaskException class TaskException ( task : dewret . workflow . Task | collections . abc . Callable [ ... , typing . Any ], dec_tb : traceback | None , tb : traceback | None , message : str , * args : Any , ** kwargs : Any ) Exception tied to a specific task. Primarily aimed at parsing issues, but this will ensure that a message is shown with useful debug information for the workflow writer. Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods add_note def add_note ( ... ) Exception.add_note(note) -- add a note to the exception with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. TaskManager class TaskManager ( / , * args , ** kwargs ) Overarching backend-agnostic task manager. Gatekeeps the specific backend implementation. This can be instantiated without choosing a backend, but the first call to any of its methods will concretize that choice - either as the default, or the backend set via TaskManager.set_backend . It cannot be changed after this point. Methods backend def backend ( ... ) Import backend module. Cached property to load the backend module, if it has not been already. Returns: Type Description None Backend module for the specific choice of backend. ensure_lazy def ensure_lazy ( self , task : Any ) -> dewret . workflow . Lazy | None Evaluate a single task for a known workflow. As we mask our lazy-evaluable functions to appear as their original types to the type system (see dewret.tasks.task ), we must cast them back, to allow the type-checker to comb the remainder of the code. Parameters: Name Type Description Default task None the suspected task to check. None Returns: Type Description None Original task, cast to a Lazy, or None. evaluate def evaluate ( self , task : dewret . workflow . Lazy | list [ dewret . workflow . Lazy ] | tuple [ dewret . workflow . Lazy , ... ], __workflow__ : dewret . workflow . Workflow , thread_pool : concurrent . futures . thread . ThreadPoolExecutor | None = None , ** kwargs : Any ) -> Any Evaluate a single task for a known workflow. Parameters: Name Type Description Default task None the task to evaluate. None workflow None workflow within which this exists. None thread_pool None existing pool of threads to run this in, or None. None **kwargs None any arguments to pass to the task. None make_lazy def make_lazy ( self ) -> collections . abc . Callable [[ collections . abc . Callable [ ... , typing . Any ]], dewret . workflow . Lazy ] Get the lazy decorator for this backend. Returns: Type Description None Real decorator for this backend. set_backend def set_backend ( self , backend : dewret . tasks . Backend ) -> dewret . tasks . Backend Choose a backend. Sets the backend, provided it has not already been loaded. Parameters: Name Type Description Default backend None chosen backend, to override the default. None Returns: Type Description None Backend that was set. Raises: Type Description RuntimeError when a backend has already been loaded. unwrap def unwrap ( self , task : dewret . workflow . Lazy ) -> collections . abc . Callable [ ... , typing . Any ] Unwraps a lazy-evaluated function to get the function. Ideally, we could use the __wrapped__ property but not all workflow engines support this, and most importantly, dask has only done so as of 2024.03. Parameters: Name Type Description Default task None task to be unwrapped. None Returns: Type Description None Original target. Raises: Type Description RuntimeError if the task is not a wrapped function.","title":"Tasks"},{"location":"reference/dewret/tasks/#module-dewrettasks","text":"Abstraction layer for task operations. Access dask, or other, backends consistently using this module. It provides decorators and execution calls that manage tasks. Note that the task decorator should be called with no arguments, and will return the appropriate decorator for the current backend. Typical usage example: >>> @task () ... def increment ( num : int ) -> int : ... return num + 1","title":"Module dewret.tasks"},{"location":"reference/dewret/tasks/#variables","text":"DEFAULT_BACKEND EXECUTION_TIME Param RetType T construct","title":"Variables"},{"location":"reference/dewret/tasks/#functions","text":"","title":"Functions"},{"location":"reference/dewret/tasks/#ensure_lazy","text":"def ensure_lazy ( task : Any ) -> dewret . workflow . Lazy | None Evaluate a single task for a known workflow. As we mask our lazy-evaluable functions to appear as their original types to the type system (see dewret.tasks.task ), we must cast them back, to allow the type-checker to comb the remainder of the code. Parameters: Name Type Description Default task None the suspected task to check. None Returns: Type Description None Original task, cast to a Lazy, or None.","title":"ensure_lazy"},{"location":"reference/dewret/tasks/#evaluate","text":"def evaluate ( task : Any , * args : Any , execute : bool = False , ** kwargs : Any ) -> Any Get a result of a task, either as a value or lazily. Parameters: Name Type Description Default task None task to evaluate None *args None other arguments to the evaluator None execute None whether or not to evaluate to obtain the final result None **kwargs None other arguments to the evaluator None Returns: Type Description None Structure of lazy evaluations if lazy, else actual result.","title":"evaluate"},{"location":"reference/dewret/tasks/#factory","text":"def factory ( fn : collections . abc . Callable [ ... , ~ RetType ] ) -> collections . abc . Callable [ ... , ~ RetType ] Create a factory, that can be treated as complex input to a workflow. Parameters: Name Type Description Default fn None a callable to create the entity. None","title":"factory"},{"location":"reference/dewret/tasks/#in_nested_task","text":"def in_nested_task ( ) -> Generator [ NoneType , NoneType , NoneType ] Informs the builder that we are within a nested task. This is only really relevant in the subworkflow context. TODO: check impact of ContextVar being thread-sensitive on build.","title":"in_nested_task"},{"location":"reference/dewret/tasks/#is_in_nested_task","text":"def is_in_nested_task ( ) -> bool Check if we are within a nested task. Used, for example, to see if discovered parameters should be treated as \"local\" (i.e. should take a default to the step) or global (i.e. should be turned into a workflow parameter) if we are inside or outside a subworkflow, respectively.","title":"is_in_nested_task"},{"location":"reference/dewret/tasks/#lazy","text":"def lazy ( ) -> collections . abc . Callable [[ collections . abc . Callable [ ... , typing . Any ]], dewret . workflow . Lazy ] Get the lazy decorator for this backend. Returns: Type Description None Real decorator for this backend.","title":"lazy"},{"location":"reference/dewret/tasks/#set_backend","text":"def set_backend ( backend : dewret . tasks . Backend ) -> None Choose a backend. Will raise an error if a backend is already chosen. Parameters: Name Type Description Default backend None chosen backend to use from here-on in. None","title":"set_backend"},{"location":"reference/dewret/tasks/#task","text":"def task ( nested : bool = False , flatten_nested : bool = True , is_factory : bool = False ) -> collections . abc . Callable [[ collections . abc . Callable [ ~ Param , ~ RetType ]], collections . abc . Callable [ ~ Param , ~ RetType ]] Decorator factory abstracting backend's own task decorator. For example: >>> @task () ... def increment ( num : int ) -> int : ... return num + 1 If the backend is dask (the default), it is will evaluate this as a dask.delayed . Note that, with any backend, dewret will hijack the decorator to record the attempted evalution rather than actually evaluating the lazy function. Nonetheless, this hijacking will still be executed with the backend's lazy executor, so dask.delayed will still be called, for example, in the dask case. Parameters: Name Type Description Default nested None whether this should be executed to find other tasks. None flatten_nested None (only relevant to nested tasks) should this nested task be considered a distinct subworkflow, or is it just organizational for the outer workflow. None is_factory None whether this task should be marked as a 'factory', rather than a normal step. None Returns: Type Description None Decorator for the current backend to mark lazy-executable tasks. Raises: Type Description TypeError if arguments are missing or incorrect, in line with usual Python behaviour.","title":"task"},{"location":"reference/dewret/tasks/#unwrap","text":"def unwrap ( task : dewret . workflow . Lazy ) -> collections . abc . Callable [ ... , typing . Any ] Unwraps a lazy-evaluated function to get the function. Ideally, we could use the __wrapped__ property but not all workflow engines support this, and most importantly, dask has only done so as of 2024.03. Parameters: Name Type Description Default task None task to be unwrapped. None Returns: Type Description None Original target. Raises: Type Description RuntimeError if the task is not a wrapped function.","title":"unwrap"},{"location":"reference/dewret/tasks/#workflow","text":"def workflow ( ) -> collections . abc . Callable [[ collections . abc . Callable [ ~ Param , ~ RetType ]], collections . abc . Callable [ ~ Param , ~ RetType ]] Shortcut for marking a task as nested. A nested task is one which calls other tasks and does not do anything else important. It will not actually get called at runtime, but should map entirely into the graph. As such, arithmetic operations on results, etc. will cause errors at render-time. Combining tasks is acceptable, and intended. The effect of the nested task will be considered equivalent to whatever reaching whatever step reference is returned at the end. >>> @task () ... def increment ( num : int ) -> int : ... return num + 1 >>> @workflow () ... def double_increment ( num : int ) -> int : ... return increment ( increment ( num = num )) Returns: Type Description None Task that runs at render, not execution, time.","title":"workflow"},{"location":"reference/dewret/tasks/#classes","text":"","title":"Classes"},{"location":"reference/dewret/tasks/#backend","text":"class Backend ( * args , ** kwds ) Stringy enum representing available backends.","title":"Backend"},{"location":"reference/dewret/tasks/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/dewret/tasks/#class-variables","text":"DASK name value","title":"Class variables"},{"location":"reference/dewret/tasks/#taskexception","text":"class TaskException ( task : dewret . workflow . Task | collections . abc . Callable [ ... , typing . Any ], dec_tb : traceback | None , tb : traceback | None , message : str , * args : Any , ** kwargs : Any ) Exception tied to a specific task. Primarily aimed at parsing issues, but this will ensure that a message is shown with useful debug information for the workflow writer.","title":"TaskException"},{"location":"reference/dewret/tasks/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dewret/tasks/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/dewret/tasks/#methods","text":"","title":"Methods"},{"location":"reference/dewret/tasks/#add_note","text":"def add_note ( ... ) Exception.add_note(note) -- add a note to the exception","title":"add_note"},{"location":"reference/dewret/tasks/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dewret/tasks/#taskmanager","text":"class TaskManager ( / , * args , ** kwargs ) Overarching backend-agnostic task manager. Gatekeeps the specific backend implementation. This can be instantiated without choosing a backend, but the first call to any of its methods will concretize that choice - either as the default, or the backend set via TaskManager.set_backend . It cannot be changed after this point.","title":"TaskManager"},{"location":"reference/dewret/tasks/#methods_1","text":"","title":"Methods"},{"location":"reference/dewret/tasks/#backend_1","text":"def backend ( ... ) Import backend module. Cached property to load the backend module, if it has not been already. Returns: Type Description None Backend module for the specific choice of backend.","title":"backend"},{"location":"reference/dewret/tasks/#ensure_lazy_1","text":"def ensure_lazy ( self , task : Any ) -> dewret . workflow . Lazy | None Evaluate a single task for a known workflow. As we mask our lazy-evaluable functions to appear as their original types to the type system (see dewret.tasks.task ), we must cast them back, to allow the type-checker to comb the remainder of the code. Parameters: Name Type Description Default task None the suspected task to check. None Returns: Type Description None Original task, cast to a Lazy, or None.","title":"ensure_lazy"},{"location":"reference/dewret/tasks/#evaluate_1","text":"def evaluate ( self , task : dewret . workflow . Lazy | list [ dewret . workflow . Lazy ] | tuple [ dewret . workflow . Lazy , ... ], __workflow__ : dewret . workflow . Workflow , thread_pool : concurrent . futures . thread . ThreadPoolExecutor | None = None , ** kwargs : Any ) -> Any Evaluate a single task for a known workflow. Parameters: Name Type Description Default task None the task to evaluate. None workflow None workflow within which this exists. None thread_pool None existing pool of threads to run this in, or None. None **kwargs None any arguments to pass to the task. None","title":"evaluate"},{"location":"reference/dewret/tasks/#make_lazy","text":"def make_lazy ( self ) -> collections . abc . Callable [[ collections . abc . Callable [ ... , typing . Any ]], dewret . workflow . Lazy ] Get the lazy decorator for this backend. Returns: Type Description None Real decorator for this backend.","title":"make_lazy"},{"location":"reference/dewret/tasks/#set_backend_1","text":"def set_backend ( self , backend : dewret . tasks . Backend ) -> dewret . tasks . Backend Choose a backend. Sets the backend, provided it has not already been loaded. Parameters: Name Type Description Default backend None chosen backend, to override the default. None Returns: Type Description None Backend that was set. Raises: Type Description RuntimeError when a backend has already been loaded.","title":"set_backend"},{"location":"reference/dewret/tasks/#unwrap_1","text":"def unwrap ( self , task : dewret . workflow . Lazy ) -> collections . abc . Callable [ ... , typing . Any ] Unwraps a lazy-evaluated function to get the function. Ideally, we could use the __wrapped__ property but not all workflow engines support this, and most importantly, dask has only done so as of 2024.03. Parameters: Name Type Description Default task None task to be unwrapped. None Returns: Type Description None Original target. Raises: Type Description RuntimeError if the task is not a wrapped function.","title":"unwrap"},{"location":"reference/dewret/utils/","text":"Module dewret.utils Utility module. General types and functions to centralize common logic. Functions crawl_raw def crawl_raw ( value : Any , action : Optional [ Callable [[ Any ], Any ]] = None ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Takes a Raw-like structure and makes it RawType. Particularly useful for squashing any TypedDicts. Parameters: Name Type Description Default value None value to squash None action None an callback to apply to each found entry, or None. None ensure_raw def ensure_raw ( value : Any , cast_tuple : bool = False ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Check if a variable counts as \"raw\". This works around a checking issue that isinstance of a union of types assigned to a variable, such as RawType , may throw errors even though Python 3.11+ does not. Instead, we explicitly make the full union in the statement below. firm_to_raw def firm_to_raw ( value : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | list [ 'FirmType' ] | dict [ str , 'FirmType' ] | tuple [ 'FirmType' , ... ] ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Convenience wrapper for firm structures. Turns structures that would be raw, except for tuples, into raw structures by mapping any tuples to lists. Parameters: Name Type Description Default value None a firm structure (contains raw/tuple values). None flatten_if_set def flatten_if_set ( value : Any ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | dewret . utils . Unset Takes a Raw-like structure and makes it RawType or Unset. Flattens if the value is set, but otherwise returns the unset sentinel value as-is. Parameters: Name Type Description Default value None value to squash None format_user_args def format_user_args ( args : str ) -> dict [ str , typing . Any ] Format user arguments from the command line. Supports: - @filename: loads arguments from a YAML file - empty string: returns an empty dict - key1:val1,key2:val2: parses a comma-separated list into a dict get_json_args def get_json_args ( args : list [ str ] ) -> dict [ str , typing . Any ] Parse a sequence of key:val strings into a dictionary, where values are JSON-parsed. Parameters: Name Type Description Default args None A sequence of strings, each in the format 'key:val', where val is a JSON literal. None Returns: Type Description None A dictionary mapping keys to their corresponding parsed JSON values. Raises: Type Description RuntimeError If any argument is not in the expected 'key:val' format. json.JSONDecodeError If a value is not valid JSON. hasher def hasher ( construct : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | list [ 'FirmType' ] | dict [ str , 'FirmType' ] | tuple [ 'FirmType' , ... ] ) -> str Consistently hash a RawType or tuple structure. Turns a possibly nested structure of basic types, dicts, lists and tuples into a consistent hash. Parameters: Name Type Description Default construct None structure to hash. None Returns: Type Description None Hash string that should be unique to the construct. The limits of this uniqueness have not yet been explicitly calculated. is_expr def is_expr ( value : Any , permitted_references : type = < class ' dewret . core . Reference '> ) -> bool Confirms whether a structure has only raw or expression types. Parameters: Name Type Description Default value None a crawlable structure. None permitted_references None a class representing the allowed types of References. None is_firm def is_firm ( value : Any , check : Optional [ Callable [[ Any ], bool ]] = None ) -> bool Confirms whether a function is firm. That is, whether its contents are raw or tuples. Parameters: Name Type Description Default value None value to check. None check None any additional check to apply. None is_raw def is_raw ( value : Any , check : Optional [ Callable [[ Any ], bool ]] = None ) -> bool Check if a variable counts as \"raw\". This works around a checking issue that isinstance of a union of types assigned to a variable, such as RawType , may throw errors even though Python 3.11+ does not. Instead, we explicitly make the full union in the statement below. is_raw_type def is_raw_type ( typ : type ) -> bool Check if a type counts as \"raw\". load_module_or_package def load_module_or_package ( target_name : str , path : pathlib . Path ) -> module Convenience loader for modules. If an __init__.py is found in the same location as the target, it will try to load the renderer module as if it is contained in a package and, if it cannot, will fall back to loading the single file. Parameters: Name Type Description Default target_name None module name that should appear in sys.modules . None path None location of the module. None make_traceback def make_traceback ( skip : int = 2 ) -> traceback | None Creates a traceback for the current frame. Necessary to allow tracebacks to be prepped for potential errors in lazy-evaluated functions. Parameters: Name Type Description Default skip None number of frames to skip before starting traceback. None resolve_renderer def resolve_renderer ( renderer : str ) -> pathlib . Path | dewret . core . RawRenderModule | dewret . core . StructuredRenderModule Resolve the renderer argument into either a module or a file path. If the renderer is a known name, attempts to import it as a module from dewret.renderers . If it starts with '@', treats the remainder as a file path. Parameters: Name Type Description Default renderer None The name of the renderer module or a file reference starting with '@'. None Returns: Type Description None A render module (imported) or a Path object to a renderer file. Raises: Type Description RuntimeError If the renderer format is invalid. NotImplementedError If the imported module does not conform to expected interfaces. ModuleNotFoundError If the module cannot be imported. Classes DataclassProtocol class DataclassProtocol ( * args , ** kwargs ) Format of a dataclass. Since dataclasses do not expose a proper type, we use this to represent them. Ancestors (in MRO) typing.Protocol typing.Generic Unset class Unset ( / , * args , ** kwargs ) Unset variable, with no default value. Descendants dewret.workflow.UnsetType","title":"Utils"},{"location":"reference/dewret/utils/#module-dewretutils","text":"Utility module. General types and functions to centralize common logic.","title":"Module dewret.utils"},{"location":"reference/dewret/utils/#functions","text":"","title":"Functions"},{"location":"reference/dewret/utils/#crawl_raw","text":"def crawl_raw ( value : Any , action : Optional [ Callable [[ Any ], Any ]] = None ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Takes a Raw-like structure and makes it RawType. Particularly useful for squashing any TypedDicts. Parameters: Name Type Description Default value None value to squash None action None an callback to apply to each found entry, or None. None","title":"crawl_raw"},{"location":"reference/dewret/utils/#ensure_raw","text":"def ensure_raw ( value : Any , cast_tuple : bool = False ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Check if a variable counts as \"raw\". This works around a checking issue that isinstance of a union of types assigned to a variable, such as RawType , may throw errors even though Python 3.11+ does not. Instead, we explicitly make the full union in the statement below.","title":"ensure_raw"},{"location":"reference/dewret/utils/#firm_to_raw","text":"def firm_to_raw ( value : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | list [ 'FirmType' ] | dict [ str , 'FirmType' ] | tuple [ 'FirmType' , ... ] ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] Convenience wrapper for firm structures. Turns structures that would be raw, except for tuples, into raw structures by mapping any tuples to lists. Parameters: Name Type Description Default value None a firm structure (contains raw/tuple values). None","title":"firm_to_raw"},{"location":"reference/dewret/utils/#flatten_if_set","text":"def flatten_if_set ( value : Any ) -> str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | dewret . utils . Unset Takes a Raw-like structure and makes it RawType or Unset. Flattens if the value is set, but otherwise returns the unset sentinel value as-is. Parameters: Name Type Description Default value None value to squash None","title":"flatten_if_set"},{"location":"reference/dewret/utils/#format_user_args","text":"def format_user_args ( args : str ) -> dict [ str , typing . Any ] Format user arguments from the command line. Supports: - @filename: loads arguments from a YAML file - empty string: returns an empty dict - key1:val1,key2:val2: parses a comma-separated list into a dict","title":"format_user_args"},{"location":"reference/dewret/utils/#get_json_args","text":"def get_json_args ( args : list [ str ] ) -> dict [ str , typing . Any ] Parse a sequence of key:val strings into a dictionary, where values are JSON-parsed. Parameters: Name Type Description Default args None A sequence of strings, each in the format 'key:val', where val is a JSON literal. None Returns: Type Description None A dictionary mapping keys to their corresponding parsed JSON values. Raises: Type Description RuntimeError If any argument is not in the expected 'key:val' format. json.JSONDecodeError If a value is not valid JSON.","title":"get_json_args"},{"location":"reference/dewret/utils/#hasher","text":"def hasher ( construct : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | list [ 'FirmType' ] | dict [ str , 'FirmType' ] | tuple [ 'FirmType' , ... ] ) -> str Consistently hash a RawType or tuple structure. Turns a possibly nested structure of basic types, dicts, lists and tuples into a consistent hash. Parameters: Name Type Description Default construct None structure to hash. None Returns: Type Description None Hash string that should be unique to the construct. The limits of this uniqueness have not yet been explicitly calculated.","title":"hasher"},{"location":"reference/dewret/utils/#is_expr","text":"def is_expr ( value : Any , permitted_references : type = < class ' dewret . core . Reference '> ) -> bool Confirms whether a structure has only raw or expression types. Parameters: Name Type Description Default value None a crawlable structure. None permitted_references None a class representing the allowed types of References. None","title":"is_expr"},{"location":"reference/dewret/utils/#is_firm","text":"def is_firm ( value : Any , check : Optional [ Callable [[ Any ], bool ]] = None ) -> bool Confirms whether a function is firm. That is, whether its contents are raw or tuples. Parameters: Name Type Description Default value None value to check. None check None any additional check to apply. None","title":"is_firm"},{"location":"reference/dewret/utils/#is_raw","text":"def is_raw ( value : Any , check : Optional [ Callable [[ Any ], bool ]] = None ) -> bool Check if a variable counts as \"raw\". This works around a checking issue that isinstance of a union of types assigned to a variable, such as RawType , may throw errors even though Python 3.11+ does not. Instead, we explicitly make the full union in the statement below.","title":"is_raw"},{"location":"reference/dewret/utils/#is_raw_type","text":"def is_raw_type ( typ : type ) -> bool Check if a type counts as \"raw\".","title":"is_raw_type"},{"location":"reference/dewret/utils/#load_module_or_package","text":"def load_module_or_package ( target_name : str , path : pathlib . Path ) -> module Convenience loader for modules. If an __init__.py is found in the same location as the target, it will try to load the renderer module as if it is contained in a package and, if it cannot, will fall back to loading the single file. Parameters: Name Type Description Default target_name None module name that should appear in sys.modules . None path None location of the module. None","title":"load_module_or_package"},{"location":"reference/dewret/utils/#make_traceback","text":"def make_traceback ( skip : int = 2 ) -> traceback | None Creates a traceback for the current frame. Necessary to allow tracebacks to be prepped for potential errors in lazy-evaluated functions. Parameters: Name Type Description Default skip None number of frames to skip before starting traceback. None","title":"make_traceback"},{"location":"reference/dewret/utils/#resolve_renderer","text":"def resolve_renderer ( renderer : str ) -> pathlib . Path | dewret . core . RawRenderModule | dewret . core . StructuredRenderModule Resolve the renderer argument into either a module or a file path. If the renderer is a known name, attempts to import it as a module from dewret.renderers . If it starts with '@', treats the remainder as a file path. Parameters: Name Type Description Default renderer None The name of the renderer module or a file reference starting with '@'. None Returns: Type Description None A render module (imported) or a Path object to a renderer file. Raises: Type Description RuntimeError If the renderer format is invalid. NotImplementedError If the imported module does not conform to expected interfaces. ModuleNotFoundError If the module cannot be imported.","title":"resolve_renderer"},{"location":"reference/dewret/utils/#classes","text":"","title":"Classes"},{"location":"reference/dewret/utils/#dataclassprotocol","text":"class DataclassProtocol ( * args , ** kwargs ) Format of a dataclass. Since dataclasses do not expose a proper type, we use this to represent them.","title":"DataclassProtocol"},{"location":"reference/dewret/utils/#ancestors-in-mro","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/utils/#unset","text":"class Unset ( / , * args , ** kwargs ) Unset variable, with no default value.","title":"Unset"},{"location":"reference/dewret/utils/#descendants","text":"dewret.workflow.UnsetType","title":"Descendants"},{"location":"reference/dewret/workflow/","text":"Module dewret.workflow Overarching workflow concepts. Basic constructs for describing a workflow. Variables AVAILABLE_TYPES CHECK_IDS LazyFactory Param RetType StepExecution T TYPE_CHECKING Target U UNSET logger Functions execute_step def execute_step ( task : 'Any' , ** kwargs : 'Any' ) -> 'Any' Evaluate a single task for a known workflow. Parameters: Name Type Description Default task None the task to evaluate. None **kwargs None any arguments to pass to the task. None expr_to_references def expr_to_references ( expression : 'Any' , remap : 'Callable[[Any], Any] | None' = None ) -> 'tuple[ExprType, list[Reference[Any] | Parameter[Any]]]' Pull out any references, or other free symbols, from an expression. Parameters: Name Type Description Default expression None normally a reference that can be immediately returned, but may be a sympy expression or a dict/tuple/list/etc. of such. None remap None a callable to project certain values down before extracting symbols, or None. None is_task def is_task ( task : 'Lazy' ) -> 'bool' Decide whether this is a task. Checks whether the wrapped function has the magic attribute __step_expression__ set to True, which is done within task creation. Parameters: Name Type Description Default task None lazy-evaluated value, suspected to be a task. None Returns: Type Description None True if task is indeed a task. param def param ( name : 'str' , default : 'T | UnsetType[T] | Unset' = < dewret . utils . Unset object at 0x7f2d6ea66910 > , tethered : 'Literal[False] | None | Step | Workflow' = False , typ : 'type[T] | Unset' = < dewret . utils . Unset object at 0x7f2d6ea66910 > , autoname : 'bool' = False ) -> 'T' Create a parameter. Will cast so it looks like the original type. Returns: Type Description None Parameter class cast to the type of the supplied default. unify_workflows def unify_workflows ( expression : 'Any' , base_workflow : 'Workflow | None' , set_only : 'bool' = False ) -> 'tuple[Basic | None, Workflow | None]' Takes an expression and ensures all of its references exist in the same workflow. Parameters: Name Type Description Default expression None any valid argument to dewret.workflow.expr_to_references . None base_workflow None the desired workflow to align on, or None. None set_only None whether to bother assimilating all the workflows (False), or to assume that has been done (False). None Classes BaseStep class BaseStep ( workflow : 'Workflow' , task : 'Task | Workflow' , arguments : 'Mapping[str, Reference[Any] | Raw]' , raw_as_parameter : 'bool' = False ) Lazy-evaluated function call. Individual function call to a lazy-evaluatable function, tracked for building up the Workflow . Attributes Name Type Description Default task None the Task being called in this step. None arguments None key-value pairs of arguments to this step. None Ancestors (in MRO) dewret.core.WorkflowComponent Descendants dewret.workflow.NestedStep dewret.workflow.Step Class variables positional_args Instance variables id Consistent ID based on the value. name Name for this step. May be remapped by the workflow to something nicer than the ID. return_type Take the type of the wrapped function from the target. Unwraps and inspects the signature, meaning that the original wrapped function must have a typehint for the return value. Methods make_reference def make_reference ( self , ** kwargs : 'Any' ) -> \"'StepReference[T]'\" Create a reference to this step. Builds a reference to the (result of) this step, which will be iterable if appropriate. Parameters: Name Type Description Default **kwargs None arguments for reference constructor, which will be supplemented appropriately. None set_workflow def set_workflow ( self , workflow : 'Workflow' , with_arguments : 'bool' = True ) -> 'None' Move the step reference to another workflow. This method is primarily intended to be called by a step, allowing it to switch to a new workflow. It also updates the workflow reference for any arguments that are steps themselves, if specified. Parameters: Name Type Description Default workflow None The new target workflow to which the step should be moved. None with_arguments None If True, also update the workflow reference for the step's arguments. None FactoryCall class FactoryCall ( workflow : 'Workflow' , task : 'Task | Workflow' , arguments : 'Mapping[str, Reference[Any] | Raw]' , raw_as_parameter : 'bool' = False ) Call to a factory function. Ancestors (in MRO) dewret.workflow.Step dewret.workflow.BaseStep dewret.core.WorkflowComponent Class variables positional_args Instance variables id Consistent ID based on the value. name Name for this step. May be remapped by the workflow to something nicer than the ID. return_type Take the type of the wrapped function from the target. Unwraps and inspects the signature, meaning that the original wrapped function must have a typehint for the return value. Methods make_reference def make_reference ( self , ** kwargs : 'Any' ) -> \"'StepReference[T]'\" Create a reference to this step. Builds a reference to the (result of) this step, which will be iterable if appropriate. Parameters: Name Type Description Default **kwargs None arguments for reference constructor, which will be supplemented appropriately. None set_workflow def set_workflow ( self , workflow : 'Workflow' , with_arguments : 'bool' = True ) -> 'None' Move the step reference to another workflow. This method is primarily intended to be called by a step, allowing it to switch to a new workflow. It also updates the workflow reference for any arguments that are steps themselves, if specified. Parameters: Name Type Description Default workflow None The new target workflow to which the step should be moved. None with_arguments None If True, also update the workflow reference for the step's arguments. None FieldableMixin class FieldableMixin ( self : 'FieldableProtocol' , * args : 'Any' , field : 'str | int | tuple[str | int, ...] | None' = None , ** kwargs : 'Any' ) Tooling for enhancing a type with referenceable fields. Descendants dewret.workflow.ParameterReference dewret.workflow.StepReference Methods find_field def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference. FieldableProtocol class FieldableProtocol ( * args : 'Any' , field : 'str | None' = None , ** kwargs : 'Any' ) Expected interfaces for a type that can take fields. Attributes Name Type Description Default field None tuple representing the named fields, either strings or integers. None Ancestors (in MRO) typing.Protocol typing.Generic Instance variables name The name for the target, accounting for the field. IterableParameterReference class IterableParameterReference ( typ : type [ ~ U ] | None = None , ** kwargs : Any ) Iterable form of parameter references. Ancestors (in MRO) dewret.core.IterableMixin dewret.workflow.ParameterReference dewret.workflow.FieldableMixin dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent Class variables ParameterReferenceMetadata default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol Static methods class_key def class_key ( ) Nice order of classes. fromiter def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first. Examples from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4) Instance variables args Returns a tuple of arguments of 'self'. Examples from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y Notes Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression. Examples from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args) Examples from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference. Methods adjoint def adjoint ( self ) apart def apart ( self , x = None , ** args ) See the apart function in sympy.polys args_cnc def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self. Explanation self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False. Examples from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []] as_base_exp def as_base_exp ( self ) -> 'tuple[Expr, Expr]' as_coeff_Add def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation. as_coeff_Mul def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product. as_coeff_add def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ()) as_coeff_exponent def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression. as_coeff_mul def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ()) as_coefficient def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None. Examples from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I) See Also coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used as_coefficients_dict def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned. Examples from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x} as_content_primitive def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self). Examples from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y) as_dummy def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned. Examples from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r Notes Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object. as_expr def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression. Examples from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x) as_independent def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True Examples -- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b)) See Also separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul as_leading_term def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value. Examples from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2) as_numer_denom def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else. See Also normal: return a/b instead of (a, b) as_ordered_factors def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self]. as_ordered_terms def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms. Examples from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1] as_poly def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None . Explanation from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None as_powers_dict def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary. See Also as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors. as_real_imag def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z)) as_set def as_set ( self ) Rewrites Boolean expression in terms of real sets. Examples from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo)) as_terms def as_terms ( self ) Transform an expression to a list of terms. aseries def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) . Parameters self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form. Examples from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x Returns Expr Asymptotic series expansion of the expression. Notes This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self . References .. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion See Also Expr.aseries: See the docstring of this function for complete details of this wrapper. atoms def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below. Examples from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)} cancel def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys coeff def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned. Explanation When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative. Examples from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1 See Also as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used collect def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify combsimp def combsimp ( self ) See the combsimp function in sympy.simplify compare def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned. Examples from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1 conjugate def conjugate ( self ) Returns the complex conjugate of 'self'. copy def copy ( self ) could_extract_minus_sign def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False. Examples from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True count def count ( self , query ) Count the number of matching subexpressions. count_ops def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count. diff def diff ( self , * symbols , ** assumptions ) dir def dir ( self , x , cdir ) doit def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x) dummy_eq def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols. Examples from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False equals def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None. Explanation If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False. evalf def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 expand def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information. extract_additively def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None. Examples from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3 See Also extract_multiplicatively coeff as_coefficient extract_branch_factor def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2) extract_multiplicatively def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self. Examples from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6 factor def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools find def find ( self , query , group = False ) Find all subexpressions matching a query. find_field def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference. fourier_series def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information. fps def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information. gammasimp def gammasimp ( self ) See the gammasimp function in sympy.simplify getO def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None. getn def getn ( self ) Returns the order of the expression. Explanation The order is determined either from the O(...) term. If there is no O(...) term, it returns None. Examples from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn() has def has ( self , * patterns ) Test whether any subexpression matches any of the patterns. Examples from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False has_free def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False. Examples from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True has_xfree def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches. Examples from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False integrate def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals invert def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions). See Also sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert is_algebraic_expr def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation. Examples from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True See Also is_rational_function References .. [1] https://en.wikipedia.org/wiki/Algebraic_expression is_constant def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively. Explanation If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing. Examples from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True is_hypergeometric def is_hypergeometric ( self , k ) is_meromorphic def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis. Examples from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False is_polynomial def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True). Examples from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function() is_rational_function def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True). Examples from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr(). is_same def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5). Examples In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False leadterm def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b). Examples from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2) limit def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim. lseries def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries(). match def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self Examples from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2} See Also matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching matches def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr. Examples from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c} n def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 normal def normal ( self ) Return the expression as a fraction. expression -> a/b See Also as_numer_denom: return (a, b) instead of a/b nseries def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries(). Examples from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y) nsimplify def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify powsimp def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify primitive def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float). Examples from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True radsimp def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify ratsimp def ratsimp ( self ) See the ratsimp function in sympy.simplify rcall def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z refine def refine ( self , assumption = True ) See the refine function in sympy.assumptions removeO def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one replace def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below: Examples Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1 See Also subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules rewrite def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten. Parameters args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True . Examples If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2) round def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number. Examples from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I Notes The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True separate def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify series def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised. Parameters expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated. Examples from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x Returns Expr : Expression Series expansion of the expression about x0 Raises TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object simplify def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify sort_key def sort_key ( self , order = None ) Return a sort key. Examples from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2] subs def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made. Examples from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained. See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision taylor_term def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\". to_nnf def to_nnf ( self , simplify = True ) together def together ( self , * args , ** kwargs ) See the together function in sympy.polys transpose def transpose ( self ) trigsimp def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify xreplace def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression. Parameters rule : dict-like Expresses a replacement rule Returns xreplace : the result of the replacement Examples from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),) See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves. IterableStepReference class IterableStepReference ( typ : type [ ~ U ] | None = None , ** kwargs : Any ) Iterable form of a step reference. Ancestors (in MRO) dewret.core.IterableMixin dewret.workflow.StepReference dewret.workflow.FieldableMixin dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent Class variables StepReferenceMetadata default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol Static methods class_key def class_key ( ) Nice order of classes. fromiter def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first. Examples from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4) Instance variables args Returns a tuple of arguments of 'self'. Examples from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y Notes Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression. Examples from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args) Examples from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference. Methods adjoint def adjoint ( self ) apart def apart ( self , x = None , ** args ) See the apart function in sympy.polys args_cnc def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self. Explanation self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False. Examples from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []] as_base_exp def as_base_exp ( self ) -> 'tuple[Expr, Expr]' as_coeff_Add def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation. as_coeff_Mul def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product. as_coeff_add def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ()) as_coeff_exponent def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression. as_coeff_mul def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ()) as_coefficient def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None. Examples from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I) See Also coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used as_coefficients_dict def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned. Examples from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x} as_content_primitive def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self). Examples from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y) as_dummy def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned. Examples from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r Notes Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object. as_expr def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression. Examples from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x) as_independent def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True Examples -- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b)) See Also separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul as_leading_term def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value. Examples from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2) as_numer_denom def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else. See Also normal: return a/b instead of (a, b) as_ordered_factors def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self]. as_ordered_terms def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms. Examples from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1] as_poly def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None . Explanation from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None as_powers_dict def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary. See Also as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors. as_real_imag def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z)) as_set def as_set ( self ) Rewrites Boolean expression in terms of real sets. Examples from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo)) as_terms def as_terms ( self ) Transform an expression to a list of terms. aseries def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) . Parameters self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form. Examples from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x Returns Expr Asymptotic series expansion of the expression. Notes This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self . References .. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion See Also Expr.aseries: See the docstring of this function for complete details of this wrapper. atoms def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below. Examples from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)} cancel def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys coeff def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned. Explanation When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative. Examples from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1 See Also as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used collect def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify combsimp def combsimp ( self ) See the combsimp function in sympy.simplify compare def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned. Examples from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1 conjugate def conjugate ( self ) Returns the complex conjugate of 'self'. copy def copy ( self ) could_extract_minus_sign def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False. Examples from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True count def count ( self , query ) Count the number of matching subexpressions. count_ops def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count. diff def diff ( self , * symbols , ** assumptions ) dir def dir ( self , x , cdir ) doit def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x) dummy_eq def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols. Examples from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False equals def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None. Explanation If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False. evalf def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 expand def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information. extract_additively def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None. Examples from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3 See Also extract_multiplicatively coeff as_coefficient extract_branch_factor def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2) extract_multiplicatively def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self. Examples from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6 factor def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools find def find ( self , query , group = False ) Find all subexpressions matching a query. find_field def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference. fourier_series def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information. fps def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information. gammasimp def gammasimp ( self ) See the gammasimp function in sympy.simplify getO def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None. getn def getn ( self ) Returns the order of the expression. Explanation The order is determined either from the O(...) term. If there is no O(...) term, it returns None. Examples from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn() has def has ( self , * patterns ) Test whether any subexpression matches any of the patterns. Examples from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False has_free def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False. Examples from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True has_xfree def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches. Examples from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False integrate def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals invert def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions). See Also sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert is_algebraic_expr def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation. Examples from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True See Also is_rational_function References .. [1] https://en.wikipedia.org/wiki/Algebraic_expression is_constant def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively. Explanation If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing. Examples from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True is_hypergeometric def is_hypergeometric ( self , k ) is_meromorphic def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis. Examples from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False is_polynomial def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True). Examples from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function() is_rational_function def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True). Examples from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr(). is_same def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5). Examples In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False leadterm def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b). Examples from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2) limit def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim. lseries def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries(). match def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self Examples from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2} See Also matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching matches def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr. Examples from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c} n def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 normal def normal ( self ) Return the expression as a fraction. expression -> a/b See Also as_numer_denom: return (a, b) instead of a/b nseries def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries(). Examples from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y) nsimplify def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify powsimp def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify primitive def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float). Examples from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True radsimp def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify ratsimp def ratsimp ( self ) See the ratsimp function in sympy.simplify rcall def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z refine def refine ( self , assumption = True ) See the refine function in sympy.assumptions removeO def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one replace def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below: Examples Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1 See Also subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules rewrite def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten. Parameters args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True . Examples If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2) round def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number. Examples from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I Notes The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True separate def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify series def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised. Parameters expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated. Examples from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x Returns Expr : Expression Series expansion of the expression about x0 Raises TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object simplify def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify sort_key def sort_key ( self , order = None ) Return a sort key. Examples from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2] subs def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made. Examples from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained. See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision taylor_term def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\". to_nnf def to_nnf ( self , simplify = True ) together def together ( self , * args , ** kwargs ) See the together function in sympy.polys transpose def transpose ( self ) trigsimp def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify xreplace def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression. Parameters rule : dict-like Expresses a replacement rule Returns xreplace : the result of the replacement Examples from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),) See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves. Lazy class Lazy ( * args , ** kwargs ) Requirements for a lazy-evaluatable function. Ancestors (in MRO) typing.Protocol typing.Generic Descendants dewret.workflow.LazyEvaluation LazyEvaluation class LazyEvaluation ( fn : 'Callable[Param, RetType]' ) Tracks a single evaluation of a lazy function. Ancestors (in MRO) dewret.workflow.Lazy typing.Protocol typing.Generic NestedStep class NestedStep ( workflow : 'Workflow' , name : 'str' , subworkflow : 'Workflow' , arguments : 'Mapping[str, Basic | Reference[Any] | Raw]' , raw_as_parameter : 'bool' = False ) Calling out to a subworkflow. Type of BaseStep to call a subworkflow, which holds a reference to it. Ancestors (in MRO) dewret.workflow.BaseStep dewret.core.WorkflowComponent Class variables positional_args Instance variables id Consistent ID based on the value. name Name for this step. May be remapped by the workflow to something nicer than the ID. return_type Take the type of the wrapped function from the target. Unwraps and inspects the signature, meaning that the original wrapped function must have a typehint for the return value. subworkflow Subworkflow that is wrapped. Methods make_reference def make_reference ( self , ** kwargs : 'Any' ) -> \"'StepReference[T]'\" Create a reference to this step. Builds a reference to the (result of) this step, which will be iterable if appropriate. Parameters: Name Type Description Default **kwargs None arguments for reference constructor, which will be supplemented appropriately. None set_workflow def set_workflow ( self , workflow : 'Workflow' , with_arguments : 'bool' = True ) -> 'None' Move the step reference to another workflow. This method is primarily intended to be called by a step, allowing it to switch to a new workflow. It also updates the workflow reference for any arguments that are steps themselves, if specified. Parameters: Name Type Description Default workflow None The new target workflow to which the step should be moved. None with_arguments None If True, also update the workflow reference for the step's arguments. None Parameter class Parameter ( name : 'str' , default : 'T | UnsetType[T]' , tethered : 'Literal[False] | None | Step | Workflow' = None , autoname : 'bool' = False , typ : 'type[T] | Unset' = < dewret . utils . Unset object at 0x7f2d6ea66910 > ) Global parameter. Independent parameter that will be used when a task is spotted reaching outside its scope. This wraps the variable it uses. To allow for potential arithmetic operations, etc. it is a Sympy symbol. Attributes Name Type Description Default name None name of the parameter. None default None captured default value from the original value. None Ancestors (in MRO) typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin Class variables autoname default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol Static methods class_key def class_key ( ) Nice order of classes. fromiter def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first. Examples from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4) is_loopable def is_loopable ( typ : 'type' ) -> 'bool' Checks if this type can be looped over. In particular, checks if this is an iterable that is NOT a str or bytes, possibly disguised behind an Annotated. Parameters: Name Type Description Default typ None type to check. None Instance variables args Returns a tuple of arguments of 'self'. Examples from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y Notes Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression. Examples from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} default Retrieve default value for this parameter, or an unset token. expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args) Examples from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Extended name, suitable for rendering. This attempts to create a unique name by tying the parameter to a step if the user has not explicitly provided a name, ideally the one where we discovered it. Methods adjoint def adjoint ( self ) apart def apart ( self , x = None , ** args ) See the apart function in sympy.polys args_cnc def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self. Explanation self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False. Examples from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []] as_base_exp def as_base_exp ( self ) -> 'tuple[Expr, Expr]' as_coeff_Add def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation. as_coeff_Mul def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product. as_coeff_add def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ()) as_coeff_exponent def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression. as_coeff_mul def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ()) as_coefficient def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None. Examples from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I) See Also coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used as_coefficients_dict def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned. Examples from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x} as_content_primitive def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self). Examples from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y) as_dummy def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned. Examples from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r Notes Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object. as_expr def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression. Examples from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x) as_independent def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True Examples -- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b)) See Also separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul as_leading_term def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value. Examples from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2) as_numer_denom def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else. See Also normal: return a/b instead of (a, b) as_ordered_factors def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self]. as_ordered_terms def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms. Examples from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1] as_poly def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None . Explanation from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None as_powers_dict def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary. See Also as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors. as_real_imag def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z)) as_set def as_set ( self ) Rewrites Boolean expression in terms of real sets. Examples from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo)) as_terms def as_terms ( self ) Transform an expression to a list of terms. aseries def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) . Parameters self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form. Examples from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x Returns Expr Asymptotic series expansion of the expression. Notes This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self . References .. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion See Also Expr.aseries: See the docstring of this function for complete details of this wrapper. atoms def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below. Examples from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)} cancel def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys coeff def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned. Explanation When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative. Examples from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1 See Also as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used collect def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify combsimp def combsimp ( self ) See the combsimp function in sympy.simplify compare def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned. Examples from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1 conjugate def conjugate ( self ) Returns the complex conjugate of 'self'. copy def copy ( self ) could_extract_minus_sign def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False. Examples from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True count def count ( self , query ) Count the number of matching subexpressions. count_ops def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count. diff def diff ( self , * symbols , ** assumptions ) dir def dir ( self , x , cdir ) doit def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x) dummy_eq def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols. Examples from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False equals def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None. Explanation If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False. evalf def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 expand def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information. extract_additively def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None. Examples from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3 See Also extract_multiplicatively coeff as_coefficient extract_branch_factor def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2) extract_multiplicatively def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self. Examples from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6 factor def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools find def find ( self , query , group = False ) Find all subexpressions matching a query. fourier_series def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information. fps def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information. gammasimp def gammasimp ( self ) See the gammasimp function in sympy.simplify getO def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None. getn def getn ( self ) Returns the order of the expression. Explanation The order is determined either from the O(...) term. If there is no O(...) term, it returns None. Examples from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn() has def has ( self , * patterns ) Test whether any subexpression matches any of the patterns. Examples from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False has_free def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False. Examples from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True has_xfree def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches. Examples from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False integrate def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals invert def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions). See Also sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert is_algebraic_expr def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation. Examples from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True See Also is_rational_function References .. [1] https://en.wikipedia.org/wiki/Algebraic_expression is_constant def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively. Explanation If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing. Examples from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True is_hypergeometric def is_hypergeometric ( self , k ) is_meromorphic def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis. Examples from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False is_polynomial def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True). Examples from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function() is_rational_function def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True). Examples from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr(). is_same def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5). Examples In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False leadterm def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b). Examples from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2) limit def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim. lseries def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries(). make_reference def make_reference ( self , ** kwargs : 'Any' ) -> \"'ParameterReference[T]'\" Creates a new reference for the parameter. The kwargs will be passed to the constructor, but the Parameters: Name Type Description Default typ None type of the new reference's target. None **kwargs None arguments to pass to the constructor. None match def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self Examples from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2} See Also matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching matches def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr. Examples from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c} n def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 normal def normal ( self ) Return the expression as a fraction. expression -> a/b See Also as_numer_denom: return (a, b) instead of a/b nseries def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries(). Examples from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y) nsimplify def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify powsimp def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify primitive def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float). Examples from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True radsimp def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify ratsimp def ratsimp ( self ) See the ratsimp function in sympy.simplify rcall def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z refine def refine ( self , assumption = True ) See the refine function in sympy.assumptions register_caller def register_caller ( self , caller : 'BaseStep' ) -> 'None' Capture a step that uses this parameter. Gathers together the steps using this parameter. The first found will be recorded as the tethered step, and used for forming the name. removeO def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one replace def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below: Examples Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1 See Also subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules rewrite def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten. Parameters args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True . Examples If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2) round def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number. Examples from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I Notes The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True separate def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify series def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised. Parameters expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated. Examples from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x Returns Expr : Expression Series expansion of the expression about x0 Raises TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object simplify def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify sort_key def sort_key ( self , order = None ) Return a sort key. Examples from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2] subs def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made. Examples from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained. See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision taylor_term def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\". to_nnf def to_nnf ( self , simplify = True ) together def together ( self , * args , ** kwargs ) See the together function in sympy.polys transpose def transpose ( self ) trigsimp def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify xreplace def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression. Parameters rule : dict-like Expresses a replacement rule Returns xreplace : the result of the replacement Examples from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),) See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves. ParameterReference class ParameterReference ( parameter : 'Parameter[U]' , * args : 'Any' , typ : 'type[U] | None' = None , ** kwargs : 'Any' ) Reference to an individual Parameter . Allows us to refer to the outputs of a Parameter in subsequent Parameter arguments. Attributes Name Type Description Default parameter None Parameter referred to. None workflow None Related workflow. In this case, as Parameters are generic but ParameterReferences are specific, this carries the actual workflow reference. None Ancestors (in MRO) dewret.workflow.FieldableMixin dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent Descendants dewret.workflow.IterableParameterReference Class variables ParameterReferenceMetadata default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol Static methods class_key def class_key ( ) Nice order of classes. fromiter def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first. Examples from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4) Instance variables args Returns a tuple of arguments of 'self'. Examples from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y Notes Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression. Examples from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args) Examples from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference. Methods adjoint def adjoint ( self ) apart def apart ( self , x = None , ** args ) See the apart function in sympy.polys args_cnc def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self. Explanation self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False. Examples from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []] as_base_exp def as_base_exp ( self ) -> 'tuple[Expr, Expr]' as_coeff_Add def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation. as_coeff_Mul def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product. as_coeff_add def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ()) as_coeff_exponent def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression. as_coeff_mul def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ()) as_coefficient def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None. Examples from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I) See Also coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used as_coefficients_dict def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned. Examples from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x} as_content_primitive def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self). Examples from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y) as_dummy def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned. Examples from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r Notes Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object. as_expr def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression. Examples from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x) as_independent def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True Examples -- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b)) See Also separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul as_leading_term def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value. Examples from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2) as_numer_denom def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else. See Also normal: return a/b instead of (a, b) as_ordered_factors def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self]. as_ordered_terms def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms. Examples from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1] as_poly def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None . Explanation from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None as_powers_dict def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary. See Also as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors. as_real_imag def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z)) as_set def as_set ( self ) Rewrites Boolean expression in terms of real sets. Examples from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo)) as_terms def as_terms ( self ) Transform an expression to a list of terms. aseries def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) . Parameters self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form. Examples from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x Returns Expr Asymptotic series expansion of the expression. Notes This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self . References .. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion See Also Expr.aseries: See the docstring of this function for complete details of this wrapper. atoms def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below. Examples from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)} cancel def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys coeff def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned. Explanation When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative. Examples from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1 See Also as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used collect def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify combsimp def combsimp ( self ) See the combsimp function in sympy.simplify compare def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned. Examples from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1 conjugate def conjugate ( self ) Returns the complex conjugate of 'self'. copy def copy ( self ) could_extract_minus_sign def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False. Examples from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True count def count ( self , query ) Count the number of matching subexpressions. count_ops def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count. diff def diff ( self , * symbols , ** assumptions ) dir def dir ( self , x , cdir ) doit def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x) dummy_eq def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols. Examples from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False equals def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None. Explanation If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False. evalf def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 expand def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information. extract_additively def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None. Examples from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3 See Also extract_multiplicatively coeff as_coefficient extract_branch_factor def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2) extract_multiplicatively def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self. Examples from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6 factor def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools find def find ( self , query , group = False ) Find all subexpressions matching a query. find_field def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference. fourier_series def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information. fps def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information. gammasimp def gammasimp ( self ) See the gammasimp function in sympy.simplify getO def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None. getn def getn ( self ) Returns the order of the expression. Explanation The order is determined either from the O(...) term. If there is no O(...) term, it returns None. Examples from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn() has def has ( self , * patterns ) Test whether any subexpression matches any of the patterns. Examples from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False has_free def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False. Examples from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True has_xfree def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches. Examples from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False integrate def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals invert def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions). See Also sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert is_algebraic_expr def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation. Examples from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True See Also is_rational_function References .. [1] https://en.wikipedia.org/wiki/Algebraic_expression is_constant def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively. Explanation If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing. Examples from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True is_hypergeometric def is_hypergeometric ( self , k ) is_meromorphic def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis. Examples from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False is_polynomial def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True). Examples from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function() is_rational_function def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True). Examples from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr(). is_same def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5). Examples In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False leadterm def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b). Examples from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2) limit def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim. lseries def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries(). match def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self Examples from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2} See Also matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching matches def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr. Examples from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c} n def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 normal def normal ( self ) Return the expression as a fraction. expression -> a/b See Also as_numer_denom: return (a, b) instead of a/b nseries def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries(). Examples from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y) nsimplify def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify powsimp def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify primitive def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float). Examples from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True radsimp def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify ratsimp def ratsimp ( self ) See the ratsimp function in sympy.simplify rcall def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z refine def refine ( self , assumption = True ) See the refine function in sympy.assumptions removeO def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one replace def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below: Examples Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1 See Also subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules rewrite def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten. Parameters args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True . Examples If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2) round def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number. Examples from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I Notes The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True separate def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify series def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised. Parameters expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated. Examples from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x Returns Expr : Expression Series expansion of the expression about x0 Raises TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object simplify def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify sort_key def sort_key ( self , order = None ) Return a sort key. Examples from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2] subs def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made. Examples from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained. See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision taylor_term def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\". to_nnf def to_nnf ( self , simplify = True ) together def together ( self , * args , ** kwargs ) See the together function in sympy.polys transpose def transpose ( self ) trigsimp def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify xreplace def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression. Parameters rule : dict-like Expresses a replacement rule Returns xreplace : the result of the replacement Examples from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),) See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves. Step class Step ( workflow : 'Workflow' , task : 'Task | Workflow' , arguments : 'Mapping[str, Reference[Any] | Raw]' , raw_as_parameter : 'bool' = False ) Regular step. Ancestors (in MRO) dewret.workflow.BaseStep dewret.core.WorkflowComponent Descendants dewret.workflow.FactoryCall Class variables positional_args Instance variables id Consistent ID based on the value. name Name for this step. May be remapped by the workflow to something nicer than the ID. return_type Take the type of the wrapped function from the target. Unwraps and inspects the signature, meaning that the original wrapped function must have a typehint for the return value. Methods make_reference def make_reference ( self , ** kwargs : 'Any' ) -> \"'StepReference[T]'\" Create a reference to this step. Builds a reference to the (result of) this step, which will be iterable if appropriate. Parameters: Name Type Description Default **kwargs None arguments for reference constructor, which will be supplemented appropriately. None set_workflow def set_workflow ( self , workflow : 'Workflow' , with_arguments : 'bool' = True ) -> 'None' Move the step reference to another workflow. This method is primarily intended to be called by a step, allowing it to switch to a new workflow. It also updates the workflow reference for any arguments that are steps themselves, if specified. Parameters: Name Type Description Default workflow None The new target workflow to which the step should be moved. None with_arguments None If True, also update the workflow reference for the step's arguments. None StepReference class StepReference ( step : 'BaseStep' , * args : 'Any' , typ : 'type[U] | None' = None , ** kwargs : 'Any' ) Reference to an individual Step . Allows us to refer to the outputs of a Step in subsequent Step arguments. Attributes Name Type Description Default _ None metadata wrapping the Step referred to. None Ancestors (in MRO) dewret.workflow.FieldableMixin dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent Descendants dewret.workflow.IterableStepReference Class variables StepReferenceMetadata default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol Static methods class_key def class_key ( ) Nice order of classes. fromiter def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first. Examples from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4) Instance variables args Returns a tuple of arguments of 'self'. Examples from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y Notes Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression. Examples from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args) Examples from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference. Methods adjoint def adjoint ( self ) apart def apart ( self , x = None , ** args ) See the apart function in sympy.polys args_cnc def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self. Explanation self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False. Examples from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []] as_base_exp def as_base_exp ( self ) -> 'tuple[Expr, Expr]' as_coeff_Add def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation. as_coeff_Mul def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product. as_coeff_add def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ()) as_coeff_exponent def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression. as_coeff_mul def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ()) as_coefficient def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None. Examples from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I) See Also coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used as_coefficients_dict def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned. Examples from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x} as_content_primitive def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self). Examples from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y) as_dummy def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned. Examples from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r Notes Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object. as_expr def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression. Examples from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x) as_independent def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True Examples -- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b)) See Also separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul as_leading_term def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value. Examples from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2) as_numer_denom def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else. See Also normal: return a/b instead of (a, b) as_ordered_factors def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self]. as_ordered_terms def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms. Examples from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1] as_poly def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None . Explanation from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None as_powers_dict def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary. See Also as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors. as_real_imag def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z)) as_set def as_set ( self ) Rewrites Boolean expression in terms of real sets. Examples from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo)) as_terms def as_terms ( self ) Transform an expression to a list of terms. aseries def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) . Parameters self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form. Examples from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x Returns Expr Asymptotic series expansion of the expression. Notes This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self . References .. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion See Also Expr.aseries: See the docstring of this function for complete details of this wrapper. atoms def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below. Examples from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)} cancel def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys coeff def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned. Explanation When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative. Examples from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1 See Also as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used collect def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify combsimp def combsimp ( self ) See the combsimp function in sympy.simplify compare def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned. Examples from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1 conjugate def conjugate ( self ) Returns the complex conjugate of 'self'. copy def copy ( self ) could_extract_minus_sign def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False. Examples from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True count def count ( self , query ) Count the number of matching subexpressions. count_ops def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count. diff def diff ( self , * symbols , ** assumptions ) dir def dir ( self , x , cdir ) doit def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x) dummy_eq def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols. Examples from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False equals def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None. Explanation If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False. evalf def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 expand def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information. extract_additively def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None. Examples from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3 See Also extract_multiplicatively coeff as_coefficient extract_branch_factor def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2) extract_multiplicatively def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self. Examples from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6 factor def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools find def find ( self , query , group = False ) Find all subexpressions matching a query. find_field def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference. fourier_series def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information. fps def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information. gammasimp def gammasimp ( self ) See the gammasimp function in sympy.simplify getO def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None. getn def getn ( self ) Returns the order of the expression. Explanation The order is determined either from the O(...) term. If there is no O(...) term, it returns None. Examples from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn() has def has ( self , * patterns ) Test whether any subexpression matches any of the patterns. Examples from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False has_free def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False. Examples from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True has_xfree def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches. Examples from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False integrate def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals invert def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions). See Also sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert is_algebraic_expr def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation. Examples from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True See Also is_rational_function References .. [1] https://en.wikipedia.org/wiki/Algebraic_expression is_constant def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively. Explanation If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing. Examples from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True is_hypergeometric def is_hypergeometric ( self , k ) is_meromorphic def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis. Examples from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False is_polynomial def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True). Examples from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function() is_rational_function def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True). Examples from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr(). is_same def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5). Examples In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False leadterm def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b). Examples from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2) limit def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim. lseries def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries(). match def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self Examples from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2} See Also matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching matches def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr. Examples from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c} n def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits. Parameters subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information. Notes When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000 normal def normal ( self ) Return the expression as a fraction. expression -> a/b See Also as_numer_denom: return (a, b) instead of a/b nseries def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries(). Examples from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y) nsimplify def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify powsimp def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify primitive def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float). Examples from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True radsimp def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify ratsimp def ratsimp ( self ) See the ratsimp function in sympy.simplify rcall def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z refine def refine ( self , assumption = True ) See the refine function in sympy.assumptions removeO def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one replace def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below: Examples Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1 See Also subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules rewrite def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten. Parameters args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True . Examples If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2) round def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number. Examples from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I Notes The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True separate def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify series def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised. Parameters expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated. Examples from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x Returns Expr : Expression Series expansion of the expression about x0 Raises TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object simplify def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify sort_key def sort_key ( self , order = None ) Return a sort key. Examples from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2] subs def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made. Examples from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained. See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision taylor_term def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\". to_nnf def to_nnf ( self , simplify = True ) together def together ( self , * args , ** kwargs ) See the together function in sympy.polys transpose def transpose ( self ) trigsimp def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify xreplace def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression. Parameters rule : dict-like Expresses a replacement rule Returns xreplace : the result of the replacement Examples from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),) See Also replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves. Task class Task ( name : 'str' , target : 'Lazy' ) Named wrapper of a lazy-evaluatable function. Wraps a lazy-evaluatable function ( dewret.workflow.Lazy ) with any metadata needed to render it later. At present, this is the name. Attributes Name Type Description Default name None Name of the lazy function as it will appear in the output workflow text. None target None Callable that is wrapped. None UnsetType class UnsetType ( raw_type : 'type[T]' ) Unset variable with a specific type. Attributes Name Type Description Default type None type of the variable. None Ancestors (in MRO) dewret.utils.Unset typing.Generic Workflow class Workflow ( name : 'str | None' = None ) Overarching workflow concept. Represents a whole workflow, as a singleton maintaining all state information needed ahead of rendering. It is built up as the lazy-evaluations are finally evaluated. Attributes Name Type Description Default steps None the sequence of calls to lazy-evaluable functions, built as they are evaluated. None tasks None the mapping of names used in the steps to the actual Task wrappers they represent. None result None target reference to evaluate, if yet present. None Static methods assimilate def assimilate ( * workflow_args : 'Workflow' ) -> \"'Workflow'\" Combine two Workflows into one Workflow. Takes two workflows and unifies them by combining steps and tasks. If it sees mismatched identifiers for the same component, it will error. This could happen if the hashing function is flawed or some Python magic to do with Targets being passed. Parameters: Name Type Description Default workflow_args None workflows to use as base None from_result def from_result ( result : 'StepReference[Any] | list[StepReference[Any]] | tuple[StepReference[Any], ...]' , simplify_ids : 'bool' = False , nested : 'bool' = True ) -> 'Workflow' Create from a desired result. Starts from a result, and builds a workflow to output it. Instance variables has_result Confirms whether this workflow has a non-empty result. Either None or an empty list/tuple are considered empty for this purpose. Returns: True if the workflow has a result, False otherwise. id Consistent ID based off the step IDs. indexed_steps Steps mapped by ID. Forces generation of IDs. Note that this effectively freezes the steps, so it should not be used until we are confident the steps are all ready to be hashed. name Get the name of the workflow. result_type Overall return type of this workflow. steps Get deduplicated steps. Returns: steps for looping over without duplicates. Methods add_nested_step def add_nested_step ( self , name : 'str' , subworkflow : 'Workflow' , return_type : 'type | None' , kwargs : 'dict[str, Any]' , positional_args : 'dict[str, bool] | None' = None ) -> 'StepReference[Any]' Append a nested step. Calls a subworkflow. Parameters: Name Type Description Default name None name of the subworkflow. None subworkflow None the subworkflow itself. None return_type None a forced type for the return, or None. None kwargs None any key-value arguments to pass in the call. None positional_args None a mapping of arguments to bools, True if the argument is positional or otherwise False. None add_step def add_step ( self , fn : 'Lazy' , kwargs : 'dict[str, Raw | Reference[Any]]' , raw_as_parameter : 'bool' = False , is_factory : 'bool' = False , positional_args : 'dict[str, bool] | None' = None ) -> 'StepReference[Any]' Append a step. Adds a step, for running a target with key-value arguments, to the workflow. Parameters: Name Type Description Default fn None the target function to turn into a step. None kwargs None any key-value arguments to pass in the call. None raw_as_parameter None whether to turn any discovered raw arguments into workflow parameters. None is_factory None whether this step should be a Factory. None positional_args None a mapping of arguments to bools, True if the argument is positional or otherwise False. None find_factories def find_factories ( self ) -> 'dict[str, FactoryCall]' Steps that are factory calls. find_parameters def find_parameters ( self , include_factory_calls : 'bool' = True ) -> 'set[Parameter[Any]]' Crawl steps for parameter references. As the workflow does not hold its own list of parameters, this dynamically finds them. Returns: Type Description None Set of all references to parameters across the steps. register_task def register_task ( self , fn : 'Lazy' ) -> 'Task' Note the existence of a lazy-evaluatable function, and wrap it as a Task . Parameters: Name Type Description Default fn None the wrapped function. None Returns: Type Description None A new Task that wraps the function, and is retained in the Workflow.tasks dict. remap def remap ( self , step_id : 'str' ) -> 'str' Apply name simplification if requested. Parameters: Name Type Description Default step_id None step to check. None Returns: Type Description None Same ID or a remapped name. set_result def set_result ( self , result : 'Basic | list[Basic] | tuple[Basic]' ) -> 'None' Choose the result step. Sets a step as being the result for the entire workflow. When we evaluate a dynamic workflow, the engine (e.g. dask) creates a graph to realize the result of a single collection. Similarly, in the static case, we need to have a result that drives the calculation. Parameters: Name Type Description Default result None reference to the chosen step. None simplify_ids def simplify_ids ( self , infix : 'list[str] | None' = None ) -> 'None' Work out mapping to simple ints from hashes. Goes through and numbers each step by the order of use of its task. WorkflowLinkedComponent class WorkflowLinkedComponent ( * args , ** kwargs ) Protocol for objects dynamically tied to a Workflow . Ancestors (in MRO) typing.Protocol typing.Generic","title":"Workflow"},{"location":"reference/dewret/workflow/#module-dewretworkflow","text":"Overarching workflow concepts. Basic constructs for describing a workflow.","title":"Module dewret.workflow"},{"location":"reference/dewret/workflow/#variables","text":"AVAILABLE_TYPES CHECK_IDS LazyFactory Param RetType StepExecution T TYPE_CHECKING Target U UNSET logger","title":"Variables"},{"location":"reference/dewret/workflow/#functions","text":"","title":"Functions"},{"location":"reference/dewret/workflow/#execute_step","text":"def execute_step ( task : 'Any' , ** kwargs : 'Any' ) -> 'Any' Evaluate a single task for a known workflow. Parameters: Name Type Description Default task None the task to evaluate. None **kwargs None any arguments to pass to the task. None","title":"execute_step"},{"location":"reference/dewret/workflow/#expr_to_references","text":"def expr_to_references ( expression : 'Any' , remap : 'Callable[[Any], Any] | None' = None ) -> 'tuple[ExprType, list[Reference[Any] | Parameter[Any]]]' Pull out any references, or other free symbols, from an expression. Parameters: Name Type Description Default expression None normally a reference that can be immediately returned, but may be a sympy expression or a dict/tuple/list/etc. of such. None remap None a callable to project certain values down before extracting symbols, or None. None","title":"expr_to_references"},{"location":"reference/dewret/workflow/#is_task","text":"def is_task ( task : 'Lazy' ) -> 'bool' Decide whether this is a task. Checks whether the wrapped function has the magic attribute __step_expression__ set to True, which is done within task creation. Parameters: Name Type Description Default task None lazy-evaluated value, suspected to be a task. None Returns: Type Description None True if task is indeed a task.","title":"is_task"},{"location":"reference/dewret/workflow/#param","text":"def param ( name : 'str' , default : 'T | UnsetType[T] | Unset' = < dewret . utils . Unset object at 0x7f2d6ea66910 > , tethered : 'Literal[False] | None | Step | Workflow' = False , typ : 'type[T] | Unset' = < dewret . utils . Unset object at 0x7f2d6ea66910 > , autoname : 'bool' = False ) -> 'T' Create a parameter. Will cast so it looks like the original type. Returns: Type Description None Parameter class cast to the type of the supplied default.","title":"param"},{"location":"reference/dewret/workflow/#unify_workflows","text":"def unify_workflows ( expression : 'Any' , base_workflow : 'Workflow | None' , set_only : 'bool' = False ) -> 'tuple[Basic | None, Workflow | None]' Takes an expression and ensures all of its references exist in the same workflow. Parameters: Name Type Description Default expression None any valid argument to dewret.workflow.expr_to_references . None base_workflow None the desired workflow to align on, or None. None set_only None whether to bother assimilating all the workflows (False), or to assume that has been done (False). None","title":"unify_workflows"},{"location":"reference/dewret/workflow/#classes","text":"","title":"Classes"},{"location":"reference/dewret/workflow/#basestep","text":"class BaseStep ( workflow : 'Workflow' , task : 'Task | Workflow' , arguments : 'Mapping[str, Reference[Any] | Raw]' , raw_as_parameter : 'bool' = False ) Lazy-evaluated function call. Individual function call to a lazy-evaluatable function, tracked for building up the Workflow .","title":"BaseStep"},{"location":"reference/dewret/workflow/#attributes","text":"Name Type Description Default task None the Task being called in this step. None arguments None key-value pairs of arguments to this step. None","title":"Attributes"},{"location":"reference/dewret/workflow/#ancestors-in-mro","text":"dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#descendants","text":"dewret.workflow.NestedStep dewret.workflow.Step","title":"Descendants"},{"location":"reference/dewret/workflow/#class-variables","text":"positional_args","title":"Class variables"},{"location":"reference/dewret/workflow/#instance-variables","text":"id Consistent ID based on the value. name Name for this step. May be remapped by the workflow to something nicer than the ID. return_type Take the type of the wrapped function from the target. Unwraps and inspects the signature, meaning that the original wrapped function must have a typehint for the return value.","title":"Instance variables"},{"location":"reference/dewret/workflow/#methods","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#make_reference","text":"def make_reference ( self , ** kwargs : 'Any' ) -> \"'StepReference[T]'\" Create a reference to this step. Builds a reference to the (result of) this step, which will be iterable if appropriate. Parameters: Name Type Description Default **kwargs None arguments for reference constructor, which will be supplemented appropriately. None","title":"make_reference"},{"location":"reference/dewret/workflow/#set_workflow","text":"def set_workflow ( self , workflow : 'Workflow' , with_arguments : 'bool' = True ) -> 'None' Move the step reference to another workflow. This method is primarily intended to be called by a step, allowing it to switch to a new workflow. It also updates the workflow reference for any arguments that are steps themselves, if specified. Parameters: Name Type Description Default workflow None The new target workflow to which the step should be moved. None with_arguments None If True, also update the workflow reference for the step's arguments. None","title":"set_workflow"},{"location":"reference/dewret/workflow/#factorycall","text":"class FactoryCall ( workflow : 'Workflow' , task : 'Task | Workflow' , arguments : 'Mapping[str, Reference[Any] | Raw]' , raw_as_parameter : 'bool' = False ) Call to a factory function.","title":"FactoryCall"},{"location":"reference/dewret/workflow/#ancestors-in-mro_1","text":"dewret.workflow.Step dewret.workflow.BaseStep dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#class-variables_1","text":"positional_args","title":"Class variables"},{"location":"reference/dewret/workflow/#instance-variables_1","text":"id Consistent ID based on the value. name Name for this step. May be remapped by the workflow to something nicer than the ID. return_type Take the type of the wrapped function from the target. Unwraps and inspects the signature, meaning that the original wrapped function must have a typehint for the return value.","title":"Instance variables"},{"location":"reference/dewret/workflow/#methods_1","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#make_reference_1","text":"def make_reference ( self , ** kwargs : 'Any' ) -> \"'StepReference[T]'\" Create a reference to this step. Builds a reference to the (result of) this step, which will be iterable if appropriate. Parameters: Name Type Description Default **kwargs None arguments for reference constructor, which will be supplemented appropriately. None","title":"make_reference"},{"location":"reference/dewret/workflow/#set_workflow_1","text":"def set_workflow ( self , workflow : 'Workflow' , with_arguments : 'bool' = True ) -> 'None' Move the step reference to another workflow. This method is primarily intended to be called by a step, allowing it to switch to a new workflow. It also updates the workflow reference for any arguments that are steps themselves, if specified. Parameters: Name Type Description Default workflow None The new target workflow to which the step should be moved. None with_arguments None If True, also update the workflow reference for the step's arguments. None","title":"set_workflow"},{"location":"reference/dewret/workflow/#fieldablemixin","text":"class FieldableMixin ( self : 'FieldableProtocol' , * args : 'Any' , field : 'str | int | tuple[str | int, ...] | None' = None , ** kwargs : 'Any' ) Tooling for enhancing a type with referenceable fields.","title":"FieldableMixin"},{"location":"reference/dewret/workflow/#descendants_1","text":"dewret.workflow.ParameterReference dewret.workflow.StepReference","title":"Descendants"},{"location":"reference/dewret/workflow/#methods_2","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#find_field","text":"def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference.","title":"find_field"},{"location":"reference/dewret/workflow/#fieldableprotocol","text":"class FieldableProtocol ( * args : 'Any' , field : 'str | None' = None , ** kwargs : 'Any' ) Expected interfaces for a type that can take fields.","title":"FieldableProtocol"},{"location":"reference/dewret/workflow/#attributes_1","text":"Name Type Description Default field None tuple representing the named fields, either strings or integers. None","title":"Attributes"},{"location":"reference/dewret/workflow/#ancestors-in-mro_2","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#instance-variables_2","text":"name The name for the target, accounting for the field.","title":"Instance variables"},{"location":"reference/dewret/workflow/#iterableparameterreference","text":"class IterableParameterReference ( typ : type [ ~ U ] | None = None , ** kwargs : Any ) Iterable form of parameter references.","title":"IterableParameterReference"},{"location":"reference/dewret/workflow/#ancestors-in-mro_3","text":"dewret.core.IterableMixin dewret.workflow.ParameterReference dewret.workflow.FieldableMixin dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#class-variables_2","text":"ParameterReferenceMetadata default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol","title":"Class variables"},{"location":"reference/dewret/workflow/#static-methods","text":"","title":"Static methods"},{"location":"reference/dewret/workflow/#class_key","text":"def class_key ( ) Nice order of classes.","title":"class_key"},{"location":"reference/dewret/workflow/#fromiter","text":"def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first.","title":"fromiter"},{"location":"reference/dewret/workflow/#examples","text":"from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4)","title":"Examples"},{"location":"reference/dewret/workflow/#instance-variables_3","text":"args Returns a tuple of arguments of 'self'.","title":"Instance variables"},{"location":"reference/dewret/workflow/#examples_1","text":"from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y","title":"Examples"},{"location":"reference/dewret/workflow/#notes","text":"Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression.","title":"Notes"},{"location":"reference/dewret/workflow/#examples_2","text":"from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args)","title":"Examples"},{"location":"reference/dewret/workflow/#examples_3","text":"from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference.","title":"Examples"},{"location":"reference/dewret/workflow/#methods_3","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#adjoint","text":"def adjoint ( self )","title":"adjoint"},{"location":"reference/dewret/workflow/#apart","text":"def apart ( self , x = None , ** args ) See the apart function in sympy.polys","title":"apart"},{"location":"reference/dewret/workflow/#args_cnc","text":"def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self.","title":"args_cnc"},{"location":"reference/dewret/workflow/#explanation","text":"self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_4","text":"from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []]","title":"Examples"},{"location":"reference/dewret/workflow/#as_base_exp","text":"def as_base_exp ( self ) -> 'tuple[Expr, Expr]'","title":"as_base_exp"},{"location":"reference/dewret/workflow/#as_coeff_add","text":"def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation.","title":"as_coeff_Add"},{"location":"reference/dewret/workflow/#as_coeff_mul","text":"def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product.","title":"as_coeff_Mul"},{"location":"reference/dewret/workflow/#as_coeff_add_1","text":"def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ())","title":"as_coeff_add"},{"location":"reference/dewret/workflow/#as_coeff_exponent","text":"def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression.","title":"as_coeff_exponent"},{"location":"reference/dewret/workflow/#as_coeff_mul_1","text":"def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ())","title":"as_coeff_mul"},{"location":"reference/dewret/workflow/#as_coefficient","text":"def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None.","title":"as_coefficient"},{"location":"reference/dewret/workflow/#examples_5","text":"from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also","text":"coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#as_coefficients_dict","text":"def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned.","title":"as_coefficients_dict"},{"location":"reference/dewret/workflow/#examples_6","text":"from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x}","title":"Examples"},{"location":"reference/dewret/workflow/#as_content_primitive","text":"def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self).","title":"as_content_primitive"},{"location":"reference/dewret/workflow/#examples_7","text":"from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y)","title":"Examples"},{"location":"reference/dewret/workflow/#as_dummy","text":"def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned.","title":"as_dummy"},{"location":"reference/dewret/workflow/#examples_8","text":"from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r","title":"Examples"},{"location":"reference/dewret/workflow/#notes_1","text":"Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object.","title":"Notes"},{"location":"reference/dewret/workflow/#as_expr","text":"def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression.","title":"as_expr"},{"location":"reference/dewret/workflow/#examples_9","text":"from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x)","title":"Examples"},{"location":"reference/dewret/workflow/#as_independent","text":"def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True","title":"as_independent"},{"location":"reference/dewret/workflow/#examples_10","text":"-- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b))","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_1","text":"separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul","title":"See Also"},{"location":"reference/dewret/workflow/#as_leading_term","text":"def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value.","title":"as_leading_term"},{"location":"reference/dewret/workflow/#examples_11","text":"from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2)","title":"Examples"},{"location":"reference/dewret/workflow/#as_numer_denom","text":"def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else.","title":"as_numer_denom"},{"location":"reference/dewret/workflow/#see-also_2","text":"normal: return a/b instead of (a, b)","title":"See Also"},{"location":"reference/dewret/workflow/#as_ordered_factors","text":"def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self].","title":"as_ordered_factors"},{"location":"reference/dewret/workflow/#as_ordered_terms","text":"def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms.","title":"as_ordered_terms"},{"location":"reference/dewret/workflow/#examples_12","text":"from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1]","title":"Examples"},{"location":"reference/dewret/workflow/#as_poly","text":"def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None .","title":"as_poly"},{"location":"reference/dewret/workflow/#explanation_1","text":"from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None","title":"Explanation"},{"location":"reference/dewret/workflow/#as_powers_dict","text":"def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary.","title":"as_powers_dict"},{"location":"reference/dewret/workflow/#see-also_3","text":"as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.","title":"See Also"},{"location":"reference/dewret/workflow/#as_real_imag","text":"def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z))","title":"as_real_imag"},{"location":"reference/dewret/workflow/#as_set","text":"def as_set ( self ) Rewrites Boolean expression in terms of real sets.","title":"as_set"},{"location":"reference/dewret/workflow/#examples_13","text":"from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo))","title":"Examples"},{"location":"reference/dewret/workflow/#as_terms","text":"def as_terms ( self ) Transform an expression to a list of terms.","title":"as_terms"},{"location":"reference/dewret/workflow/#aseries","text":"def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) .","title":"aseries"},{"location":"reference/dewret/workflow/#parameters","text":"self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_14","text":"from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns","text":"Expr Asymptotic series expansion of the expression.","title":"Returns"},{"location":"reference/dewret/workflow/#notes_2","text":"This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self .","title":"Notes"},{"location":"reference/dewret/workflow/#references","text":".. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion","title":"References"},{"location":"reference/dewret/workflow/#see-also_4","text":"Expr.aseries: See the docstring of this function for complete details of this wrapper.","title":"See Also"},{"location":"reference/dewret/workflow/#atoms","text":"def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below.","title":"atoms"},{"location":"reference/dewret/workflow/#examples_15","text":"from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)}","title":"Examples"},{"location":"reference/dewret/workflow/#cancel","text":"def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys","title":"cancel"},{"location":"reference/dewret/workflow/#coeff","text":"def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned.","title":"coeff"},{"location":"reference/dewret/workflow/#explanation_2","text":"When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_16","text":"from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_5","text":"as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#collect","text":"def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify","title":"collect"},{"location":"reference/dewret/workflow/#combsimp","text":"def combsimp ( self ) See the combsimp function in sympy.simplify","title":"combsimp"},{"location":"reference/dewret/workflow/#compare","text":"def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned.","title":"compare"},{"location":"reference/dewret/workflow/#examples_17","text":"from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1","title":"Examples"},{"location":"reference/dewret/workflow/#conjugate","text":"def conjugate ( self ) Returns the complex conjugate of 'self'.","title":"conjugate"},{"location":"reference/dewret/workflow/#copy","text":"def copy ( self )","title":"copy"},{"location":"reference/dewret/workflow/#could_extract_minus_sign","text":"def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False.","title":"could_extract_minus_sign"},{"location":"reference/dewret/workflow/#examples_18","text":"from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True","title":"Examples"},{"location":"reference/dewret/workflow/#count","text":"def count ( self , query ) Count the number of matching subexpressions.","title":"count"},{"location":"reference/dewret/workflow/#count_ops","text":"def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count.","title":"count_ops"},{"location":"reference/dewret/workflow/#diff","text":"def diff ( self , * symbols , ** assumptions )","title":"diff"},{"location":"reference/dewret/workflow/#dir","text":"def dir ( self , x , cdir )","title":"dir"},{"location":"reference/dewret/workflow/#doit","text":"def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x)","title":"doit"},{"location":"reference/dewret/workflow/#dummy_eq","text":"def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols.","title":"dummy_eq"},{"location":"reference/dewret/workflow/#examples_19","text":"from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False","title":"Examples"},{"location":"reference/dewret/workflow/#equals","text":"def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None.","title":"equals"},{"location":"reference/dewret/workflow/#explanation_3","text":"If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False.","title":"Explanation"},{"location":"reference/dewret/workflow/#evalf","text":"def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"evalf"},{"location":"reference/dewret/workflow/#parameters_1","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_3","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#expand","text":"def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information.","title":"expand"},{"location":"reference/dewret/workflow/#extract_additively","text":"def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None.","title":"extract_additively"},{"location":"reference/dewret/workflow/#examples_20","text":"from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_6","text":"extract_multiplicatively coeff as_coefficient","title":"See Also"},{"location":"reference/dewret/workflow/#extract_branch_factor","text":"def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2)","title":"extract_branch_factor"},{"location":"reference/dewret/workflow/#extract_multiplicatively","text":"def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self.","title":"extract_multiplicatively"},{"location":"reference/dewret/workflow/#examples_21","text":"from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6","title":"Examples"},{"location":"reference/dewret/workflow/#factor","text":"def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools","title":"factor"},{"location":"reference/dewret/workflow/#find","text":"def find ( self , query , group = False ) Find all subexpressions matching a query.","title":"find"},{"location":"reference/dewret/workflow/#find_field_1","text":"def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference.","title":"find_field"},{"location":"reference/dewret/workflow/#fourier_series","text":"def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information.","title":"fourier_series"},{"location":"reference/dewret/workflow/#fps","text":"def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information.","title":"fps"},{"location":"reference/dewret/workflow/#gammasimp","text":"def gammasimp ( self ) See the gammasimp function in sympy.simplify","title":"gammasimp"},{"location":"reference/dewret/workflow/#geto","text":"def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None.","title":"getO"},{"location":"reference/dewret/workflow/#getn","text":"def getn ( self ) Returns the order of the expression.","title":"getn"},{"location":"reference/dewret/workflow/#explanation_4","text":"The order is determined either from the O(...) term. If there is no O(...) term, it returns None.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_22","text":"from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn()","title":"Examples"},{"location":"reference/dewret/workflow/#has","text":"def has ( self , * patterns ) Test whether any subexpression matches any of the patterns.","title":"has"},{"location":"reference/dewret/workflow/#examples_23","text":"from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False","title":"Examples"},{"location":"reference/dewret/workflow/#has_free","text":"def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False.","title":"has_free"},{"location":"reference/dewret/workflow/#examples_24","text":"from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True","title":"Examples"},{"location":"reference/dewret/workflow/#has_xfree","text":"def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches.","title":"has_xfree"},{"location":"reference/dewret/workflow/#examples_25","text":"from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False","title":"Examples"},{"location":"reference/dewret/workflow/#integrate","text":"def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals","title":"integrate"},{"location":"reference/dewret/workflow/#invert","text":"def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions).","title":"invert"},{"location":"reference/dewret/workflow/#see-also_7","text":"sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert","title":"See Also"},{"location":"reference/dewret/workflow/#is_algebraic_expr","text":"def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation.","title":"is_algebraic_expr"},{"location":"reference/dewret/workflow/#examples_26","text":"from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_8","text":"is_rational_function","title":"See Also"},{"location":"reference/dewret/workflow/#references_1","text":".. [1] https://en.wikipedia.org/wiki/Algebraic_expression","title":"References"},{"location":"reference/dewret/workflow/#is_constant","text":"def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively.","title":"is_constant"},{"location":"reference/dewret/workflow/#explanation_5","text":"If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_27","text":"from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True","title":"Examples"},{"location":"reference/dewret/workflow/#is_hypergeometric","text":"def is_hypergeometric ( self , k )","title":"is_hypergeometric"},{"location":"reference/dewret/workflow/#is_meromorphic","text":"def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis.","title":"is_meromorphic"},{"location":"reference/dewret/workflow/#examples_28","text":"from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False","title":"Examples"},{"location":"reference/dewret/workflow/#is_polynomial","text":"def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True).","title":"is_polynomial"},{"location":"reference/dewret/workflow/#examples_29","text":"from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function()","title":"Examples"},{"location":"reference/dewret/workflow/#is_rational_function","text":"def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True).","title":"is_rational_function"},{"location":"reference/dewret/workflow/#examples_30","text":"from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr().","title":"Examples"},{"location":"reference/dewret/workflow/#is_same","text":"def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).","title":"is_same"},{"location":"reference/dewret/workflow/#examples_31","text":"In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False","title":"Examples"},{"location":"reference/dewret/workflow/#leadterm","text":"def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b).","title":"leadterm"},{"location":"reference/dewret/workflow/#examples_32","text":"from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2)","title":"Examples"},{"location":"reference/dewret/workflow/#limit","text":"def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim.","title":"limit"},{"location":"reference/dewret/workflow/#lseries","text":"def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries().","title":"lseries"},{"location":"reference/dewret/workflow/#match","text":"def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self","title":"match"},{"location":"reference/dewret/workflow/#examples_33","text":"from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2}","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_9","text":"matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching","title":"See Also"},{"location":"reference/dewret/workflow/#matches","text":"def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr.","title":"matches"},{"location":"reference/dewret/workflow/#examples_34","text":"from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c}","title":"Examples"},{"location":"reference/dewret/workflow/#n","text":"def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"n"},{"location":"reference/dewret/workflow/#parameters_2","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_4","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#normal","text":"def normal ( self ) Return the expression as a fraction. expression -> a/b","title":"normal"},{"location":"reference/dewret/workflow/#see-also_10","text":"as_numer_denom: return (a, b) instead of a/b","title":"See Also"},{"location":"reference/dewret/workflow/#nseries","text":"def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries().","title":"nseries"},{"location":"reference/dewret/workflow/#examples_35","text":"from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y)","title":"Examples"},{"location":"reference/dewret/workflow/#nsimplify","text":"def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify","title":"nsimplify"},{"location":"reference/dewret/workflow/#powsimp","text":"def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify","title":"powsimp"},{"location":"reference/dewret/workflow/#primitive","text":"def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float).","title":"primitive"},{"location":"reference/dewret/workflow/#examples_36","text":"from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True","title":"Examples"},{"location":"reference/dewret/workflow/#radsimp","text":"def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify","title":"radsimp"},{"location":"reference/dewret/workflow/#ratsimp","text":"def ratsimp ( self ) See the ratsimp function in sympy.simplify","title":"ratsimp"},{"location":"reference/dewret/workflow/#rcall","text":"def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z","title":"rcall"},{"location":"reference/dewret/workflow/#refine","text":"def refine ( self , assumption = True ) See the refine function in sympy.assumptions","title":"refine"},{"location":"reference/dewret/workflow/#removeo","text":"def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one","title":"removeO"},{"location":"reference/dewret/workflow/#replace","text":"def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below:","title":"replace"},{"location":"reference/dewret/workflow/#examples_37","text":"Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_11","text":"subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules","title":"See Also"},{"location":"reference/dewret/workflow/#rewrite","text":"def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten.","title":"rewrite"},{"location":"reference/dewret/workflow/#parameters_3","text":"args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True .","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_38","text":"If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2)","title":"Examples"},{"location":"reference/dewret/workflow/#round","text":"def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number.","title":"round"},{"location":"reference/dewret/workflow/#examples_39","text":"from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I","title":"Examples"},{"location":"reference/dewret/workflow/#notes_5","text":"The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True","title":"Notes"},{"location":"reference/dewret/workflow/#separate","text":"def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify","title":"separate"},{"location":"reference/dewret/workflow/#series","text":"def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised.","title":"series"},{"location":"reference/dewret/workflow/#parameters_4","text":"expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_40","text":"from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_1","text":"Expr : Expression Series expansion of the expression about x0","title":"Returns"},{"location":"reference/dewret/workflow/#raises","text":"TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object","title":"Raises"},{"location":"reference/dewret/workflow/#simplify","text":"def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify","title":"simplify"},{"location":"reference/dewret/workflow/#sort_key","text":"def sort_key ( self , order = None ) Return a sort key.","title":"sort_key"},{"location":"reference/dewret/workflow/#examples_41","text":"from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2]","title":"Examples"},{"location":"reference/dewret/workflow/#subs","text":"def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made.","title":"subs"},{"location":"reference/dewret/workflow/#examples_42","text":"from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained.","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_12","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision","title":"See Also"},{"location":"reference/dewret/workflow/#taylor_term","text":"def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\".","title":"taylor_term"},{"location":"reference/dewret/workflow/#to_nnf","text":"def to_nnf ( self , simplify = True )","title":"to_nnf"},{"location":"reference/dewret/workflow/#together","text":"def together ( self , * args , ** kwargs ) See the together function in sympy.polys","title":"together"},{"location":"reference/dewret/workflow/#transpose","text":"def transpose ( self )","title":"transpose"},{"location":"reference/dewret/workflow/#trigsimp","text":"def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify","title":"trigsimp"},{"location":"reference/dewret/workflow/#xreplace","text":"def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression.","title":"xreplace"},{"location":"reference/dewret/workflow/#parameters_5","text":"rule : dict-like Expresses a replacement rule","title":"Parameters"},{"location":"reference/dewret/workflow/#returns_2","text":"xreplace : the result of the replacement","title":"Returns"},{"location":"reference/dewret/workflow/#examples_43","text":"from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_13","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves.","title":"See Also"},{"location":"reference/dewret/workflow/#iterablestepreference","text":"class IterableStepReference ( typ : type [ ~ U ] | None = None , ** kwargs : Any ) Iterable form of a step reference.","title":"IterableStepReference"},{"location":"reference/dewret/workflow/#ancestors-in-mro_4","text":"dewret.core.IterableMixin dewret.workflow.StepReference dewret.workflow.FieldableMixin dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#class-variables_3","text":"StepReferenceMetadata default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol","title":"Class variables"},{"location":"reference/dewret/workflow/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/dewret/workflow/#class_key_1","text":"def class_key ( ) Nice order of classes.","title":"class_key"},{"location":"reference/dewret/workflow/#fromiter_1","text":"def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first.","title":"fromiter"},{"location":"reference/dewret/workflow/#examples_44","text":"from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4)","title":"Examples"},{"location":"reference/dewret/workflow/#instance-variables_4","text":"args Returns a tuple of arguments of 'self'.","title":"Instance variables"},{"location":"reference/dewret/workflow/#examples_45","text":"from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y","title":"Examples"},{"location":"reference/dewret/workflow/#notes_6","text":"Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression.","title":"Notes"},{"location":"reference/dewret/workflow/#examples_46","text":"from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args)","title":"Examples"},{"location":"reference/dewret/workflow/#examples_47","text":"from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference.","title":"Examples"},{"location":"reference/dewret/workflow/#methods_4","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#adjoint_1","text":"def adjoint ( self )","title":"adjoint"},{"location":"reference/dewret/workflow/#apart_1","text":"def apart ( self , x = None , ** args ) See the apart function in sympy.polys","title":"apart"},{"location":"reference/dewret/workflow/#args_cnc_1","text":"def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self.","title":"args_cnc"},{"location":"reference/dewret/workflow/#explanation_6","text":"self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_48","text":"from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []]","title":"Examples"},{"location":"reference/dewret/workflow/#as_base_exp_1","text":"def as_base_exp ( self ) -> 'tuple[Expr, Expr]'","title":"as_base_exp"},{"location":"reference/dewret/workflow/#as_coeff_add_2","text":"def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation.","title":"as_coeff_Add"},{"location":"reference/dewret/workflow/#as_coeff_mul_2","text":"def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product.","title":"as_coeff_Mul"},{"location":"reference/dewret/workflow/#as_coeff_add_3","text":"def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ())","title":"as_coeff_add"},{"location":"reference/dewret/workflow/#as_coeff_exponent_1","text":"def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression.","title":"as_coeff_exponent"},{"location":"reference/dewret/workflow/#as_coeff_mul_3","text":"def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ())","title":"as_coeff_mul"},{"location":"reference/dewret/workflow/#as_coefficient_1","text":"def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None.","title":"as_coefficient"},{"location":"reference/dewret/workflow/#examples_49","text":"from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_14","text":"coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#as_coefficients_dict_1","text":"def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned.","title":"as_coefficients_dict"},{"location":"reference/dewret/workflow/#examples_50","text":"from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x}","title":"Examples"},{"location":"reference/dewret/workflow/#as_content_primitive_1","text":"def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self).","title":"as_content_primitive"},{"location":"reference/dewret/workflow/#examples_51","text":"from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y)","title":"Examples"},{"location":"reference/dewret/workflow/#as_dummy_1","text":"def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned.","title":"as_dummy"},{"location":"reference/dewret/workflow/#examples_52","text":"from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r","title":"Examples"},{"location":"reference/dewret/workflow/#notes_7","text":"Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object.","title":"Notes"},{"location":"reference/dewret/workflow/#as_expr_1","text":"def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression.","title":"as_expr"},{"location":"reference/dewret/workflow/#examples_53","text":"from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x)","title":"Examples"},{"location":"reference/dewret/workflow/#as_independent_1","text":"def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True","title":"as_independent"},{"location":"reference/dewret/workflow/#examples_54","text":"-- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b))","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_15","text":"separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul","title":"See Also"},{"location":"reference/dewret/workflow/#as_leading_term_1","text":"def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value.","title":"as_leading_term"},{"location":"reference/dewret/workflow/#examples_55","text":"from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2)","title":"Examples"},{"location":"reference/dewret/workflow/#as_numer_denom_1","text":"def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else.","title":"as_numer_denom"},{"location":"reference/dewret/workflow/#see-also_16","text":"normal: return a/b instead of (a, b)","title":"See Also"},{"location":"reference/dewret/workflow/#as_ordered_factors_1","text":"def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self].","title":"as_ordered_factors"},{"location":"reference/dewret/workflow/#as_ordered_terms_1","text":"def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms.","title":"as_ordered_terms"},{"location":"reference/dewret/workflow/#examples_56","text":"from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1]","title":"Examples"},{"location":"reference/dewret/workflow/#as_poly_1","text":"def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None .","title":"as_poly"},{"location":"reference/dewret/workflow/#explanation_7","text":"from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None","title":"Explanation"},{"location":"reference/dewret/workflow/#as_powers_dict_1","text":"def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary.","title":"as_powers_dict"},{"location":"reference/dewret/workflow/#see-also_17","text":"as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.","title":"See Also"},{"location":"reference/dewret/workflow/#as_real_imag_1","text":"def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z))","title":"as_real_imag"},{"location":"reference/dewret/workflow/#as_set_1","text":"def as_set ( self ) Rewrites Boolean expression in terms of real sets.","title":"as_set"},{"location":"reference/dewret/workflow/#examples_57","text":"from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo))","title":"Examples"},{"location":"reference/dewret/workflow/#as_terms_1","text":"def as_terms ( self ) Transform an expression to a list of terms.","title":"as_terms"},{"location":"reference/dewret/workflow/#aseries_1","text":"def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) .","title":"aseries"},{"location":"reference/dewret/workflow/#parameters_6","text":"self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_58","text":"from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_3","text":"Expr Asymptotic series expansion of the expression.","title":"Returns"},{"location":"reference/dewret/workflow/#notes_8","text":"This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self .","title":"Notes"},{"location":"reference/dewret/workflow/#references_2","text":".. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion","title":"References"},{"location":"reference/dewret/workflow/#see-also_18","text":"Expr.aseries: See the docstring of this function for complete details of this wrapper.","title":"See Also"},{"location":"reference/dewret/workflow/#atoms_1","text":"def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below.","title":"atoms"},{"location":"reference/dewret/workflow/#examples_59","text":"from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)}","title":"Examples"},{"location":"reference/dewret/workflow/#cancel_1","text":"def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys","title":"cancel"},{"location":"reference/dewret/workflow/#coeff_1","text":"def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned.","title":"coeff"},{"location":"reference/dewret/workflow/#explanation_8","text":"When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_60","text":"from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_19","text":"as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#collect_1","text":"def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify","title":"collect"},{"location":"reference/dewret/workflow/#combsimp_1","text":"def combsimp ( self ) See the combsimp function in sympy.simplify","title":"combsimp"},{"location":"reference/dewret/workflow/#compare_1","text":"def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned.","title":"compare"},{"location":"reference/dewret/workflow/#examples_61","text":"from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1","title":"Examples"},{"location":"reference/dewret/workflow/#conjugate_1","text":"def conjugate ( self ) Returns the complex conjugate of 'self'.","title":"conjugate"},{"location":"reference/dewret/workflow/#copy_1","text":"def copy ( self )","title":"copy"},{"location":"reference/dewret/workflow/#could_extract_minus_sign_1","text":"def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False.","title":"could_extract_minus_sign"},{"location":"reference/dewret/workflow/#examples_62","text":"from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True","title":"Examples"},{"location":"reference/dewret/workflow/#count_1","text":"def count ( self , query ) Count the number of matching subexpressions.","title":"count"},{"location":"reference/dewret/workflow/#count_ops_1","text":"def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count.","title":"count_ops"},{"location":"reference/dewret/workflow/#diff_1","text":"def diff ( self , * symbols , ** assumptions )","title":"diff"},{"location":"reference/dewret/workflow/#dir_1","text":"def dir ( self , x , cdir )","title":"dir"},{"location":"reference/dewret/workflow/#doit_1","text":"def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x)","title":"doit"},{"location":"reference/dewret/workflow/#dummy_eq_1","text":"def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols.","title":"dummy_eq"},{"location":"reference/dewret/workflow/#examples_63","text":"from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False","title":"Examples"},{"location":"reference/dewret/workflow/#equals_1","text":"def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None.","title":"equals"},{"location":"reference/dewret/workflow/#explanation_9","text":"If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False.","title":"Explanation"},{"location":"reference/dewret/workflow/#evalf_1","text":"def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"evalf"},{"location":"reference/dewret/workflow/#parameters_7","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_9","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#expand_1","text":"def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information.","title":"expand"},{"location":"reference/dewret/workflow/#extract_additively_1","text":"def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None.","title":"extract_additively"},{"location":"reference/dewret/workflow/#examples_64","text":"from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_20","text":"extract_multiplicatively coeff as_coefficient","title":"See Also"},{"location":"reference/dewret/workflow/#extract_branch_factor_1","text":"def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2)","title":"extract_branch_factor"},{"location":"reference/dewret/workflow/#extract_multiplicatively_1","text":"def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self.","title":"extract_multiplicatively"},{"location":"reference/dewret/workflow/#examples_65","text":"from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6","title":"Examples"},{"location":"reference/dewret/workflow/#factor_1","text":"def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools","title":"factor"},{"location":"reference/dewret/workflow/#find_1","text":"def find ( self , query , group = False ) Find all subexpressions matching a query.","title":"find"},{"location":"reference/dewret/workflow/#find_field_2","text":"def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference.","title":"find_field"},{"location":"reference/dewret/workflow/#fourier_series_1","text":"def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information.","title":"fourier_series"},{"location":"reference/dewret/workflow/#fps_1","text":"def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information.","title":"fps"},{"location":"reference/dewret/workflow/#gammasimp_1","text":"def gammasimp ( self ) See the gammasimp function in sympy.simplify","title":"gammasimp"},{"location":"reference/dewret/workflow/#geto_1","text":"def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None.","title":"getO"},{"location":"reference/dewret/workflow/#getn_1","text":"def getn ( self ) Returns the order of the expression.","title":"getn"},{"location":"reference/dewret/workflow/#explanation_10","text":"The order is determined either from the O(...) term. If there is no O(...) term, it returns None.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_66","text":"from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn()","title":"Examples"},{"location":"reference/dewret/workflow/#has_1","text":"def has ( self , * patterns ) Test whether any subexpression matches any of the patterns.","title":"has"},{"location":"reference/dewret/workflow/#examples_67","text":"from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False","title":"Examples"},{"location":"reference/dewret/workflow/#has_free_1","text":"def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False.","title":"has_free"},{"location":"reference/dewret/workflow/#examples_68","text":"from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True","title":"Examples"},{"location":"reference/dewret/workflow/#has_xfree_1","text":"def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches.","title":"has_xfree"},{"location":"reference/dewret/workflow/#examples_69","text":"from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False","title":"Examples"},{"location":"reference/dewret/workflow/#integrate_1","text":"def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals","title":"integrate"},{"location":"reference/dewret/workflow/#invert_1","text":"def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions).","title":"invert"},{"location":"reference/dewret/workflow/#see-also_21","text":"sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert","title":"See Also"},{"location":"reference/dewret/workflow/#is_algebraic_expr_1","text":"def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation.","title":"is_algebraic_expr"},{"location":"reference/dewret/workflow/#examples_70","text":"from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_22","text":"is_rational_function","title":"See Also"},{"location":"reference/dewret/workflow/#references_3","text":".. [1] https://en.wikipedia.org/wiki/Algebraic_expression","title":"References"},{"location":"reference/dewret/workflow/#is_constant_1","text":"def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively.","title":"is_constant"},{"location":"reference/dewret/workflow/#explanation_11","text":"If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_71","text":"from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True","title":"Examples"},{"location":"reference/dewret/workflow/#is_hypergeometric_1","text":"def is_hypergeometric ( self , k )","title":"is_hypergeometric"},{"location":"reference/dewret/workflow/#is_meromorphic_1","text":"def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis.","title":"is_meromorphic"},{"location":"reference/dewret/workflow/#examples_72","text":"from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False","title":"Examples"},{"location":"reference/dewret/workflow/#is_polynomial_1","text":"def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True).","title":"is_polynomial"},{"location":"reference/dewret/workflow/#examples_73","text":"from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function()","title":"Examples"},{"location":"reference/dewret/workflow/#is_rational_function_1","text":"def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True).","title":"is_rational_function"},{"location":"reference/dewret/workflow/#examples_74","text":"from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr().","title":"Examples"},{"location":"reference/dewret/workflow/#is_same_1","text":"def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).","title":"is_same"},{"location":"reference/dewret/workflow/#examples_75","text":"In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False","title":"Examples"},{"location":"reference/dewret/workflow/#leadterm_1","text":"def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b).","title":"leadterm"},{"location":"reference/dewret/workflow/#examples_76","text":"from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2)","title":"Examples"},{"location":"reference/dewret/workflow/#limit_1","text":"def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim.","title":"limit"},{"location":"reference/dewret/workflow/#lseries_1","text":"def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries().","title":"lseries"},{"location":"reference/dewret/workflow/#match_1","text":"def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self","title":"match"},{"location":"reference/dewret/workflow/#examples_77","text":"from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2}","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_23","text":"matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching","title":"See Also"},{"location":"reference/dewret/workflow/#matches_1","text":"def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr.","title":"matches"},{"location":"reference/dewret/workflow/#examples_78","text":"from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c}","title":"Examples"},{"location":"reference/dewret/workflow/#n_1","text":"def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"n"},{"location":"reference/dewret/workflow/#parameters_8","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_10","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#normal_1","text":"def normal ( self ) Return the expression as a fraction. expression -> a/b","title":"normal"},{"location":"reference/dewret/workflow/#see-also_24","text":"as_numer_denom: return (a, b) instead of a/b","title":"See Also"},{"location":"reference/dewret/workflow/#nseries_1","text":"def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries().","title":"nseries"},{"location":"reference/dewret/workflow/#examples_79","text":"from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y)","title":"Examples"},{"location":"reference/dewret/workflow/#nsimplify_1","text":"def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify","title":"nsimplify"},{"location":"reference/dewret/workflow/#powsimp_1","text":"def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify","title":"powsimp"},{"location":"reference/dewret/workflow/#primitive_1","text":"def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float).","title":"primitive"},{"location":"reference/dewret/workflow/#examples_80","text":"from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True","title":"Examples"},{"location":"reference/dewret/workflow/#radsimp_1","text":"def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify","title":"radsimp"},{"location":"reference/dewret/workflow/#ratsimp_1","text":"def ratsimp ( self ) See the ratsimp function in sympy.simplify","title":"ratsimp"},{"location":"reference/dewret/workflow/#rcall_1","text":"def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z","title":"rcall"},{"location":"reference/dewret/workflow/#refine_1","text":"def refine ( self , assumption = True ) See the refine function in sympy.assumptions","title":"refine"},{"location":"reference/dewret/workflow/#removeo_1","text":"def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one","title":"removeO"},{"location":"reference/dewret/workflow/#replace_1","text":"def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below:","title":"replace"},{"location":"reference/dewret/workflow/#examples_81","text":"Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_25","text":"subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules","title":"See Also"},{"location":"reference/dewret/workflow/#rewrite_1","text":"def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten.","title":"rewrite"},{"location":"reference/dewret/workflow/#parameters_9","text":"args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True .","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_82","text":"If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2)","title":"Examples"},{"location":"reference/dewret/workflow/#round_1","text":"def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number.","title":"round"},{"location":"reference/dewret/workflow/#examples_83","text":"from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I","title":"Examples"},{"location":"reference/dewret/workflow/#notes_11","text":"The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True","title":"Notes"},{"location":"reference/dewret/workflow/#separate_1","text":"def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify","title":"separate"},{"location":"reference/dewret/workflow/#series_1","text":"def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised.","title":"series"},{"location":"reference/dewret/workflow/#parameters_10","text":"expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_84","text":"from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_4","text":"Expr : Expression Series expansion of the expression about x0","title":"Returns"},{"location":"reference/dewret/workflow/#raises_1","text":"TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object","title":"Raises"},{"location":"reference/dewret/workflow/#simplify_1","text":"def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify","title":"simplify"},{"location":"reference/dewret/workflow/#sort_key_1","text":"def sort_key ( self , order = None ) Return a sort key.","title":"sort_key"},{"location":"reference/dewret/workflow/#examples_85","text":"from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2]","title":"Examples"},{"location":"reference/dewret/workflow/#subs_1","text":"def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made.","title":"subs"},{"location":"reference/dewret/workflow/#examples_86","text":"from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained.","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_26","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision","title":"See Also"},{"location":"reference/dewret/workflow/#taylor_term_1","text":"def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\".","title":"taylor_term"},{"location":"reference/dewret/workflow/#to_nnf_1","text":"def to_nnf ( self , simplify = True )","title":"to_nnf"},{"location":"reference/dewret/workflow/#together_1","text":"def together ( self , * args , ** kwargs ) See the together function in sympy.polys","title":"together"},{"location":"reference/dewret/workflow/#transpose_1","text":"def transpose ( self )","title":"transpose"},{"location":"reference/dewret/workflow/#trigsimp_1","text":"def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify","title":"trigsimp"},{"location":"reference/dewret/workflow/#xreplace_1","text":"def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression.","title":"xreplace"},{"location":"reference/dewret/workflow/#parameters_11","text":"rule : dict-like Expresses a replacement rule","title":"Parameters"},{"location":"reference/dewret/workflow/#returns_5","text":"xreplace : the result of the replacement","title":"Returns"},{"location":"reference/dewret/workflow/#examples_87","text":"from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_27","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves.","title":"See Also"},{"location":"reference/dewret/workflow/#lazy","text":"class Lazy ( * args , ** kwargs ) Requirements for a lazy-evaluatable function.","title":"Lazy"},{"location":"reference/dewret/workflow/#ancestors-in-mro_5","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#descendants_2","text":"dewret.workflow.LazyEvaluation","title":"Descendants"},{"location":"reference/dewret/workflow/#lazyevaluation","text":"class LazyEvaluation ( fn : 'Callable[Param, RetType]' ) Tracks a single evaluation of a lazy function.","title":"LazyEvaluation"},{"location":"reference/dewret/workflow/#ancestors-in-mro_6","text":"dewret.workflow.Lazy typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#nestedstep","text":"class NestedStep ( workflow : 'Workflow' , name : 'str' , subworkflow : 'Workflow' , arguments : 'Mapping[str, Basic | Reference[Any] | Raw]' , raw_as_parameter : 'bool' = False ) Calling out to a subworkflow. Type of BaseStep to call a subworkflow, which holds a reference to it.","title":"NestedStep"},{"location":"reference/dewret/workflow/#ancestors-in-mro_7","text":"dewret.workflow.BaseStep dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#class-variables_4","text":"positional_args","title":"Class variables"},{"location":"reference/dewret/workflow/#instance-variables_5","text":"id Consistent ID based on the value. name Name for this step. May be remapped by the workflow to something nicer than the ID. return_type Take the type of the wrapped function from the target. Unwraps and inspects the signature, meaning that the original wrapped function must have a typehint for the return value. subworkflow Subworkflow that is wrapped.","title":"Instance variables"},{"location":"reference/dewret/workflow/#methods_5","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#make_reference_2","text":"def make_reference ( self , ** kwargs : 'Any' ) -> \"'StepReference[T]'\" Create a reference to this step. Builds a reference to the (result of) this step, which will be iterable if appropriate. Parameters: Name Type Description Default **kwargs None arguments for reference constructor, which will be supplemented appropriately. None","title":"make_reference"},{"location":"reference/dewret/workflow/#set_workflow_2","text":"def set_workflow ( self , workflow : 'Workflow' , with_arguments : 'bool' = True ) -> 'None' Move the step reference to another workflow. This method is primarily intended to be called by a step, allowing it to switch to a new workflow. It also updates the workflow reference for any arguments that are steps themselves, if specified. Parameters: Name Type Description Default workflow None The new target workflow to which the step should be moved. None with_arguments None If True, also update the workflow reference for the step's arguments. None","title":"set_workflow"},{"location":"reference/dewret/workflow/#parameter","text":"class Parameter ( name : 'str' , default : 'T | UnsetType[T]' , tethered : 'Literal[False] | None | Step | Workflow' = None , autoname : 'bool' = False , typ : 'type[T] | Unset' = < dewret . utils . Unset object at 0x7f2d6ea66910 > ) Global parameter. Independent parameter that will be used when a task is spotted reaching outside its scope. This wraps the variable it uses. To allow for potential arithmetic operations, etc. it is a Sympy symbol.","title":"Parameter"},{"location":"reference/dewret/workflow/#attributes_2","text":"Name Type Description Default name None name of the parameter. None default None captured default value from the original value. None","title":"Attributes"},{"location":"reference/dewret/workflow/#ancestors-in-mro_8","text":"typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#class-variables_5","text":"autoname default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol","title":"Class variables"},{"location":"reference/dewret/workflow/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/dewret/workflow/#class_key_2","text":"def class_key ( ) Nice order of classes.","title":"class_key"},{"location":"reference/dewret/workflow/#fromiter_2","text":"def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first.","title":"fromiter"},{"location":"reference/dewret/workflow/#examples_88","text":"from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4)","title":"Examples"},{"location":"reference/dewret/workflow/#is_loopable","text":"def is_loopable ( typ : 'type' ) -> 'bool' Checks if this type can be looped over. In particular, checks if this is an iterable that is NOT a str or bytes, possibly disguised behind an Annotated. Parameters: Name Type Description Default typ None type to check. None","title":"is_loopable"},{"location":"reference/dewret/workflow/#instance-variables_6","text":"args Returns a tuple of arguments of 'self'.","title":"Instance variables"},{"location":"reference/dewret/workflow/#examples_89","text":"from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y","title":"Examples"},{"location":"reference/dewret/workflow/#notes_12","text":"Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression.","title":"Notes"},{"location":"reference/dewret/workflow/#examples_90","text":"from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} default Retrieve default value for this parameter, or an unset token. expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args)","title":"Examples"},{"location":"reference/dewret/workflow/#examples_91","text":"from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Extended name, suitable for rendering. This attempts to create a unique name by tying the parameter to a step if the user has not explicitly provided a name, ideally the one where we discovered it.","title":"Examples"},{"location":"reference/dewret/workflow/#methods_6","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#adjoint_2","text":"def adjoint ( self )","title":"adjoint"},{"location":"reference/dewret/workflow/#apart_2","text":"def apart ( self , x = None , ** args ) See the apart function in sympy.polys","title":"apart"},{"location":"reference/dewret/workflow/#args_cnc_2","text":"def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self.","title":"args_cnc"},{"location":"reference/dewret/workflow/#explanation_12","text":"self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_92","text":"from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []]","title":"Examples"},{"location":"reference/dewret/workflow/#as_base_exp_2","text":"def as_base_exp ( self ) -> 'tuple[Expr, Expr]'","title":"as_base_exp"},{"location":"reference/dewret/workflow/#as_coeff_add_4","text":"def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation.","title":"as_coeff_Add"},{"location":"reference/dewret/workflow/#as_coeff_mul_4","text":"def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product.","title":"as_coeff_Mul"},{"location":"reference/dewret/workflow/#as_coeff_add_5","text":"def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ())","title":"as_coeff_add"},{"location":"reference/dewret/workflow/#as_coeff_exponent_2","text":"def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression.","title":"as_coeff_exponent"},{"location":"reference/dewret/workflow/#as_coeff_mul_5","text":"def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ())","title":"as_coeff_mul"},{"location":"reference/dewret/workflow/#as_coefficient_2","text":"def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None.","title":"as_coefficient"},{"location":"reference/dewret/workflow/#examples_93","text":"from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_28","text":"coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#as_coefficients_dict_2","text":"def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned.","title":"as_coefficients_dict"},{"location":"reference/dewret/workflow/#examples_94","text":"from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x}","title":"Examples"},{"location":"reference/dewret/workflow/#as_content_primitive_2","text":"def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self).","title":"as_content_primitive"},{"location":"reference/dewret/workflow/#examples_95","text":"from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y)","title":"Examples"},{"location":"reference/dewret/workflow/#as_dummy_2","text":"def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned.","title":"as_dummy"},{"location":"reference/dewret/workflow/#examples_96","text":"from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r","title":"Examples"},{"location":"reference/dewret/workflow/#notes_13","text":"Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object.","title":"Notes"},{"location":"reference/dewret/workflow/#as_expr_2","text":"def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression.","title":"as_expr"},{"location":"reference/dewret/workflow/#examples_97","text":"from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x)","title":"Examples"},{"location":"reference/dewret/workflow/#as_independent_2","text":"def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True","title":"as_independent"},{"location":"reference/dewret/workflow/#examples_98","text":"-- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b))","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_29","text":"separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul","title":"See Also"},{"location":"reference/dewret/workflow/#as_leading_term_2","text":"def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value.","title":"as_leading_term"},{"location":"reference/dewret/workflow/#examples_99","text":"from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2)","title":"Examples"},{"location":"reference/dewret/workflow/#as_numer_denom_2","text":"def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else.","title":"as_numer_denom"},{"location":"reference/dewret/workflow/#see-also_30","text":"normal: return a/b instead of (a, b)","title":"See Also"},{"location":"reference/dewret/workflow/#as_ordered_factors_2","text":"def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self].","title":"as_ordered_factors"},{"location":"reference/dewret/workflow/#as_ordered_terms_2","text":"def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms.","title":"as_ordered_terms"},{"location":"reference/dewret/workflow/#examples_100","text":"from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1]","title":"Examples"},{"location":"reference/dewret/workflow/#as_poly_2","text":"def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None .","title":"as_poly"},{"location":"reference/dewret/workflow/#explanation_13","text":"from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None","title":"Explanation"},{"location":"reference/dewret/workflow/#as_powers_dict_2","text":"def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary.","title":"as_powers_dict"},{"location":"reference/dewret/workflow/#see-also_31","text":"as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.","title":"See Also"},{"location":"reference/dewret/workflow/#as_real_imag_2","text":"def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z))","title":"as_real_imag"},{"location":"reference/dewret/workflow/#as_set_2","text":"def as_set ( self ) Rewrites Boolean expression in terms of real sets.","title":"as_set"},{"location":"reference/dewret/workflow/#examples_101","text":"from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo))","title":"Examples"},{"location":"reference/dewret/workflow/#as_terms_2","text":"def as_terms ( self ) Transform an expression to a list of terms.","title":"as_terms"},{"location":"reference/dewret/workflow/#aseries_2","text":"def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) .","title":"aseries"},{"location":"reference/dewret/workflow/#parameters_12","text":"self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_102","text":"from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_6","text":"Expr Asymptotic series expansion of the expression.","title":"Returns"},{"location":"reference/dewret/workflow/#notes_14","text":"This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self .","title":"Notes"},{"location":"reference/dewret/workflow/#references_4","text":".. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion","title":"References"},{"location":"reference/dewret/workflow/#see-also_32","text":"Expr.aseries: See the docstring of this function for complete details of this wrapper.","title":"See Also"},{"location":"reference/dewret/workflow/#atoms_2","text":"def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below.","title":"atoms"},{"location":"reference/dewret/workflow/#examples_103","text":"from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)}","title":"Examples"},{"location":"reference/dewret/workflow/#cancel_2","text":"def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys","title":"cancel"},{"location":"reference/dewret/workflow/#coeff_2","text":"def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned.","title":"coeff"},{"location":"reference/dewret/workflow/#explanation_14","text":"When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_104","text":"from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_33","text":"as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#collect_2","text":"def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify","title":"collect"},{"location":"reference/dewret/workflow/#combsimp_2","text":"def combsimp ( self ) See the combsimp function in sympy.simplify","title":"combsimp"},{"location":"reference/dewret/workflow/#compare_2","text":"def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned.","title":"compare"},{"location":"reference/dewret/workflow/#examples_105","text":"from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1","title":"Examples"},{"location":"reference/dewret/workflow/#conjugate_2","text":"def conjugate ( self ) Returns the complex conjugate of 'self'.","title":"conjugate"},{"location":"reference/dewret/workflow/#copy_2","text":"def copy ( self )","title":"copy"},{"location":"reference/dewret/workflow/#could_extract_minus_sign_2","text":"def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False.","title":"could_extract_minus_sign"},{"location":"reference/dewret/workflow/#examples_106","text":"from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True","title":"Examples"},{"location":"reference/dewret/workflow/#count_2","text":"def count ( self , query ) Count the number of matching subexpressions.","title":"count"},{"location":"reference/dewret/workflow/#count_ops_2","text":"def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count.","title":"count_ops"},{"location":"reference/dewret/workflow/#diff_2","text":"def diff ( self , * symbols , ** assumptions )","title":"diff"},{"location":"reference/dewret/workflow/#dir_2","text":"def dir ( self , x , cdir )","title":"dir"},{"location":"reference/dewret/workflow/#doit_2","text":"def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x)","title":"doit"},{"location":"reference/dewret/workflow/#dummy_eq_2","text":"def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols.","title":"dummy_eq"},{"location":"reference/dewret/workflow/#examples_107","text":"from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False","title":"Examples"},{"location":"reference/dewret/workflow/#equals_2","text":"def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None.","title":"equals"},{"location":"reference/dewret/workflow/#explanation_15","text":"If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False.","title":"Explanation"},{"location":"reference/dewret/workflow/#evalf_2","text":"def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"evalf"},{"location":"reference/dewret/workflow/#parameters_13","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_15","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#expand_2","text":"def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information.","title":"expand"},{"location":"reference/dewret/workflow/#extract_additively_2","text":"def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None.","title":"extract_additively"},{"location":"reference/dewret/workflow/#examples_108","text":"from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_34","text":"extract_multiplicatively coeff as_coefficient","title":"See Also"},{"location":"reference/dewret/workflow/#extract_branch_factor_2","text":"def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2)","title":"extract_branch_factor"},{"location":"reference/dewret/workflow/#extract_multiplicatively_2","text":"def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self.","title":"extract_multiplicatively"},{"location":"reference/dewret/workflow/#examples_109","text":"from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6","title":"Examples"},{"location":"reference/dewret/workflow/#factor_2","text":"def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools","title":"factor"},{"location":"reference/dewret/workflow/#find_2","text":"def find ( self , query , group = False ) Find all subexpressions matching a query.","title":"find"},{"location":"reference/dewret/workflow/#fourier_series_2","text":"def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information.","title":"fourier_series"},{"location":"reference/dewret/workflow/#fps_2","text":"def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information.","title":"fps"},{"location":"reference/dewret/workflow/#gammasimp_2","text":"def gammasimp ( self ) See the gammasimp function in sympy.simplify","title":"gammasimp"},{"location":"reference/dewret/workflow/#geto_2","text":"def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None.","title":"getO"},{"location":"reference/dewret/workflow/#getn_2","text":"def getn ( self ) Returns the order of the expression.","title":"getn"},{"location":"reference/dewret/workflow/#explanation_16","text":"The order is determined either from the O(...) term. If there is no O(...) term, it returns None.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_110","text":"from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn()","title":"Examples"},{"location":"reference/dewret/workflow/#has_2","text":"def has ( self , * patterns ) Test whether any subexpression matches any of the patterns.","title":"has"},{"location":"reference/dewret/workflow/#examples_111","text":"from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False","title":"Examples"},{"location":"reference/dewret/workflow/#has_free_2","text":"def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False.","title":"has_free"},{"location":"reference/dewret/workflow/#examples_112","text":"from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True","title":"Examples"},{"location":"reference/dewret/workflow/#has_xfree_2","text":"def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches.","title":"has_xfree"},{"location":"reference/dewret/workflow/#examples_113","text":"from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False","title":"Examples"},{"location":"reference/dewret/workflow/#integrate_2","text":"def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals","title":"integrate"},{"location":"reference/dewret/workflow/#invert_2","text":"def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions).","title":"invert"},{"location":"reference/dewret/workflow/#see-also_35","text":"sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert","title":"See Also"},{"location":"reference/dewret/workflow/#is_algebraic_expr_2","text":"def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation.","title":"is_algebraic_expr"},{"location":"reference/dewret/workflow/#examples_114","text":"from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_36","text":"is_rational_function","title":"See Also"},{"location":"reference/dewret/workflow/#references_5","text":".. [1] https://en.wikipedia.org/wiki/Algebraic_expression","title":"References"},{"location":"reference/dewret/workflow/#is_constant_2","text":"def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively.","title":"is_constant"},{"location":"reference/dewret/workflow/#explanation_17","text":"If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_115","text":"from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True","title":"Examples"},{"location":"reference/dewret/workflow/#is_hypergeometric_2","text":"def is_hypergeometric ( self , k )","title":"is_hypergeometric"},{"location":"reference/dewret/workflow/#is_meromorphic_2","text":"def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis.","title":"is_meromorphic"},{"location":"reference/dewret/workflow/#examples_116","text":"from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False","title":"Examples"},{"location":"reference/dewret/workflow/#is_polynomial_2","text":"def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True).","title":"is_polynomial"},{"location":"reference/dewret/workflow/#examples_117","text":"from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function()","title":"Examples"},{"location":"reference/dewret/workflow/#is_rational_function_2","text":"def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True).","title":"is_rational_function"},{"location":"reference/dewret/workflow/#examples_118","text":"from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr().","title":"Examples"},{"location":"reference/dewret/workflow/#is_same_2","text":"def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).","title":"is_same"},{"location":"reference/dewret/workflow/#examples_119","text":"In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False","title":"Examples"},{"location":"reference/dewret/workflow/#leadterm_2","text":"def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b).","title":"leadterm"},{"location":"reference/dewret/workflow/#examples_120","text":"from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2)","title":"Examples"},{"location":"reference/dewret/workflow/#limit_2","text":"def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim.","title":"limit"},{"location":"reference/dewret/workflow/#lseries_2","text":"def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries().","title":"lseries"},{"location":"reference/dewret/workflow/#make_reference_3","text":"def make_reference ( self , ** kwargs : 'Any' ) -> \"'ParameterReference[T]'\" Creates a new reference for the parameter. The kwargs will be passed to the constructor, but the Parameters: Name Type Description Default typ None type of the new reference's target. None **kwargs None arguments to pass to the constructor. None","title":"make_reference"},{"location":"reference/dewret/workflow/#match_2","text":"def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self","title":"match"},{"location":"reference/dewret/workflow/#examples_121","text":"from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2}","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_37","text":"matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching","title":"See Also"},{"location":"reference/dewret/workflow/#matches_2","text":"def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr.","title":"matches"},{"location":"reference/dewret/workflow/#examples_122","text":"from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c}","title":"Examples"},{"location":"reference/dewret/workflow/#n_2","text":"def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"n"},{"location":"reference/dewret/workflow/#parameters_14","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_16","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#normal_2","text":"def normal ( self ) Return the expression as a fraction. expression -> a/b","title":"normal"},{"location":"reference/dewret/workflow/#see-also_38","text":"as_numer_denom: return (a, b) instead of a/b","title":"See Also"},{"location":"reference/dewret/workflow/#nseries_2","text":"def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries().","title":"nseries"},{"location":"reference/dewret/workflow/#examples_123","text":"from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y)","title":"Examples"},{"location":"reference/dewret/workflow/#nsimplify_2","text":"def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify","title":"nsimplify"},{"location":"reference/dewret/workflow/#powsimp_2","text":"def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify","title":"powsimp"},{"location":"reference/dewret/workflow/#primitive_2","text":"def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float).","title":"primitive"},{"location":"reference/dewret/workflow/#examples_124","text":"from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True","title":"Examples"},{"location":"reference/dewret/workflow/#radsimp_2","text":"def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify","title":"radsimp"},{"location":"reference/dewret/workflow/#ratsimp_2","text":"def ratsimp ( self ) See the ratsimp function in sympy.simplify","title":"ratsimp"},{"location":"reference/dewret/workflow/#rcall_2","text":"def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z","title":"rcall"},{"location":"reference/dewret/workflow/#refine_2","text":"def refine ( self , assumption = True ) See the refine function in sympy.assumptions","title":"refine"},{"location":"reference/dewret/workflow/#register_caller","text":"def register_caller ( self , caller : 'BaseStep' ) -> 'None' Capture a step that uses this parameter. Gathers together the steps using this parameter. The first found will be recorded as the tethered step, and used for forming the name.","title":"register_caller"},{"location":"reference/dewret/workflow/#removeo_2","text":"def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one","title":"removeO"},{"location":"reference/dewret/workflow/#replace_2","text":"def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below:","title":"replace"},{"location":"reference/dewret/workflow/#examples_125","text":"Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_39","text":"subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules","title":"See Also"},{"location":"reference/dewret/workflow/#rewrite_2","text":"def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten.","title":"rewrite"},{"location":"reference/dewret/workflow/#parameters_15","text":"args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True .","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_126","text":"If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2)","title":"Examples"},{"location":"reference/dewret/workflow/#round_2","text":"def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number.","title":"round"},{"location":"reference/dewret/workflow/#examples_127","text":"from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I","title":"Examples"},{"location":"reference/dewret/workflow/#notes_17","text":"The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True","title":"Notes"},{"location":"reference/dewret/workflow/#separate_2","text":"def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify","title":"separate"},{"location":"reference/dewret/workflow/#series_2","text":"def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised.","title":"series"},{"location":"reference/dewret/workflow/#parameters_16","text":"expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_128","text":"from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_7","text":"Expr : Expression Series expansion of the expression about x0","title":"Returns"},{"location":"reference/dewret/workflow/#raises_2","text":"TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object","title":"Raises"},{"location":"reference/dewret/workflow/#simplify_2","text":"def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify","title":"simplify"},{"location":"reference/dewret/workflow/#sort_key_2","text":"def sort_key ( self , order = None ) Return a sort key.","title":"sort_key"},{"location":"reference/dewret/workflow/#examples_129","text":"from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2]","title":"Examples"},{"location":"reference/dewret/workflow/#subs_2","text":"def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made.","title":"subs"},{"location":"reference/dewret/workflow/#examples_130","text":"from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained.","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_40","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision","title":"See Also"},{"location":"reference/dewret/workflow/#taylor_term_2","text":"def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\".","title":"taylor_term"},{"location":"reference/dewret/workflow/#to_nnf_2","text":"def to_nnf ( self , simplify = True )","title":"to_nnf"},{"location":"reference/dewret/workflow/#together_2","text":"def together ( self , * args , ** kwargs ) See the together function in sympy.polys","title":"together"},{"location":"reference/dewret/workflow/#transpose_2","text":"def transpose ( self )","title":"transpose"},{"location":"reference/dewret/workflow/#trigsimp_2","text":"def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify","title":"trigsimp"},{"location":"reference/dewret/workflow/#xreplace_2","text":"def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression.","title":"xreplace"},{"location":"reference/dewret/workflow/#parameters_17","text":"rule : dict-like Expresses a replacement rule","title":"Parameters"},{"location":"reference/dewret/workflow/#returns_8","text":"xreplace : the result of the replacement","title":"Returns"},{"location":"reference/dewret/workflow/#examples_131","text":"from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_41","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves.","title":"See Also"},{"location":"reference/dewret/workflow/#parameterreference","text":"class ParameterReference ( parameter : 'Parameter[U]' , * args : 'Any' , typ : 'type[U] | None' = None , ** kwargs : 'Any' ) Reference to an individual Parameter . Allows us to refer to the outputs of a Parameter in subsequent Parameter arguments.","title":"ParameterReference"},{"location":"reference/dewret/workflow/#attributes_3","text":"Name Type Description Default parameter None Parameter referred to. None workflow None Related workflow. In this case, as Parameters are generic but ParameterReferences are specific, this carries the actual workflow reference. None","title":"Attributes"},{"location":"reference/dewret/workflow/#ancestors-in-mro_9","text":"dewret.workflow.FieldableMixin dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#descendants_3","text":"dewret.workflow.IterableParameterReference","title":"Descendants"},{"location":"reference/dewret/workflow/#class-variables_6","text":"ParameterReferenceMetadata default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol","title":"Class variables"},{"location":"reference/dewret/workflow/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/dewret/workflow/#class_key_3","text":"def class_key ( ) Nice order of classes.","title":"class_key"},{"location":"reference/dewret/workflow/#fromiter_3","text":"def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first.","title":"fromiter"},{"location":"reference/dewret/workflow/#examples_132","text":"from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4)","title":"Examples"},{"location":"reference/dewret/workflow/#instance-variables_7","text":"args Returns a tuple of arguments of 'self'.","title":"Instance variables"},{"location":"reference/dewret/workflow/#examples_133","text":"from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y","title":"Examples"},{"location":"reference/dewret/workflow/#notes_18","text":"Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression.","title":"Notes"},{"location":"reference/dewret/workflow/#examples_134","text":"from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args)","title":"Examples"},{"location":"reference/dewret/workflow/#examples_135","text":"from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference.","title":"Examples"},{"location":"reference/dewret/workflow/#methods_7","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#adjoint_3","text":"def adjoint ( self )","title":"adjoint"},{"location":"reference/dewret/workflow/#apart_3","text":"def apart ( self , x = None , ** args ) See the apart function in sympy.polys","title":"apart"},{"location":"reference/dewret/workflow/#args_cnc_3","text":"def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self.","title":"args_cnc"},{"location":"reference/dewret/workflow/#explanation_18","text":"self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_136","text":"from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []]","title":"Examples"},{"location":"reference/dewret/workflow/#as_base_exp_3","text":"def as_base_exp ( self ) -> 'tuple[Expr, Expr]'","title":"as_base_exp"},{"location":"reference/dewret/workflow/#as_coeff_add_6","text":"def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation.","title":"as_coeff_Add"},{"location":"reference/dewret/workflow/#as_coeff_mul_6","text":"def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product.","title":"as_coeff_Mul"},{"location":"reference/dewret/workflow/#as_coeff_add_7","text":"def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ())","title":"as_coeff_add"},{"location":"reference/dewret/workflow/#as_coeff_exponent_3","text":"def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression.","title":"as_coeff_exponent"},{"location":"reference/dewret/workflow/#as_coeff_mul_7","text":"def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ())","title":"as_coeff_mul"},{"location":"reference/dewret/workflow/#as_coefficient_3","text":"def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None.","title":"as_coefficient"},{"location":"reference/dewret/workflow/#examples_137","text":"from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_42","text":"coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#as_coefficients_dict_3","text":"def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned.","title":"as_coefficients_dict"},{"location":"reference/dewret/workflow/#examples_138","text":"from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x}","title":"Examples"},{"location":"reference/dewret/workflow/#as_content_primitive_3","text":"def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self).","title":"as_content_primitive"},{"location":"reference/dewret/workflow/#examples_139","text":"from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y)","title":"Examples"},{"location":"reference/dewret/workflow/#as_dummy_3","text":"def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned.","title":"as_dummy"},{"location":"reference/dewret/workflow/#examples_140","text":"from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r","title":"Examples"},{"location":"reference/dewret/workflow/#notes_19","text":"Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object.","title":"Notes"},{"location":"reference/dewret/workflow/#as_expr_3","text":"def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression.","title":"as_expr"},{"location":"reference/dewret/workflow/#examples_141","text":"from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x)","title":"Examples"},{"location":"reference/dewret/workflow/#as_independent_3","text":"def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True","title":"as_independent"},{"location":"reference/dewret/workflow/#examples_142","text":"-- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b))","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_43","text":"separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul","title":"See Also"},{"location":"reference/dewret/workflow/#as_leading_term_3","text":"def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value.","title":"as_leading_term"},{"location":"reference/dewret/workflow/#examples_143","text":"from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2)","title":"Examples"},{"location":"reference/dewret/workflow/#as_numer_denom_3","text":"def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else.","title":"as_numer_denom"},{"location":"reference/dewret/workflow/#see-also_44","text":"normal: return a/b instead of (a, b)","title":"See Also"},{"location":"reference/dewret/workflow/#as_ordered_factors_3","text":"def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self].","title":"as_ordered_factors"},{"location":"reference/dewret/workflow/#as_ordered_terms_3","text":"def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms.","title":"as_ordered_terms"},{"location":"reference/dewret/workflow/#examples_144","text":"from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1]","title":"Examples"},{"location":"reference/dewret/workflow/#as_poly_3","text":"def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None .","title":"as_poly"},{"location":"reference/dewret/workflow/#explanation_19","text":"from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None","title":"Explanation"},{"location":"reference/dewret/workflow/#as_powers_dict_3","text":"def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary.","title":"as_powers_dict"},{"location":"reference/dewret/workflow/#see-also_45","text":"as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.","title":"See Also"},{"location":"reference/dewret/workflow/#as_real_imag_3","text":"def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z))","title":"as_real_imag"},{"location":"reference/dewret/workflow/#as_set_3","text":"def as_set ( self ) Rewrites Boolean expression in terms of real sets.","title":"as_set"},{"location":"reference/dewret/workflow/#examples_145","text":"from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo))","title":"Examples"},{"location":"reference/dewret/workflow/#as_terms_3","text":"def as_terms ( self ) Transform an expression to a list of terms.","title":"as_terms"},{"location":"reference/dewret/workflow/#aseries_3","text":"def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) .","title":"aseries"},{"location":"reference/dewret/workflow/#parameters_18","text":"self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_146","text":"from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_9","text":"Expr Asymptotic series expansion of the expression.","title":"Returns"},{"location":"reference/dewret/workflow/#notes_20","text":"This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self .","title":"Notes"},{"location":"reference/dewret/workflow/#references_6","text":".. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion","title":"References"},{"location":"reference/dewret/workflow/#see-also_46","text":"Expr.aseries: See the docstring of this function for complete details of this wrapper.","title":"See Also"},{"location":"reference/dewret/workflow/#atoms_3","text":"def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below.","title":"atoms"},{"location":"reference/dewret/workflow/#examples_147","text":"from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)}","title":"Examples"},{"location":"reference/dewret/workflow/#cancel_3","text":"def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys","title":"cancel"},{"location":"reference/dewret/workflow/#coeff_3","text":"def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned.","title":"coeff"},{"location":"reference/dewret/workflow/#explanation_20","text":"When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_148","text":"from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_47","text":"as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#collect_3","text":"def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify","title":"collect"},{"location":"reference/dewret/workflow/#combsimp_3","text":"def combsimp ( self ) See the combsimp function in sympy.simplify","title":"combsimp"},{"location":"reference/dewret/workflow/#compare_3","text":"def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned.","title":"compare"},{"location":"reference/dewret/workflow/#examples_149","text":"from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1","title":"Examples"},{"location":"reference/dewret/workflow/#conjugate_3","text":"def conjugate ( self ) Returns the complex conjugate of 'self'.","title":"conjugate"},{"location":"reference/dewret/workflow/#copy_3","text":"def copy ( self )","title":"copy"},{"location":"reference/dewret/workflow/#could_extract_minus_sign_3","text":"def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False.","title":"could_extract_minus_sign"},{"location":"reference/dewret/workflow/#examples_150","text":"from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True","title":"Examples"},{"location":"reference/dewret/workflow/#count_3","text":"def count ( self , query ) Count the number of matching subexpressions.","title":"count"},{"location":"reference/dewret/workflow/#count_ops_3","text":"def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count.","title":"count_ops"},{"location":"reference/dewret/workflow/#diff_3","text":"def diff ( self , * symbols , ** assumptions )","title":"diff"},{"location":"reference/dewret/workflow/#dir_3","text":"def dir ( self , x , cdir )","title":"dir"},{"location":"reference/dewret/workflow/#doit_3","text":"def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x)","title":"doit"},{"location":"reference/dewret/workflow/#dummy_eq_3","text":"def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols.","title":"dummy_eq"},{"location":"reference/dewret/workflow/#examples_151","text":"from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False","title":"Examples"},{"location":"reference/dewret/workflow/#equals_3","text":"def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None.","title":"equals"},{"location":"reference/dewret/workflow/#explanation_21","text":"If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False.","title":"Explanation"},{"location":"reference/dewret/workflow/#evalf_3","text":"def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"evalf"},{"location":"reference/dewret/workflow/#parameters_19","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_21","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#expand_3","text":"def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information.","title":"expand"},{"location":"reference/dewret/workflow/#extract_additively_3","text":"def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None.","title":"extract_additively"},{"location":"reference/dewret/workflow/#examples_152","text":"from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_48","text":"extract_multiplicatively coeff as_coefficient","title":"See Also"},{"location":"reference/dewret/workflow/#extract_branch_factor_3","text":"def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2)","title":"extract_branch_factor"},{"location":"reference/dewret/workflow/#extract_multiplicatively_3","text":"def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self.","title":"extract_multiplicatively"},{"location":"reference/dewret/workflow/#examples_153","text":"from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6","title":"Examples"},{"location":"reference/dewret/workflow/#factor_3","text":"def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools","title":"factor"},{"location":"reference/dewret/workflow/#find_3","text":"def find ( self , query , group = False ) Find all subexpressions matching a query.","title":"find"},{"location":"reference/dewret/workflow/#find_field_3","text":"def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference.","title":"find_field"},{"location":"reference/dewret/workflow/#fourier_series_3","text":"def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information.","title":"fourier_series"},{"location":"reference/dewret/workflow/#fps_3","text":"def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information.","title":"fps"},{"location":"reference/dewret/workflow/#gammasimp_3","text":"def gammasimp ( self ) See the gammasimp function in sympy.simplify","title":"gammasimp"},{"location":"reference/dewret/workflow/#geto_3","text":"def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None.","title":"getO"},{"location":"reference/dewret/workflow/#getn_3","text":"def getn ( self ) Returns the order of the expression.","title":"getn"},{"location":"reference/dewret/workflow/#explanation_22","text":"The order is determined either from the O(...) term. If there is no O(...) term, it returns None.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_154","text":"from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn()","title":"Examples"},{"location":"reference/dewret/workflow/#has_3","text":"def has ( self , * patterns ) Test whether any subexpression matches any of the patterns.","title":"has"},{"location":"reference/dewret/workflow/#examples_155","text":"from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False","title":"Examples"},{"location":"reference/dewret/workflow/#has_free_3","text":"def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False.","title":"has_free"},{"location":"reference/dewret/workflow/#examples_156","text":"from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True","title":"Examples"},{"location":"reference/dewret/workflow/#has_xfree_3","text":"def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches.","title":"has_xfree"},{"location":"reference/dewret/workflow/#examples_157","text":"from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False","title":"Examples"},{"location":"reference/dewret/workflow/#integrate_3","text":"def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals","title":"integrate"},{"location":"reference/dewret/workflow/#invert_3","text":"def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions).","title":"invert"},{"location":"reference/dewret/workflow/#see-also_49","text":"sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert","title":"See Also"},{"location":"reference/dewret/workflow/#is_algebraic_expr_3","text":"def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation.","title":"is_algebraic_expr"},{"location":"reference/dewret/workflow/#examples_158","text":"from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_50","text":"is_rational_function","title":"See Also"},{"location":"reference/dewret/workflow/#references_7","text":".. [1] https://en.wikipedia.org/wiki/Algebraic_expression","title":"References"},{"location":"reference/dewret/workflow/#is_constant_3","text":"def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively.","title":"is_constant"},{"location":"reference/dewret/workflow/#explanation_23","text":"If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_159","text":"from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True","title":"Examples"},{"location":"reference/dewret/workflow/#is_hypergeometric_3","text":"def is_hypergeometric ( self , k )","title":"is_hypergeometric"},{"location":"reference/dewret/workflow/#is_meromorphic_3","text":"def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis.","title":"is_meromorphic"},{"location":"reference/dewret/workflow/#examples_160","text":"from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False","title":"Examples"},{"location":"reference/dewret/workflow/#is_polynomial_3","text":"def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True).","title":"is_polynomial"},{"location":"reference/dewret/workflow/#examples_161","text":"from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function()","title":"Examples"},{"location":"reference/dewret/workflow/#is_rational_function_3","text":"def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True).","title":"is_rational_function"},{"location":"reference/dewret/workflow/#examples_162","text":"from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr().","title":"Examples"},{"location":"reference/dewret/workflow/#is_same_3","text":"def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).","title":"is_same"},{"location":"reference/dewret/workflow/#examples_163","text":"In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False","title":"Examples"},{"location":"reference/dewret/workflow/#leadterm_3","text":"def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b).","title":"leadterm"},{"location":"reference/dewret/workflow/#examples_164","text":"from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2)","title":"Examples"},{"location":"reference/dewret/workflow/#limit_3","text":"def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim.","title":"limit"},{"location":"reference/dewret/workflow/#lseries_3","text":"def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries().","title":"lseries"},{"location":"reference/dewret/workflow/#match_3","text":"def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self","title":"match"},{"location":"reference/dewret/workflow/#examples_165","text":"from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2}","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_51","text":"matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching","title":"See Also"},{"location":"reference/dewret/workflow/#matches_3","text":"def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr.","title":"matches"},{"location":"reference/dewret/workflow/#examples_166","text":"from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c}","title":"Examples"},{"location":"reference/dewret/workflow/#n_3","text":"def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"n"},{"location":"reference/dewret/workflow/#parameters_20","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_22","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#normal_3","text":"def normal ( self ) Return the expression as a fraction. expression -> a/b","title":"normal"},{"location":"reference/dewret/workflow/#see-also_52","text":"as_numer_denom: return (a, b) instead of a/b","title":"See Also"},{"location":"reference/dewret/workflow/#nseries_3","text":"def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries().","title":"nseries"},{"location":"reference/dewret/workflow/#examples_167","text":"from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y)","title":"Examples"},{"location":"reference/dewret/workflow/#nsimplify_3","text":"def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify","title":"nsimplify"},{"location":"reference/dewret/workflow/#powsimp_3","text":"def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify","title":"powsimp"},{"location":"reference/dewret/workflow/#primitive_3","text":"def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float).","title":"primitive"},{"location":"reference/dewret/workflow/#examples_168","text":"from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True","title":"Examples"},{"location":"reference/dewret/workflow/#radsimp_3","text":"def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify","title":"radsimp"},{"location":"reference/dewret/workflow/#ratsimp_3","text":"def ratsimp ( self ) See the ratsimp function in sympy.simplify","title":"ratsimp"},{"location":"reference/dewret/workflow/#rcall_3","text":"def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z","title":"rcall"},{"location":"reference/dewret/workflow/#refine_3","text":"def refine ( self , assumption = True ) See the refine function in sympy.assumptions","title":"refine"},{"location":"reference/dewret/workflow/#removeo_3","text":"def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one","title":"removeO"},{"location":"reference/dewret/workflow/#replace_3","text":"def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below:","title":"replace"},{"location":"reference/dewret/workflow/#examples_169","text":"Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_53","text":"subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules","title":"See Also"},{"location":"reference/dewret/workflow/#rewrite_3","text":"def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten.","title":"rewrite"},{"location":"reference/dewret/workflow/#parameters_21","text":"args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True .","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_170","text":"If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2)","title":"Examples"},{"location":"reference/dewret/workflow/#round_3","text":"def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number.","title":"round"},{"location":"reference/dewret/workflow/#examples_171","text":"from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I","title":"Examples"},{"location":"reference/dewret/workflow/#notes_23","text":"The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True","title":"Notes"},{"location":"reference/dewret/workflow/#separate_3","text":"def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify","title":"separate"},{"location":"reference/dewret/workflow/#series_3","text":"def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised.","title":"series"},{"location":"reference/dewret/workflow/#parameters_22","text":"expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_172","text":"from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_10","text":"Expr : Expression Series expansion of the expression about x0","title":"Returns"},{"location":"reference/dewret/workflow/#raises_3","text":"TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object","title":"Raises"},{"location":"reference/dewret/workflow/#simplify_3","text":"def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify","title":"simplify"},{"location":"reference/dewret/workflow/#sort_key_3","text":"def sort_key ( self , order = None ) Return a sort key.","title":"sort_key"},{"location":"reference/dewret/workflow/#examples_173","text":"from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2]","title":"Examples"},{"location":"reference/dewret/workflow/#subs_3","text":"def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made.","title":"subs"},{"location":"reference/dewret/workflow/#examples_174","text":"from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained.","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_54","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision","title":"See Also"},{"location":"reference/dewret/workflow/#taylor_term_3","text":"def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\".","title":"taylor_term"},{"location":"reference/dewret/workflow/#to_nnf_3","text":"def to_nnf ( self , simplify = True )","title":"to_nnf"},{"location":"reference/dewret/workflow/#together_3","text":"def together ( self , * args , ** kwargs ) See the together function in sympy.polys","title":"together"},{"location":"reference/dewret/workflow/#transpose_3","text":"def transpose ( self )","title":"transpose"},{"location":"reference/dewret/workflow/#trigsimp_3","text":"def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify","title":"trigsimp"},{"location":"reference/dewret/workflow/#xreplace_3","text":"def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression.","title":"xreplace"},{"location":"reference/dewret/workflow/#parameters_23","text":"rule : dict-like Expresses a replacement rule","title":"Parameters"},{"location":"reference/dewret/workflow/#returns_11","text":"xreplace : the result of the replacement","title":"Returns"},{"location":"reference/dewret/workflow/#examples_175","text":"from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_55","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves.","title":"See Also"},{"location":"reference/dewret/workflow/#step","text":"class Step ( workflow : 'Workflow' , task : 'Task | Workflow' , arguments : 'Mapping[str, Reference[Any] | Raw]' , raw_as_parameter : 'bool' = False ) Regular step.","title":"Step"},{"location":"reference/dewret/workflow/#ancestors-in-mro_10","text":"dewret.workflow.BaseStep dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#descendants_4","text":"dewret.workflow.FactoryCall","title":"Descendants"},{"location":"reference/dewret/workflow/#class-variables_7","text":"positional_args","title":"Class variables"},{"location":"reference/dewret/workflow/#instance-variables_8","text":"id Consistent ID based on the value. name Name for this step. May be remapped by the workflow to something nicer than the ID. return_type Take the type of the wrapped function from the target. Unwraps and inspects the signature, meaning that the original wrapped function must have a typehint for the return value.","title":"Instance variables"},{"location":"reference/dewret/workflow/#methods_8","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#make_reference_4","text":"def make_reference ( self , ** kwargs : 'Any' ) -> \"'StepReference[T]'\" Create a reference to this step. Builds a reference to the (result of) this step, which will be iterable if appropriate. Parameters: Name Type Description Default **kwargs None arguments for reference constructor, which will be supplemented appropriately. None","title":"make_reference"},{"location":"reference/dewret/workflow/#set_workflow_3","text":"def set_workflow ( self , workflow : 'Workflow' , with_arguments : 'bool' = True ) -> 'None' Move the step reference to another workflow. This method is primarily intended to be called by a step, allowing it to switch to a new workflow. It also updates the workflow reference for any arguments that are steps themselves, if specified. Parameters: Name Type Description Default workflow None The new target workflow to which the step should be moved. None with_arguments None If True, also update the workflow reference for the step's arguments. None","title":"set_workflow"},{"location":"reference/dewret/workflow/#stepreference","text":"class StepReference ( step : 'BaseStep' , * args : 'Any' , typ : 'type[U] | None' = None , ** kwargs : 'Any' ) Reference to an individual Step . Allows us to refer to the outputs of a Step in subsequent Step arguments.","title":"StepReference"},{"location":"reference/dewret/workflow/#attributes_4","text":"Name Type Description Default _ None metadata wrapping the Step referred to. None","title":"Attributes"},{"location":"reference/dewret/workflow/#ancestors-in-mro_11","text":"dewret.workflow.FieldableMixin dewret.core.Reference typing.Generic sympy.core.symbol.Symbol sympy.core.expr.AtomicExpr sympy.core.basic.Atom sympy.core.expr.Expr sympy.logic.boolalg.Boolean sympy.core.basic.Basic sympy.printing.defaults.Printable sympy.core.evalf.EvalfMixin dewret.core.WorkflowComponent","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#descendants_5","text":"dewret.workflow.IterableStepReference","title":"Descendants"},{"location":"reference/dewret/workflow/#class-variables_8","text":"StepReferenceMetadata default_assumptions is_Add is_AlgebraicNumber is_Atom is_Boolean is_Derivative is_Dummy is_Equality is_Float is_Function is_Indexed is_Integer is_MatAdd is_MatMul is_Matrix is_Mul is_Not is_Number is_NumberSymbol is_Order is_Piecewise is_Point is_Poly is_Pow is_Rational is_Relational is_Symbol is_Vector is_Wild is_comparable is_number is_scalar is_symbol","title":"Class variables"},{"location":"reference/dewret/workflow/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/dewret/workflow/#class_key_4","text":"def class_key ( ) Nice order of classes.","title":"class_key"},{"location":"reference/dewret/workflow/#fromiter_4","text":"def fromiter ( args , ** assumptions ) Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first.","title":"fromiter"},{"location":"reference/dewret/workflow/#examples_176","text":"from sympy import Tuple Tuple.fromiter(i for i in range(5)) (0, 1, 2, 3, 4)","title":"Examples"},{"location":"reference/dewret/workflow/#instance-variables_9","text":"args Returns a tuple of arguments of 'self'.","title":"Instance variables"},{"location":"reference/dewret/workflow/#examples_177","text":"from sympy import cot from sympy.abc import x, y cot(x).args (x,) cot(x).args[0] x (x*y).args (x, y) (x*y).args[1] y","title":"Examples"},{"location":"reference/dewret/workflow/#notes_24","text":"Never use self._args, always use self.args. Only use _args in new when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). assumptions0 binary_symbols canonical_variables Return a dictionary mapping any variable defined in self.bound_symbols to Symbols that do not clash with any free symbols in the expression.","title":"Notes"},{"location":"reference/dewret/workflow/#examples_178","text":"from sympy import Lambda from sympy.abc import x Lambda(x, 2*x).canonical_variables {x: _0} expr_free_symbols free_symbols func The top-level function in an expression. The following should hold for all objects:: >> x == x.func(*x.args)","title":"Examples"},{"location":"reference/dewret/workflow/#examples_179","text":"from sympy.abc import x a = 2 x a.func a.args (2, x) a.func( a.args) 2 x a == a.func( a.args) True is_algebraic is_antihermitian is_commutative is_complex is_composite is_even is_extended_negative is_extended_nonnegative is_extended_nonpositive is_extended_nonzero is_extended_positive is_extended_real is_finite is_hermitian is_imaginary is_infinite is_integer is_irrational is_negative is_noninteger is_nonnegative is_nonpositive is_nonzero is_odd is_polar is_positive is_prime is_rational is_real is_transcendental is_zero kind name Printable name of the reference.","title":"Examples"},{"location":"reference/dewret/workflow/#methods_9","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#adjoint_4","text":"def adjoint ( self )","title":"adjoint"},{"location":"reference/dewret/workflow/#apart_4","text":"def apart ( self , x = None , ** args ) See the apart function in sympy.polys","title":"apart"},{"location":"reference/dewret/workflow/#args_cnc_4","text":"def args_cnc ( self , cset = False , warn = True , split_1 = True ) Return [commutative factors, non-commutative factors] of self.","title":"args_cnc"},{"location":"reference/dewret/workflow/#explanation_24","text":"self is treated as a Mul and the ordering of the factors is maintained. If cset is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting warn to False. Note: -1 is always separated from a Number unless split_1 is False.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_180","text":"from sympy import symbols, oo A, B = symbols('A B', commutative=0) x, y = symbols('x y') (-2 x y).args_cnc() [[-1, 2, x, y], []] (-2.5 x).args_cnc() [[-1, 2.5, x], []] (-2 x A B y).args_cnc() [[-1, 2, x, y], [A, B]] (-2 x A B y).args_cnc(split_1=False) [[-2, x, y], [A, B]] (-2 x*y).args_cnc(cset=True) [{-1, 2, x, y}, []] The arg is always treated as a Mul: (-2 + x + A).args_cnc() [[], [x - 2 + A]] (-oo).args_cnc() # -oo is a singleton [[-1, oo], []]","title":"Examples"},{"location":"reference/dewret/workflow/#as_base_exp_4","text":"def as_base_exp ( self ) -> 'tuple[Expr, Expr]'","title":"as_base_exp"},{"location":"reference/dewret/workflow/#as_coeff_add_8","text":"def as_coeff_Add ( self , rational = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a summation.","title":"as_coeff_Add"},{"location":"reference/dewret/workflow/#as_coeff_mul_8","text":"def as_coeff_Mul ( self , rational : 'bool' = False ) -> \"tuple['Number', Expr]\" Efficiently extract the coefficient of a product.","title":"as_coeff_Mul"},{"location":"reference/dewret/workflow/#as_coeff_add_9","text":"def as_coeff_add ( self , * deps ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as an Add, a . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of a ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add. if you know self is an Add and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail. if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_add() (3, ()) (3 + x).as_coeff_add() (3, (x,)) (3 + x + y).as_coeff_add(x) (y + 3, (x,)) (3 + y).as_coeff_add(x) (y + 3, ())","title":"as_coeff_add"},{"location":"reference/dewret/workflow/#as_coeff_exponent_4","text":"def as_coeff_exponent ( self , x ) -> 'tuple[Expr, Expr]' c*x**e -> c,e where x can be any symbolic expression.","title":"as_coeff_exponent"},{"location":"reference/dewret/workflow/#as_coeff_mul_9","text":"def as_coeff_mul ( self , * deps , ** kwargs ) -> 'tuple[Expr, tuple[Expr, ...]]' Return the tuple (c, args) where self is written as a Mul, m . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul. if you know self is a Mul and want only the head, use self.args[0]; if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail; if you want to split self into an independent and dependent parts use self.as_independent(*deps) from sympy import S from sympy.abc import x, y (S(3)).as_coeff_mul() (3, ()) (3 x y).as_coeff_mul() (3, (x, y)) (3 x y).as_coeff_mul(x) (3 y, (x,)) (3 y).as_coeff_mul(x) (3*y, ())","title":"as_coeff_mul"},{"location":"reference/dewret/workflow/#as_coefficient_4","text":"def as_coefficient ( self , expr : 'Expr' ) -> 'Expr | None' Extracts symbolic coefficient at the given expression. In other words, this functions separates 'self' into the product of 'expr' and 'expr'-free coefficient. If such separation is not possible it will return None.","title":"as_coefficient"},{"location":"reference/dewret/workflow/#examples_181","text":"from sympy import E, pi, sin, I, Poly from sympy.abc import x E.as_coefficient(E) 1 (2 E).as_coefficient(E) 2 (2 sin(E)*E).as_coefficient(E) Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) (2 E + x E).as_coefficient(E) x + 2 _.args[0] # just want the exact match 2 p = Poly(2 E + x E); p Poly(x E + 2 E, x, E, domain='ZZ') p.coeff_monomial(E) 2 p.nth(0, 1) 2 Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient 2*x is desired then the coeff method should be used.) (2 E x + x).as_coefficient(E) (2 E x + x).coeff(E) 2*x (E*(x + 1) + x).as_coefficient(E) (2 pi I).as_coefficient(pi I) 2 (2 I).as_coefficient(pi*I)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_56","text":"coeff: return sum of terms have a given factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#as_coefficients_dict_4","text":"def as_coefficients_dict ( self , * syms ) Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols syms are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned.","title":"as_coefficients_dict"},{"location":"reference/dewret/workflow/#examples_182","text":"from sympy.abc import a, x, y (3 x + a x + 4).as_coefficients_dict() {1: 4, x: 3, a x: 1} _[a] 0 (3 a x).as_coefficients_dict() {a x: 3} (3 a x).as_coefficients_dict(x) {x: 3 a} (3 a x).as_coefficients_dict(y) {1: 3 a*x}","title":"Examples"},{"location":"reference/dewret/workflow/#as_content_primitive_4","text":"def as_content_primitive ( self , radical = False , clear = True ) This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and Mul(*foo.as_content_primitive()) == foo . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self).","title":"as_content_primitive"},{"location":"reference/dewret/workflow/#examples_183","text":"from sympy import sqrt from sympy.abc import x, y, z eq = 2 + 2 x + 2 y (3 + 3 y) The as_content_primitive function is recursive and retains structure: eq.as_content_primitive() (2, x + 3 y (y + 1) + 1) Integer powers will have Rationals extracted from the base: ((2 + 6 x) 2).as_content_primitive() (4, (3 x + 1) 2) ((2 + 6*x) (2 y)).as_content_primitive() (1, (2 (3 x + 1)) (2 y)) Terms may end up joining once their as_content_primitives are added: ((5 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (11, x (y + 1)) ((3 (x (1 + y)) + 2 x (3 + 3 y))).as_content_primitive() (9, x (y + 1)) ((3 (z (1 + y)) + 2.0 x (3 + 3 y))).as_content_primitive() (1, 6.0 x (y + 1) + 3 z (y + 1)) ((5 (x (1 + y)) + 2 x (3 + 3 y)) 2).as_content_primitive() (121, x 2 (y + 1) 2) ((x (1 + y) + 0.4 x (3 + 3 y)) 2).as_content_primitive() (1, 4.84 x 2*(y + 1) 2) Radical content can also be factored out of the primitive: (2 sqrt(2) + 4 sqrt(10)).as_content_primitive(radical=True) (2, sqrt(2) (1 + 2 sqrt(5))) If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. (x/2 + y).as_content_primitive() (1/2, x + 2*y) (x/2 + y).as_content_primitive(clear=False) (1, x/2 + y)","title":"Examples"},{"location":"reference/dewret/workflow/#as_dummy_4","text":"def as_dummy ( self ) Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned.","title":"as_dummy"},{"location":"reference/dewret/workflow/#examples_184","text":"from sympy import Integral, Symbol from sympy.abc import x r = Symbol('r', real=True) Integral(r, (r, x)).as_dummy() Integral( 0, (_0, x)) .variables[0].is_real is None True r.as_dummy() _r","title":"Examples"},{"location":"reference/dewret/workflow/#notes_25","text":"Any object that has structurally bound variables should have a property, bound_symbols that returns those symbols appearing in the object.","title":"Notes"},{"location":"reference/dewret/workflow/#as_expr_4","text":"def as_expr ( self , * gens ) Convert a polynomial to a SymPy expression.","title":"as_expr"},{"location":"reference/dewret/workflow/#examples_185","text":"from sympy import sin from sympy.abc import x, y f = (x 2 + x*y).as_poly(x, y) f.as_expr() x 2 + x*y sin(x).as_expr() sin(x)","title":"Examples"},{"location":"reference/dewret/workflow/#as_independent_4","text":"def as_independent ( self , * deps , ** hint ) -> 'tuple[Expr, Expr]' A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.: separatevars() to change Mul, Add and Pow (including exp) into Mul .expand(mul=True) to change Add or Mul into Add .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for self of zero regardless of hints. For nonzero self , the returned tuple (i, d) has the following interpretation: i will has no variable that appears in deps d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul) if self is an Add then self = i + d if self is a Mul then self = i*d otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True","title":"as_independent"},{"location":"reference/dewret/workflow/#examples_186","text":"-- self is an Add from sympy import sin, cos, exp from sympy.abc import x, y, z (x + x y).as_independent(x) (0, x y + x) (x + x y).as_independent(y) (x, x y) (2 x sin(x) + y + x + z).as_independent(x) (y + z, 2 x sin(x) + x) (2 x sin(x) + y + x + z).as_independent(x, y) (z, 2 x sin(x) + x + y) -- self is a Mul (x sin(x) cos(y)).as_independent(x) (cos(y), x*sin(x)) non-commutative terms cannot always be separated out when self is a Mul from sympy import symbols n1, n2, n3 = symbols('n1 n2 n3', commutative=False) (n1 + n1 n2).as_independent(n2) (n1, n1 n2) (n2 n1 + n1 n2).as_independent(n2) (0, n1 n2 + n2 n1) (n1 n2 n3).as_independent(n1) (1, n1 n2 n3) (n1 n2 n3).as_independent(n2) (n1, n2 n3) ((x-n1) (x-y)).as_independent(x) (1, (x - y)*(x - n1)) -- self is anything else: (sin(x)).as_independent(x) (1, sin(x)) (sin(x)).as_independent(y) (sin(x), 1) exp(x+y).as_independent(x) (1, exp(x + y)) -- force self to be treated as an Add: (3 x).as_independent(x, as_Add=True) (0, 3 x) -- force self to be treated as a Mul: (3+x).as_independent(x, as_Add=False) (1, x + 3) (-3+x).as_independent(x, as_Add=False) (1, x - 3) Note how the below differs from the above in making the constant on the dep term positive. (y*(-3+x)).as_independent(x) (y, x - 3) -- use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols from sympy import Integral I = Integral(x, (x, 1, 2)) I.has(x) True x in I.free_symbols False I.as_independent(x) == (I, 1) True (I + x).as_independent(x) == (I, x) True Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values from sympy import separatevars, log separatevars(exp(x+y)).as_independent(x) (exp(y), exp(x)) (x + x y).as_independent(y) (x, x y) separatevars(x + x y).as_independent(y) (x, y + 1) (x (1 + y)).as_independent(y) (x, y + 1) (x (1 + y)).expand(mul=True).as_independent(y) (x, x y) a, b=symbols('a b', positive=True) (log(a*b).expand(log=True)).as_independent(b) (log(a), log(b))","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_57","text":"separatevars expand_log sympy.core.add.Add.as_two_terms sympy.core.mul.Mul.as_two_terms as_coeff_mul","title":"See Also"},{"location":"reference/dewret/workflow/#as_leading_term_4","text":"def as_leading_term ( self , * symbols , logx = None , cdir = 0 ) Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value.","title":"as_leading_term"},{"location":"reference/dewret/workflow/#examples_187","text":"from sympy.abc import x (1 + x + x 2).as_leading_term(x) 1 (1/x 2 + x + x 2).as_leading_term(x) x (-2)","title":"Examples"},{"location":"reference/dewret/workflow/#as_numer_denom_4","text":"def as_numer_denom ( self ) -> 'tuple[Expr, Expr]' Return the numerator and the denominator of an expression. expression -> a/b -> a, b This is just a stub that should be defined by an object's class methods to get anything else.","title":"as_numer_denom"},{"location":"reference/dewret/workflow/#see-also_58","text":"normal: return a/b instead of (a, b)","title":"See Also"},{"location":"reference/dewret/workflow/#as_ordered_factors_4","text":"def as_ordered_factors ( self , order = None ) Return list of ordered factors (if Mul) else [self].","title":"as_ordered_factors"},{"location":"reference/dewret/workflow/#as_ordered_terms_4","text":"def as_ordered_terms ( self , order = None , data = False ) Transform an expression to an ordered list of terms.","title":"as_ordered_terms"},{"location":"reference/dewret/workflow/#examples_188","text":"from sympy import sin, cos from sympy.abc import x (sin(x) 2*cos(x) + sin(x) 2 + 1).as_ordered_terms() [sin(x) 2*cos(x), sin(x) 2, 1]","title":"Examples"},{"location":"reference/dewret/workflow/#as_poly_4","text":"def as_poly ( self , * gens , ** args ) Converts self to a polynomial or returns None .","title":"as_poly"},{"location":"reference/dewret/workflow/#explanation_25","text":"from sympy import sin from sympy.abc import x, y print((x 2 + x*y).as_poly()) Poly(x 2 + x*y, x, y, domain='ZZ') print((x 2 + x*y).as_poly(x, y)) Poly(x 2 + x*y, x, y, domain='ZZ') print((x**2 + sin(y)).as_poly(x, y)) None","title":"Explanation"},{"location":"reference/dewret/workflow/#as_powers_dict_4","text":"def as_powers_dict ( self ) Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary.","title":"as_powers_dict"},{"location":"reference/dewret/workflow/#see-also_59","text":"as_ordered_factors: An alternative for noncommutative applications, returning an ordered list of factors. args_cnc: Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors.","title":"See Also"},{"location":"reference/dewret/workflow/#as_real_imag_4","text":"def as_real_imag ( self , deep = True , ** hints ) Performs complex expansion on 'self' and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. from sympy import symbols, I x, y = symbols('x,y', real=True) (x + y*I).as_real_imag() (x, y) from sympy.abc import z, w (z + w*I).as_real_imag() (re(z) - im(w), re(w) + im(z))","title":"as_real_imag"},{"location":"reference/dewret/workflow/#as_set_4","text":"def as_set ( self ) Rewrites Boolean expression in terms of real sets.","title":"as_set"},{"location":"reference/dewret/workflow/#examples_189","text":"from sympy import Symbol, Eq, Or, And x = Symbol('x', real=True) Eq(x, 0).as_set() {0} (x > 0).as_set() Interval.open(0, oo) And(-2 < x, x < 2).as_set() Interval.open(-2, 2) Or(x < -2, 2 < x).as_set() Union(Interval.open(-oo, -2), Interval.open(2, oo))","title":"Examples"},{"location":"reference/dewret/workflow/#as_terms_4","text":"def as_terms ( self ) Transform an expression to a list of terms.","title":"as_terms"},{"location":"reference/dewret/workflow/#aseries_4","text":"def aseries ( self , x = None , n = 6 , bound = 0 , hir = False ) Asymptotic Series expansion of self. This is equivalent to self.series(x, oo, n) .","title":"aseries"},{"location":"reference/dewret/workflow/#parameters_24","text":"self : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. hir : Boolean Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. bound : Value, Integer Use the bound parameter to give limit on rewriting coefficients in its normalised form.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_190","text":"from sympy import sin, exp from sympy.abc import x e = sin(1/x + exp(-x)) - sin(1/x) e.aseries(x) (1/(24 x 4) - 1/(2 x 2) + 1 + O(x (-6), (x, oo)))*exp(-x) e.aseries(x, n=3, hir=True) -exp(-2 x) sin(1/x)/2 + exp(-x) cos(1/x) + O(exp(-3 x), (x, oo)) e = exp(exp(x)/(1 - 1/x)) e.aseries(x) exp(exp(x)/(1 - 1/x)) e.aseries(x, bound=3) # doctest: +SKIP exp(exp(x)/x 2) exp(exp(x)/x) exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x 2)*exp(exp(x)) For rational expressions this method may return original expression without the Order term. (1/x).aseries(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_12","text":"Expr Asymptotic series expansion of the expression.","title":"Returns"},{"location":"reference/dewret/workflow/#notes_26","text":"This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either O(x ** (-n)) or O(w ** (-n)) where w belongs to the most rapidly varying expression of self .","title":"Notes"},{"location":"reference/dewret/workflow/#references_8","text":".. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. .. [2] Gruntz thesis - p90 .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion","title":"References"},{"location":"reference/dewret/workflow/#see-also_60","text":"Expr.aseries: See the docstring of this function for complete details of this wrapper.","title":"See Also"},{"location":"reference/dewret/workflow/#atoms_4","text":"def atoms ( self , * types : 'Tbasic | type[Tbasic]' ) -> 'set[Basic] | set[Tbasic]' Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below.","title":"atoms"},{"location":"reference/dewret/workflow/#examples_191","text":"from sympy import I, pi, sin from sympy.abc import x, y (1 + x + 2 sin(y + I pi)).atoms() {1, 2, I, pi, x, y} If one or more types are given, the results will contain only those types of atoms. from sympy import Number, NumberSymbol, Symbol (1 + x + 2 sin(y + I pi)).atoms(Symbol) {x, y} (1 + x + 2 sin(y + I pi)).atoms(Number) {1, 2} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol) {1, 2, pi} (1 + x + 2 sin(y + I pi)).atoms(Number, NumberSymbol, I) {1, 2, I, pi} Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: (1 + x + 2 sin(y + I pi)).atoms(x) # x is a Symbol {x, y} Be careful to check your assumptions when using the implicit option since S(1).is_Integer = True but type(S(1)) is One , a special type of SymPy atom, while type(S(2)) is type Integer and will find all integers in an expression: from sympy import S (1 + x + 2 sin(y + I pi)).atoms(S(1)) {1} (1 + x + 2 sin(y + I pi)).atoms(S(2)) {1, 2} Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/ init .py) can be listed as an argument and those types of \"atoms\" as found in scanning the arguments of the expression recursively: from sympy import Function, Mul from sympy.core.function import AppliedUndef f = Function('f') (1 + f(x) + 2 sin(y + I pi)).atoms(Function) {f(x), sin(y + I pi)} (1 + f(x) + 2 sin(y + I*pi)).atoms(AppliedUndef) {f(x)} (1 + x + 2 sin(y + I pi)).atoms(Mul) {I pi, 2 sin(y + I*pi)}","title":"Examples"},{"location":"reference/dewret/workflow/#cancel_4","text":"def cancel ( self , * gens , ** args ) See the cancel function in sympy.polys","title":"cancel"},{"location":"reference/dewret/workflow/#coeff_4","text":"def coeff ( self , x : 'Expr' , n = 1 , right = False , _first = True ) Returns the coefficient from the term(s) containing x**n . If n is zero then all terms independent of x will be returned.","title":"coeff"},{"location":"reference/dewret/workflow/#explanation_26","text":"When x is noncommutative, the coefficient to the left (default) or right of x can be returned. The keyword 'right' is ignored when x is commutative.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_192","text":"from sympy import symbols from sympy.abc import x, y, z You can select terms that have an explicit negative in front of them: (-x + 2 y).coeff(-1) x (x - 2 y).coeff(-1) 2*y You can select terms with no Rational coefficient: (x + 2 y).coeff(1) x (3 + 2 x + 4 x *2).coeff(1) 0 You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): (3 + 2 x + 4 x 2).coeff(x, 0) 3 eq = ((x + 1) 3).expand() + 1 eq x 3 + 3*x 2 + 3*x + 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 2] eq -= 2 [eq.coeff(x, i) for i in reversed(range(4))] [1, 3, 3, 0] You can select terms that have a numerical term in front of them: (-x - 2 y).coeff(2) -y from sympy import sqrt (x + sqrt(2) x).coeff(sqrt(2)) x The matching is exact: (3 + 2 x + 4 x 2).coeff(x) 2 (3 + 2 x + 4 x 2).coeff(x 2) 4 (3 + 2 x + 4 x 2).coeff(x 3) 0 (z*(x + y) 2).coeff((x + y) 2) z (z*(x + y) 2).coeff(x + y) 0 In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: (x + z (x + x y)).coeff(x) 1 If such factoring is desired, factor_terms can be used first: from sympy import factor_terms factor_terms(x + z (x + x y)).coeff(x) z*(y + 1) + 1 n, m, o = symbols('n m o', commutative=False) n.coeff(n) 1 (3 n).coeff(n) 3 (n m + m n m).coeff(n) # = (1 + m) n m 1 + m (n m + m n m).coeff(n, right=True) # = (1 + m) n*m m If there is more than one possible coefficient 0 is returned: (n m + m n).coeff(n) 0 If there is only one possible coefficient, it is returned: (n m + x m n).coeff(m n) x (n m + x m n).coeff(m n, right=1) 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_61","text":"as_coefficient: separate the expression into a coefficient and factor as_coeff_Add: separate the additive constant from an expression as_coeff_Mul: separate the multiplicative constant from an expression as_independent: separate x-dependent terms/factors from others sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used","title":"See Also"},{"location":"reference/dewret/workflow/#collect_4","text":"def collect ( self , syms , func = None , evaluate = True , exact = False , distribute_order_term = True ) See the collect function in sympy.simplify","title":"collect"},{"location":"reference/dewret/workflow/#combsimp_4","text":"def combsimp ( self ) See the combsimp function in sympy.simplify","title":"combsimp"},{"location":"reference/dewret/workflow/#compare_4","text":"def compare ( self , other ) Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the ordering_of_classes then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned.","title":"compare"},{"location":"reference/dewret/workflow/#examples_193","text":"from sympy.abc import x, y x.compare(y) -1 x.compare(x) 0 y.compare(x) 1","title":"Examples"},{"location":"reference/dewret/workflow/#conjugate_4","text":"def conjugate ( self ) Returns the complex conjugate of 'self'.","title":"conjugate"},{"location":"reference/dewret/workflow/#copy_4","text":"def copy ( self )","title":"copy"},{"location":"reference/dewret/workflow/#could_extract_minus_sign_4","text":"def could_extract_minus_sign ( self ) -> 'bool' Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False.","title":"could_extract_minus_sign"},{"location":"reference/dewret/workflow/#examples_194","text":"from sympy.abc import x, y e = x - y {i.could_extract_minus_sign() for i in (e, -e)} {False, True} Though the y - x is considered like -(x - y) , since it is in a product without a leading factor of -1, the result is false below: (x*(y - x)).could_extract_minus_sign() False To put something in canonical form wrt to sign, use signsimp : from sympy import signsimp signsimp(x (y - x)) -x (x - y) _.could_extract_minus_sign() True","title":"Examples"},{"location":"reference/dewret/workflow/#count_4","text":"def count ( self , query ) Count the number of matching subexpressions.","title":"count"},{"location":"reference/dewret/workflow/#count_ops_4","text":"def count_ops ( self , visual = False ) Wrapper for count_ops that returns the operation count.","title":"count_ops"},{"location":"reference/dewret/workflow/#diff_4","text":"def diff ( self , * symbols , ** assumptions )","title":"diff"},{"location":"reference/dewret/workflow/#dir_4","text":"def dir ( self , x , cdir )","title":"dir"},{"location":"reference/dewret/workflow/#doit_4","text":"def doit ( self , ** hints ) Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via 'hints' or unless the 'deep' hint was set to 'False'. from sympy import Integral from sympy.abc import x 2 Integral(x, x) 2 Integral(x, x) (2 Integral(x, x)).doit() x *2 (2 Integral(x, x)).doit(deep=False) 2 Integral(x, x)","title":"doit"},{"location":"reference/dewret/workflow/#dummy_eq_4","text":"def dummy_eq ( self , other , symbol = None ) Compare two expressions and handle dummy symbols.","title":"dummy_eq"},{"location":"reference/dewret/workflow/#examples_195","text":"from sympy import Dummy from sympy.abc import x, y u = Dummy('u') (u 2 + 1).dummy_eq(x 2 + 1) True (u 2 + 1) == (x 2 + 1) False (u 2 + y).dummy_eq(x 2 + y, x) True (u 2 + y).dummy_eq(x 2 + y, y) False","title":"Examples"},{"location":"reference/dewret/workflow/#equals_4","text":"def equals ( self , other , failing_expression = False ) Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None.","title":"equals"},{"location":"reference/dewret/workflow/#explanation_27","text":"If self is a Number (or complex number) that is not zero, then the result is False. If self is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False.","title":"Explanation"},{"location":"reference/dewret/workflow/#evalf_4","text":"def evalf ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"evalf"},{"location":"reference/dewret/workflow/#parameters_25","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_27","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#expand_4","text":"def expand ( self , deep = True , modulus = None , power_base = True , power_exp = True , mul = True , log = True , multinomial = True , basic = True , ** hints ) Expand an expression using hints. See the docstring of the expand() function in sympy.core.function for more information.","title":"expand"},{"location":"reference/dewret/workflow/#extract_additively_4","text":"def extract_additively ( self , c ) Return self - c if it's possible to subtract c from self and make all matching coefficients move towards zero, else return None.","title":"extract_additively"},{"location":"reference/dewret/workflow/#examples_196","text":"from sympy.abc import x, y e = 2 x + 3 e.extract_additively(x + 1) x + 2 e.extract_additively(3 x) e.extract_additively(4) (y (x + 1)).extract_additively(x + 1) ((x + 1) (x + 2 y + 1) + 3).extract_additively(x + 1) (x + 1) (x + 2*y) + 3","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_62","text":"extract_multiplicatively coeff as_coefficient","title":"See Also"},{"location":"reference/dewret/workflow/#extract_branch_factor_4","text":"def extract_branch_factor ( self , allow_half = False ) Try to write self as exp_polar(2*pi*I*n)*z in a nice way. Return (z, n). from sympy import exp_polar, I, pi from sympy.abc import x, y exp_polar(I pi).extract_branch_factor() (exp_polar(I pi), 0) exp_polar(2 I pi).extract_branch_factor() (1, 1) exp_polar(-pi I).extract_branch_factor() (exp_polar(I pi), -1) exp_polar(3 pi I + x).extract_branch_factor() (exp_polar(x + I pi), 1) (y exp_polar(-5 pi I) exp_polar(3 pi I + 2 pi x)).extract_branch_factor() (y exp_polar(2 pi x), -1) exp_polar(-I pi/2).extract_branch_factor() (exp_polar(-I pi/2), 0) If allow_half is True, also extract exp_polar(I*pi): exp_polar(I pi).extract_branch_factor(allow_half=True) (1, 1/2) exp_polar(2 I pi).extract_branch_factor(allow_half=True) (1, 1) exp_polar(3 I pi).extract_branch_factor(allow_half=True) (1, 3/2) exp_polar(-I pi).extract_branch_factor(allow_half=True) (1, -1/2)","title":"extract_branch_factor"},{"location":"reference/dewret/workflow/#extract_multiplicatively_4","text":"def extract_multiplicatively ( self , c : 'Expr' ) -> 'Expr | None' Return None if it's not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self.","title":"extract_multiplicatively"},{"location":"reference/dewret/workflow/#examples_197","text":"from sympy import symbols, Rational x, y = symbols('x,y', real=True) ((x y) 3).extract_multiplicatively(x 2 * y) x y**2 ((x y) 3).extract_multiplicatively(x *4 * y) (2*x).extract_multiplicatively(2) x (2*x).extract_multiplicatively(3) (Rational(1, 2)*x).extract_multiplicatively(3) x/6","title":"Examples"},{"location":"reference/dewret/workflow/#factor_4","text":"def factor ( self , * gens , ** args ) See the factor() function in sympy.polys.polytools","title":"factor"},{"location":"reference/dewret/workflow/#find_4","text":"def find ( self , query , group = False ) Find all subexpressions matching a query.","title":"find"},{"location":"reference/dewret/workflow/#find_field_4","text":"def find_field ( self : 'FieldableProtocol' , field : 'str | int' , fallback_type : 'type | None' = None , ** init_kwargs : 'Any' ) -> 'Reference[Any]' Field within the reference, if possible. Parameters: Name Type Description Default field None the field to search for. None fallback_type None the type to use if we do not know a more specific one. None **init_kwargs None arguments to use for constructing a new reference (via __make_reference__ ). None Returns: Type Description None A field-specific version of this reference.","title":"find_field"},{"location":"reference/dewret/workflow/#fourier_series_4","text":"def fourier_series ( self , limits = None ) Compute fourier sine/cosine series of self. See the docstring of the :func: fourier_series in sympy.series.fourier for more information.","title":"fourier_series"},{"location":"reference/dewret/workflow/#fps_4","text":"def fps ( self , x = None , x0 = 0 , dir = 1 , hyper = True , order = 4 , rational = True , full = False ) Compute formal power power series of self. See the docstring of the :func: fps function in sympy.series.formal for more information.","title":"fps"},{"location":"reference/dewret/workflow/#gammasimp_4","text":"def gammasimp ( self ) See the gammasimp function in sympy.simplify","title":"gammasimp"},{"location":"reference/dewret/workflow/#geto_4","text":"def getO ( self ) -> 'Expr | None' Returns the additive O(..) symbol if there is one, else None.","title":"getO"},{"location":"reference/dewret/workflow/#getn_4","text":"def getn ( self ) Returns the order of the expression.","title":"getn"},{"location":"reference/dewret/workflow/#explanation_28","text":"The order is determined either from the O(...) term. If there is no O(...) term, it returns None.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_198","text":"from sympy import O from sympy.abc import x (1 + x + O(x**2)).getn() 2 (1 + x).getn()","title":"Examples"},{"location":"reference/dewret/workflow/#has_4","text":"def has ( self , * patterns ) Test whether any subexpression matches any of the patterns.","title":"has"},{"location":"reference/dewret/workflow/#examples_199","text":"from sympy import sin from sympy.abc import x, y, z (x 2 + sin(x*y)).has(z) False (x 2 + sin(x*y)).has(x, y, z) True x.has(x) True Note has is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: from sympy import Interval i = Interval.Lopen(0, 5); i Interval.Lopen(0, 5) i.args (0, 5, True, False) i.has(4) # there is no \"4\" in the arguments False i.has(0) # there is a \"0\" in the arguments True Instead, use contains to determine whether a number is in the interval or not: i.contains(4) True i.contains(0) False Note that expr.has(*patterns) is exactly equivalent to any(expr.has(p) for p in patterns) . In particular, False is returned when the list of patterns is empty. x.has() False","title":"Examples"},{"location":"reference/dewret/workflow/#has_free_4","text":"def has_free ( self , * patterns ) Return True if self has object(s) x as a free expression else False.","title":"has_free"},{"location":"reference/dewret/workflow/#examples_200","text":"from sympy import Integral, Function from sympy.abc import x, y f = Function('f') g = Function('g') expr = Integral(f(x), (f(x), 1, g(y))) expr.free_symbols {y} expr.has_free(g(y)) True expr.has_free(*(x, f(x))) False This works for subexpressions and types, too: expr.has_free(g) True (x + y + 1).has_free(y + 1) True","title":"Examples"},{"location":"reference/dewret/workflow/#has_xfree_4","text":"def has_xfree ( self , s : 'set[Basic]' ) Return True if self has any of the patterns in s as a free argument, else False. This is like Basic.has_free but this will only report exact argument matches.","title":"has_xfree"},{"location":"reference/dewret/workflow/#examples_201","text":"from sympy import Function from sympy.abc import x, y f = Function('f') f(x).has_xfree({f}) False f(x).has_xfree({f(x)}) True f(x + 1).has_xfree({x}) True f(x + 1).has_xfree({x + 1}) True f(x + y + 1).has_xfree({x + 1}) False","title":"Examples"},{"location":"reference/dewret/workflow/#integrate_4","text":"def integrate ( self , * args , ** kwargs ) See the integrate function in sympy.integrals","title":"integrate"},{"location":"reference/dewret/workflow/#invert_4","text":"def invert ( self , g , * gens , ** args ) Return the multiplicative inverse of self mod g where self (and g ) may be symbolic expressions).","title":"invert"},{"location":"reference/dewret/workflow/#see-also_63","text":"sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert","title":"See Also"},{"location":"reference/dewret/workflow/#is_algebraic_expr_4","text":"def is_algebraic_expr ( self , * syms ) This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"algebraic expressions\" with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation.","title":"is_algebraic_expr"},{"location":"reference/dewret/workflow/#examples_202","text":"from sympy import Symbol, sqrt x = Symbol('x', real=True) sqrt(1 + x).is_rational_function() False sqrt(1 + x).is_algebraic_expr() True This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. from sympy import exp, factor a = sqrt(exp(x)* 2 + 2 exp(x) + 1)/(exp(x) + 1) a.is_algebraic_expr(x) False factor(a).is_algebraic_expr() True","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_64","text":"is_rational_function","title":"See Also"},{"location":"reference/dewret/workflow/#references_9","text":".. [1] https://en.wikipedia.org/wiki/Algebraic_expression","title":"References"},{"location":"reference/dewret/workflow/#is_constant_4","text":"def is_constant ( self , * wrt , ** flags ) Return True if self is constant, False if not, or None if the constancy could not be determined conclusively.","title":"is_constant"},{"location":"reference/dewret/workflow/#explanation_29","text":"If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if wrt is different than the free symbols. 2) differentiation with respect to variables in 'wrt' (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag failing_number is True -- in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing.","title":"Explanation"},{"location":"reference/dewret/workflow/#examples_203","text":"from sympy import cos, sin, Sum, S, pi from sympy.abc import a, n, x, y x.is_constant() False S(2).is_constant() True Sum(x, (x, 1, 10)).is_constant() True Sum(x, (x, 1, n)).is_constant() False Sum(x, (x, 1, n)).is_constant(y) True Sum(x, (x, 1, n)).is_constant(n) False Sum(x, (x, 1, n)).is_constant(x) True eq = a cos(x) 2 + a sin(x)**2 - a eq.is_constant() True eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0 True (0 x).is_constant() False x.is_constant() False (x x).is_constant() False one = cos(x) 2 + sin(x) 2 one.is_constant() True ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1 True","title":"Examples"},{"location":"reference/dewret/workflow/#is_hypergeometric_4","text":"def is_hypergeometric ( self , k )","title":"is_hypergeometric"},{"location":"reference/dewret/workflow/#is_meromorphic_4","text":"def is_meromorphic ( self , x , a ) This tests whether an expression is meromorphic as a function of the given symbol x at the point a . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis.","title":"is_meromorphic"},{"location":"reference/dewret/workflow/#examples_204","text":"from sympy import zoo, log, sin, sqrt from sympy.abc import x f = 1/x 2 + 1 - 2*x 3 f.is_meromorphic(x, 0) True f.is_meromorphic(x, 1) True f.is_meromorphic(x, zoo) True g = x**log(3) g.is_meromorphic(x, 0) False g.is_meromorphic(x, 1) True g.is_meromorphic(x, zoo) False h = sin(1/x) x *2 h.is_meromorphic(x, 0) False h.is_meromorphic(x, 1) True h.is_meromorphic(x, zoo) True Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. log(x).is_meromorphic(x, -1) True log(x).is_meromorphic(x, 0) False sqrt(x).is_meromorphic(x, -1) True sqrt(x).is_meromorphic(x, 0) False","title":"Examples"},{"location":"reference/dewret/workflow/#is_polynomial_4","text":"def is_polynomial ( self , * syms ) Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are \"polynomials\" with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol('z', polynomial=True).","title":"is_polynomial"},{"location":"reference/dewret/workflow/#examples_205","text":"from sympy import Symbol, Function x = Symbol('x') ((x 2 + 1) 4).is_polynomial(x) True ((x 2 + 1) 4).is_polynomial() True (2 x + 1).is_polynomial(x) False (2 x + 1).is_polynomial(2**x) True f = Function('f') (f(x) + 1).is_polynomial(x) False (f(x) + 1).is_polynomial(f(x)) True (1/f(x) + 1).is_polynomial(f(x)) False n = Symbol('n', nonnegative=True, integer=True) (x**n + 1).is_polynomial(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. from sympy import sqrt, factor, cancel y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1) a.is_polynomial(y) False factor(a) y + 1 factor(a).is_polynomial(y) True b = (y* 2 + 2 y + 1)/(y + 1) b.is_polynomial(y) False cancel(b) y + 1 cancel(b).is_polynomial(y) True See also .is_rational_function()","title":"Examples"},{"location":"reference/dewret/workflow/#is_rational_function_4","text":"def is_rational_function ( self , * syms ) Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are \"rational functions\" with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol('z', rational_function=True).","title":"is_rational_function"},{"location":"reference/dewret/workflow/#examples_206","text":"from sympy import Symbol, sin from sympy.abc import x, y (x/y).is_rational_function() True (x**2).is_rational_function() True (x/sin(y)).is_rational_function(y) False n = Symbol('n', integer=True) (x**n + 1).is_rational_function(x) False This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. from sympy import sqrt, factor y = Symbol('y', positive=True) a = sqrt(y* 2 + 2 y + 1)/y a.is_rational_function(y) False factor(a) (y + 1)/y factor(a).is_rational_function(y) True See also is_algebraic_expr().","title":"Examples"},{"location":"reference/dewret/workflow/#is_same_4","text":"def is_same ( a , b , approx = None ) Return True if a and b are structurally the same, else False. If approx is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).","title":"is_same"},{"location":"reference/dewret/workflow/#examples_207","text":"In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: from sympy import S 2.0 == S(2) False 0.5 == S.Half False By supplying a function with which to compare two numbers, such differences can be ignored. e.g. equal_valued will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. from sympy import Float from sympy.core.numbers import equal_valued (S.Half/4).is_same(Float(0.125, 1), equal_valued) True Float(1, 2).is_same(Float(1, 10), equal_valued) True But decimals without a power of 2 denominator will compare as not being the same. Float(0.1, 9).is_same(Float(0.1, 10), equal_valued) False But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: import math Float(0.1, 9).is_same(Float(0.1, 10), math.isclose) True Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. from sympy import eye, Basic eye(1) == S(eye(1)) # mutable vs immutable True Basic.is_same(eye(1), S(eye(1))) False","title":"Examples"},{"location":"reference/dewret/workflow/#leadterm_4","text":"def leadterm ( self , x , logx = None , cdir = 0 ) Returns the leading term a x *b as a tuple (a, b).","title":"leadterm"},{"location":"reference/dewret/workflow/#examples_208","text":"from sympy.abc import x (1+x+x 2).leadterm(x) (1, 0) (1/x 2+x+x**2).leadterm(x) (1, -2)","title":"Examples"},{"location":"reference/dewret/workflow/#limit_4","text":"def limit ( self , x , xlim , dir = '+' ) Compute limit x->xlim.","title":"limit"},{"location":"reference/dewret/workflow/#lseries_4","text":"def lseries ( self , x = None , x0 = 0 , dir = '+' , logx = None , cdir = 0 ) Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series:: for term in sin(x).lseries(x): print term The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the \"n\" parameter. See also nseries().","title":"lseries"},{"location":"reference/dewret/workflow/#match_4","text":"def match ( self , pattern , old = False ) Pattern matching. Wild symbols match all. Return None when expression (self) does not match with pattern. Otherwise return a dictionary such that:: pattern.xreplace(self.match(pattern)) == self","title":"match"},{"location":"reference/dewret/workflow/#examples_209","text":"from sympy import Wild, Sum from sympy.abc import x, y p = Wild(\"p\") q = Wild(\"q\") r = Wild(\"r\") e = (x+y) (x+y) e.match(p p) {p_: x + y} e.match(p q) {p_: x + y, q_: x + y} e = (2*x) 2 e.match(p q r) {p_: 4, q_: x, r_: 2} (p q r).xreplace(e.match(p*q r)) 4 x *2 Since match is purely structural expressions that are equivalent up to bound symbols will not match: print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))) None An expression with bound symbols can be matched if the pattern uses a distinct Wild for each bound symbol: Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p))) {p_: 2, q_: x} The old flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless old=True : (x - 2).match(p - x, old=True) {p_: 2 x - 2} (2/x).match(p x, old=True) {p_: 2/x**2}","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_65","text":"matches: pattern.matches(expr) is the same as expr.match(pattern) xreplace: exact structural replacement replace: structural replacement with pattern matching Wild: symbolic placeholders for expressions in pattern matching","title":"See Also"},{"location":"reference/dewret/workflow/#matches_4","text":"def matches ( self , expr , repl_dict = None , old = False ) Helper method for match() that looks for a match between Wild symbols in self and expressions in expr.","title":"matches"},{"location":"reference/dewret/workflow/#examples_210","text":"from sympy import symbols, Wild, Basic a, b, c = symbols('a b c') x = Wild('x') Basic(a + x, x).matches(Basic(a + b, c)) is None True Basic(a + x, x).matches(Basic(a + b + c, b + c)) {x_: b + c}","title":"Examples"},{"location":"reference/dewret/workflow/#n_4","text":"def n ( self , n = 15 , subs = None , maxn = 100 , chop = False , strict = False , quad = None , verbose = False ) Evaluate the given formula to an accuracy of n digits.","title":"n"},{"location":"reference/dewret/workflow/#parameters_26","text":"subs : dict, optional Substitute numerical values for symbols, e.g. subs={x:3, y:1+pi} . The substitutions must be given as a dictionary. maxn : int, optional Allow a maximum temporary working precision of maxn digits. chop : bool or number, optional Specifies how to replace tiny real or imaginary parts in subresults by exact zeros. When ``True`` the chop value defaults to standard precision. Otherwise the chop value is used to determine the magnitude of \"small\" for purposes of chopping. >>> from sympy import N >>> x = 1e-4 >>> N(x, chop=True) 0.000100000000000000 >>> N(x, chop=1e-5) 0.000100000000000000 >>> N(x, chop=1e-4) 0 strict : bool, optional Raise PrecisionExhausted if any subresult fails to evaluate to full accuracy, given the available maxprec. quad : str, optional Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature is used. For oscillatory integrals on an infinite interval, try quad='osc' . verbose : bool, optional Print debug information.","title":"Parameters"},{"location":"reference/dewret/workflow/#notes_28","text":"When Floats are naively substituted into an expression, precision errors may adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what happens in the following: from sympy.abc import x, y, z values = {x: 1e16, y: 1, z: 1e16} (x + y - z).subs(values) 0 Using the subs argument for evalf is the accurate way to evaluate such an expression: (x + y - z).evalf(subs=values) 1.00000000000000","title":"Notes"},{"location":"reference/dewret/workflow/#normal_4","text":"def normal ( self ) Return the expression as a fraction. expression -> a/b","title":"normal"},{"location":"reference/dewret/workflow/#see-also_66","text":"as_numer_denom: return (a, b) instead of a/b","title":"See Also"},{"location":"reference/dewret/workflow/#nseries_4","text":"def nseries ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is called. This calculates \"n\" terms in the innermost expressions and then builds up the final series just by \"cross-multiplying\" everything out. The optional logx parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage -- it's fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage -- you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. See also lseries().","title":"nseries"},{"location":"reference/dewret/workflow/#examples_211","text":"from sympy import sin, log, Symbol from sympy.abc import x, y sin(x).nseries(x, 0, 6) x - x 3/6 + x 5/120 + O(x 6) log(x+1).nseries(x, 0, 5) x - x 2/2 + x 3/3 - x 4/4 + O(x**5) Handling of the logx parameter --- in the following example the expansion fails since sin does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): e = sin(log(x)) e.nseries(x, 0, 6) Traceback (most recent call last): ... PoleError: ... ... logx = Symbol('logx') e.nseries(x, 0, 6, logx=logx) sin(logx) In the following example, the expansion works but only returns self unless the logx parameter is used: e = x y e.nseries(x, 0, 2) x y e.nseries(x, 0, 2, logx=logx) exp(logx*y)","title":"Examples"},{"location":"reference/dewret/workflow/#nsimplify_4","text":"def nsimplify ( self , constants = (), tolerance = None , full = False ) See the nsimplify function in sympy.simplify","title":"nsimplify"},{"location":"reference/dewret/workflow/#powsimp_4","text":"def powsimp ( self , * args , ** kwargs ) See the powsimp function in sympy.simplify","title":"powsimp"},{"location":"reference/dewret/workflow/#primitive_4","text":"def primitive ( self ) -> 'tuple[Number, Expr]' Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float).","title":"primitive"},{"location":"reference/dewret/workflow/#examples_212","text":"from sympy.abc import x (3 (x + 1) 2).primitive() (3, (x + 1) 2) a = (6 x + 2); a.primitive() (2, 3 x + 1) b = (x/2 + 3); b.primitive() (1/2, x + 6) (a b).primitive() == (1, a*b) True","title":"Examples"},{"location":"reference/dewret/workflow/#radsimp_4","text":"def radsimp ( self , ** kwargs ) See the radsimp function in sympy.simplify","title":"radsimp"},{"location":"reference/dewret/workflow/#ratsimp_4","text":"def ratsimp ( self ) See the ratsimp function in sympy.simplify","title":"ratsimp"},{"location":"reference/dewret/workflow/#rcall_4","text":"def rcall ( self , * args ) Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: (x+Lambda(y, 2*y))(z) == x+2*z , however, you can use: from sympy import Lambda from sympy.abc import x, y, z (x + Lambda(y, 2 y)).rcall(z) x + 2 z","title":"rcall"},{"location":"reference/dewret/workflow/#refine_4","text":"def refine ( self , assumption = True ) See the refine function in sympy.assumptions","title":"refine"},{"location":"reference/dewret/workflow/#removeo_4","text":"def removeO ( self ) -> 'Expr' Removes the additive O(..) symbol if there is one","title":"removeO"},{"location":"reference/dewret/workflow/#replace_4","text":"def replace ( self , query , value , map = False , simultaneous = True , exact = None ) -> 'Basic' Replace matching subexpressions of self with value . If map = True then also return the mapping {old: new} where old was a sub-expression found with query and new is the replacement value for it. If the expression itself does not match the query, then the returned value will be self.xreplace(map) otherwise it should be self.subs(ordered(map.items())) . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below:","title":"replace"},{"location":"reference/dewret/workflow/#examples_213","text":"Initial setup from sympy import log, sin, cos, tan, Wild, Mul, Add from sympy.abc import x, y f = log(sin(x)) + tan(sin(x**2)) 1.1. type -> type obj.replace(type, newtype) When object of type ``type`` is found, replace it with the result of passing its argument(s) to ``newtype``. >>> f.replace(sin, cos) log(cos(x)) + tan(cos(x**2)) >>> sin(x).replace(sin, cos, map=True) (cos(x), {sin(x): cos(x)}) >>> (x*y).replace(Mul, Add) x + y 1.2. type -> func obj.replace(type, func) When object of type ``type`` is found, apply ``func`` to its argument(s). ``func`` must be written to handle the number of arguments of ``type``. >>> f.replace(sin, lambda arg: sin(2*arg)) log(sin(2*x)) + tan(sin(2*x**2)) >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args))) sin(2*x*y) 2.1. pattern -> expr obj.replace(pattern(wild), expr(wild)) Replace subexpressions matching ``pattern`` with the expression written in terms of the Wild symbols in ``pattern``. >>> a, b = map(Wild, 'ab') >>> f.replace(sin(a), tan(a)) log(tan(x)) + tan(tan(x**2)) >>> f.replace(sin(a), tan(a/2)) log(tan(x/2)) + tan(tan(x**2/2)) >>> f.replace(sin(a), a) log(x) + tan(x**2) >>> (x*y).replace(a*x, a) y Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: >>> (2*x + y).replace(a*x + b, b - a) y - 2 >>> (2*x).replace(a*x + b, b - a) 2*x When set to False, the results may be non-intuitive: >>> (2*x).replace(a*x + b, b - a, exact=False) 2/x 2.2. pattern -> func obj.replace(pattern(wild), lambda wild: expr(wild)) All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: >>> f.replace(sin(a), lambda a: sin(2*a)) log(sin(2*x)) + tan(sin(2*x**2)) 3.1. func -> func obj.replace(filter, func) Replace subexpression ``e`` with ``func(e)`` if ``filter(e)`` is True. >>> g = 2*sin(x**3) >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2) 4*sin(x**9) The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. >>> e = x*(x*y + 1) >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x) 2*x*(2*x*y + 1) When matching a single symbol, exact will default to True, but this may or may not be the behavior that is desired: Here, we want exact=False : from sympy import Function f = Function('f') e = f(1) + f(0) q = f(a), lambda a: f(a + 1) e.replace( q, exact=False) f(1) + f(2) e.replace( q, exact=True) f(0) + f(2) But here, the nature of matching makes selecting the right setting tricky: e = x (1 + y) (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=False) x (x (1 + y)).replace(x (1 + a), lambda a: x -a, exact=True) x (-x - y + 1) (x y).replace(x (1 + a), lambda a: x -a, exact=False) x (x y).replace(x (1 + a), lambda a: x -a, exact=True) x**(1 - y) It is probably better to use a different form of the query that describes the target expression more precisely: (1 + x (1 + y)).replace( ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1, ... lambda x: x.base (1 - (x.exp - 1))) ... x**(1 - y) + 1","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_67","text":"subs: substitution of subexpressions as defined by the objects themselves. xreplace: exact node replacement in expr tree; also capable of using matching rules","title":"See Also"},{"location":"reference/dewret/workflow/#rewrite_4","text":"def rewrite ( self , * args , deep = True , ** hints ) Rewrite self using a defined rule. Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten.","title":"rewrite"},{"location":"reference/dewret/workflow/#parameters_27","text":"args : Expr A rule , or pattern and rule . - pattern is a type or an iterable of types. - rule can be any object. deep : bool, optional If True , subexpressions are recursively transformed. Default is True .","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_214","text":"If pattern is unspecified, all possible expressions are transformed. from sympy import cos, sin, exp, I from sympy.abc import x expr = cos(x) + I sin(x) expr.rewrite(exp) exp(I x) Pattern can be a type or an iterable of types. expr.rewrite(sin, exp) exp(I x)/2 + cos(x) - exp(-I x)/2 expr.rewrite([cos,], exp) exp(I x)/2 + I sin(x) + exp(-I x)/2 expr.rewrite([cos, sin], exp) exp(I x) Rewriting behavior can be implemented by defining _eval_rewrite() method. from sympy import Expr, sqrt, pi class MySin(Expr): ... def _eval_rewrite(self, rule, args, hints): ... x, = args ... if rule == cos: ... return cos(pi/2 - x, evaluate=False) ... if rule == sqrt: ... return sqrt(1 - cos(x) 2) MySin(MySin(x)).rewrite(cos) cos(-cos(-x + pi/2) + pi/2) MySin(x).rewrite(sqrt) sqrt(1 - cos(x)**2) Defining _eval_rewrite_as_[...]() method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. class MySin(Expr): ... def _eval_rewrite_as_cos(self, args, *hints): ... x, = args ... return cos(pi/2 - x, evaluate=False) MySin(x).rewrite(cos) cos(-x + pi/2)","title":"Examples"},{"location":"reference/dewret/workflow/#round_4","text":"def round ( self , n = None ) Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number.","title":"round"},{"location":"reference/dewret/workflow/#examples_215","text":"from sympy import pi, E, I, S, Number pi.round() 3 pi.round(2) 3.14 (2 pi + E I).round() 6 + 3*I The round method has a chopping effect: (2 pi + I/10).round() 6 (pi/10 + 2 I).round() 2 I (pi/10 + E I).round(2) 0.31 + 2.72*I","title":"Examples"},{"location":"reference/dewret/workflow/#notes_29","text":"The Python round function uses the SymPy round method so it will always return a SymPy number (not a Python float or int): isinstance(round(S(123), -2), Number) True","title":"Notes"},{"location":"reference/dewret/workflow/#separate_4","text":"def separate ( self , deep = False , force = False ) See the separate function in sympy.simplify","title":"separate"},{"location":"reference/dewret/workflow/#series_4","text":"def series ( self , x = None , x0 = 0 , n = 6 , dir = '+' , logx = None , cdir = 0 ) Series expansion of \"self\" around x = x0 yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of \"self\" around the point x = x0 with respect to x up to O((x - x0)**n, x, x0) (default n is 6). If x=None and self is univariate, the univariate symbol will be supplied, otherwise an error will be raised.","title":"series"},{"location":"reference/dewret/workflow/#parameters_28","text":"expr : Expression The expression whose series is to be expanded. x : Symbol It is the variable of the expression to be calculated. x0 : Value The value around which x is calculated. Can be any value from -oo to oo . n : Value The value used to represent the order in terms of x**n , up to which the series is to be expanded. dir : String, optional The series-expansion can be bi-directional. If dir=\"+\" , then (x->x0+). If dir=\"-\", then (x->x0-). For infinite x0 ( oo or -oo ), the dir argument is determined from the direction of the infinity (i.e., dir=\"-\" for oo``). logx : optional It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. cdir : optional It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated.","title":"Parameters"},{"location":"reference/dewret/workflow/#examples_216","text":"from sympy import cos, exp, tan from sympy.abc import x, y cos(x).series() 1 - x 2/2 + x 4/24 + O(x 6) cos(x).series(n=4) 1 - x 2/2 + O(x 4) cos(x).series(x, x0=1, n=2) cos(1) - (x - 1)*sin(1) + O((x - 1) 2, (x, 1)) e = cos(x + exp(y)) e.series(y, n=2) cos(x + 1) - y sin(x + 1) + O(y 2) e.series(x, n=2) cos(exp(y)) - x sin(exp(y)) + O(x**2) If n=None then a generator of the series terms will be returned. term=cos(x).series(n=None) [next(term) for i in range(2)] [1, -x**2/2] For dir=+ (default) the series is calculated from the right and for dir=- the series from the left. For smooth functions this flag will not alter the results. abs(x).series(dir=\"+\") x abs(x).series(dir=\"-\") -x f = tan(x) f.series(x, 2, 6, \"+\") tan(2) + (1 + tan(2) 2)*(x - 2) + (x - 2) 2 (tan(2) 3 + tan(2)) + (x - 2) 3 (1/3 + 4 tan(2) 2/3 + tan(2) 4) + (x - 2) 4 (tan(2) 5 + 5*tan(2) 3/3 + 2 tan(2)/3) + (x - 2) 5 (2/15 + 17 tan(2) 2/15 + 2 tan(2) 4 + tan(2) 6) + O((x - 2)**6, (x, 2)) f.series(x, 2, 3, \"-\") tan(2) + (2 - x) (-tan(2) 2 - 1) + (2 - x) 2 (tan(2) 3 + tan(2)) + O((x - 2) 3, (x, 2)) For rational expressions this method may return original expression without the Order term. (1/x).series(x, n=8) 1/x","title":"Examples"},{"location":"reference/dewret/workflow/#returns_13","text":"Expr : Expression Series expansion of the expression about x0","title":"Returns"},{"location":"reference/dewret/workflow/#raises_4","text":"TypeError If \"n\" and \"x0\" are infinity objects PoleError If \"x0\" is an infinity object","title":"Raises"},{"location":"reference/dewret/workflow/#simplify_4","text":"def simplify ( self , ** kwargs ) -> 'Basic' See the simplify function in sympy.simplify","title":"simplify"},{"location":"reference/dewret/workflow/#sort_key_4","text":"def sort_key ( self , order = None ) Return a sort key.","title":"sort_key"},{"location":"reference/dewret/workflow/#examples_217","text":"from sympy import S, I sorted([S(1)/2, I, -I], key=lambda x: x.sort_key()) [1/2, -I, I] S(\"[x, 1/x, 1/x 2, x 2, x (1/2), x (1/4), x (3/2)]\") [x, 1/x, x (-2), x 2, sqrt(x), x (1/4), x (3/2)] sorted(_, key=lambda x: x.sort_key()) [x (-2), 1/x, x (1/4), sqrt(x), x, x (3/2), x**2]","title":"Examples"},{"location":"reference/dewret/workflow/#subs_4","text":"def subs ( self , arg1 : 'Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex' , arg2 : 'Basic | complex | None' = None , ** kwargs : 'Any' ) -> 'Basic' Substitutes old for new in an expression after sympifying args. args is either: - two arguments, e.g. foo.subs(old, new) - one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword simultaneous is True, the subexpressions will not be evaluated until all the substitutions have been made.","title":"subs"},{"location":"reference/dewret/workflow/#examples_218","text":"from sympy import pi, exp, limit, oo from sympy.abc import x, y (1 + x y).subs(x, pi) pi y + 1 (1 + x y).subs({x:pi, y:2}) 1 + 2 pi (1 + x y).subs([(x, pi), (y, 2)]) 1 + 2 pi reps = [(y, x 2), (x, 2)] (x + y).subs(reps) 6 (x + y).subs(reversed(reps)) x 2 + 2 (x 2 + x 4).subs(x 2, y) y 2 + y To replace only the x 2 but not the x 4, use xreplace: (x 2 + x 4).xreplace({x 2: y}) x 4 + y To delay evaluation until all substitutions have been made, set the keyword simultaneous to True: (x/y).subs([(x, 0), (y, 0)]) 0 (x/y).subs([(x, 0), (y, 0)], simultaneous=True) nan This has the added feature of not allowing subsequent substitutions to affect those already made: ((x + y)/y).subs({x + y: y, y: x + y}) 1 ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True) y/(x + y) In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. from sympy import sqrt, sin, cos from sympy.abc import a, b, c, d, e A = (sqrt(sin(2 x)), a) B = (sin(2 x), b) C = (cos(2*x), c) D = (x, d) E = (exp(x), e) expr = sqrt(sin(2 x)) sin(exp(x) x) cos(2 x) + sin(2 x) expr.subs(dict([A, B, C, D, E])) a c sin(d*e) + b The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: (x* 3 - 3 x).subs({x: oo}) nan limit(x* 3 - 3 x, x, oo) oo If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as (1/x).evalf(subs={x: 3.0}, n=21) 0.333333333333333333333 rather than (1/x).subs({x: 3.0}).evalf(21) 0.333333333333333314830 as the former will ensure that the desired level of precision is obtained.","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_68","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements xreplace: exact node replacement in expr tree; also capable of using matching rules sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision","title":"See Also"},{"location":"reference/dewret/workflow/#taylor_term_4","text":"def taylor_term ( self , n , x , * previous_terms ) General method for the taylor term. This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the \"previous_terms\".","title":"taylor_term"},{"location":"reference/dewret/workflow/#to_nnf_4","text":"def to_nnf ( self , simplify = True )","title":"to_nnf"},{"location":"reference/dewret/workflow/#together_4","text":"def together ( self , * args , ** kwargs ) See the together function in sympy.polys","title":"together"},{"location":"reference/dewret/workflow/#transpose_4","text":"def transpose ( self )","title":"transpose"},{"location":"reference/dewret/workflow/#trigsimp_4","text":"def trigsimp ( self , ** args ) See the trigsimp function in sympy.simplify","title":"trigsimp"},{"location":"reference/dewret/workflow/#xreplace_4","text":"def xreplace ( self , rule , hack2 = False ) Replace occurrences of objects within the expression.","title":"xreplace"},{"location":"reference/dewret/workflow/#parameters_29","text":"rule : dict-like Expresses a replacement rule","title":"Parameters"},{"location":"reference/dewret/workflow/#returns_14","text":"xreplace : the result of the replacement","title":"Returns"},{"location":"reference/dewret/workflow/#examples_219","text":"from sympy import symbols, pi, exp x, y, z = symbols('x y z') (1 + x y).xreplace({x: pi}) pi y + 1 (1 + x y).xreplace({x: pi, y: 2}) 1 + 2 pi Replacements occur only if an entire node in the expression tree is matched: (x y + z).xreplace({x y: pi}) z + pi (x y z).xreplace({x y: pi}) x y z (2 x).xreplace({2 x: y, x: z}) y (2 2 x).xreplace({2 x: y, x: z}) 4*z (x + y + 2).xreplace({x + y: 2}) x + y + 2 (x + 2 + exp(x + 2)).xreplace({x + 2: y}) x + exp(y) + 2 xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: from sympy import Integral Integral(x, (x, 1, 2 x)).xreplace({x: y}) Integral(y, (y, 1, 2 y)) Trying to replace x with an expression raises an error: Integral(x, (x, 1, 2 x)).xreplace({x: 2 y}) # doctest: +SKIP ValueError: Invalid limits given: ((2 y, 1, 4 y),)","title":"Examples"},{"location":"reference/dewret/workflow/#see-also_69","text":"replace: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements subs: substitution of subexpressions as defined by the objects themselves.","title":"See Also"},{"location":"reference/dewret/workflow/#task","text":"class Task ( name : 'str' , target : 'Lazy' ) Named wrapper of a lazy-evaluatable function. Wraps a lazy-evaluatable function ( dewret.workflow.Lazy ) with any metadata needed to render it later. At present, this is the name.","title":"Task"},{"location":"reference/dewret/workflow/#attributes_5","text":"Name Type Description Default name None Name of the lazy function as it will appear in the output workflow text. None target None Callable that is wrapped. None","title":"Attributes"},{"location":"reference/dewret/workflow/#unsettype","text":"class UnsetType ( raw_type : 'type[T]' ) Unset variable with a specific type.","title":"UnsetType"},{"location":"reference/dewret/workflow/#attributes_6","text":"Name Type Description Default type None type of the variable. None","title":"Attributes"},{"location":"reference/dewret/workflow/#ancestors-in-mro_12","text":"dewret.utils.Unset typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/workflow/#workflow","text":"class Workflow ( name : 'str | None' = None ) Overarching workflow concept. Represents a whole workflow, as a singleton maintaining all state information needed ahead of rendering. It is built up as the lazy-evaluations are finally evaluated.","title":"Workflow"},{"location":"reference/dewret/workflow/#attributes_7","text":"Name Type Description Default steps None the sequence of calls to lazy-evaluable functions, built as they are evaluated. None tasks None the mapping of names used in the steps to the actual Task wrappers they represent. None result None target reference to evaluate, if yet present. None","title":"Attributes"},{"location":"reference/dewret/workflow/#static-methods_5","text":"","title":"Static methods"},{"location":"reference/dewret/workflow/#assimilate","text":"def assimilate ( * workflow_args : 'Workflow' ) -> \"'Workflow'\" Combine two Workflows into one Workflow. Takes two workflows and unifies them by combining steps and tasks. If it sees mismatched identifiers for the same component, it will error. This could happen if the hashing function is flawed or some Python magic to do with Targets being passed. Parameters: Name Type Description Default workflow_args None workflows to use as base None","title":"assimilate"},{"location":"reference/dewret/workflow/#from_result","text":"def from_result ( result : 'StepReference[Any] | list[StepReference[Any]] | tuple[StepReference[Any], ...]' , simplify_ids : 'bool' = False , nested : 'bool' = True ) -> 'Workflow' Create from a desired result. Starts from a result, and builds a workflow to output it.","title":"from_result"},{"location":"reference/dewret/workflow/#instance-variables_10","text":"has_result Confirms whether this workflow has a non-empty result. Either None or an empty list/tuple are considered empty for this purpose. Returns: True if the workflow has a result, False otherwise. id Consistent ID based off the step IDs. indexed_steps Steps mapped by ID. Forces generation of IDs. Note that this effectively freezes the steps, so it should not be used until we are confident the steps are all ready to be hashed. name Get the name of the workflow. result_type Overall return type of this workflow. steps Get deduplicated steps. Returns: steps for looping over without duplicates.","title":"Instance variables"},{"location":"reference/dewret/workflow/#methods_10","text":"","title":"Methods"},{"location":"reference/dewret/workflow/#add_nested_step","text":"def add_nested_step ( self , name : 'str' , subworkflow : 'Workflow' , return_type : 'type | None' , kwargs : 'dict[str, Any]' , positional_args : 'dict[str, bool] | None' = None ) -> 'StepReference[Any]' Append a nested step. Calls a subworkflow. Parameters: Name Type Description Default name None name of the subworkflow. None subworkflow None the subworkflow itself. None return_type None a forced type for the return, or None. None kwargs None any key-value arguments to pass in the call. None positional_args None a mapping of arguments to bools, True if the argument is positional or otherwise False. None","title":"add_nested_step"},{"location":"reference/dewret/workflow/#add_step","text":"def add_step ( self , fn : 'Lazy' , kwargs : 'dict[str, Raw | Reference[Any]]' , raw_as_parameter : 'bool' = False , is_factory : 'bool' = False , positional_args : 'dict[str, bool] | None' = None ) -> 'StepReference[Any]' Append a step. Adds a step, for running a target with key-value arguments, to the workflow. Parameters: Name Type Description Default fn None the target function to turn into a step. None kwargs None any key-value arguments to pass in the call. None raw_as_parameter None whether to turn any discovered raw arguments into workflow parameters. None is_factory None whether this step should be a Factory. None positional_args None a mapping of arguments to bools, True if the argument is positional or otherwise False. None","title":"add_step"},{"location":"reference/dewret/workflow/#find_factories","text":"def find_factories ( self ) -> 'dict[str, FactoryCall]' Steps that are factory calls.","title":"find_factories"},{"location":"reference/dewret/workflow/#find_parameters","text":"def find_parameters ( self , include_factory_calls : 'bool' = True ) -> 'set[Parameter[Any]]' Crawl steps for parameter references. As the workflow does not hold its own list of parameters, this dynamically finds them. Returns: Type Description None Set of all references to parameters across the steps.","title":"find_parameters"},{"location":"reference/dewret/workflow/#register_task","text":"def register_task ( self , fn : 'Lazy' ) -> 'Task' Note the existence of a lazy-evaluatable function, and wrap it as a Task . Parameters: Name Type Description Default fn None the wrapped function. None Returns: Type Description None A new Task that wraps the function, and is retained in the Workflow.tasks dict.","title":"register_task"},{"location":"reference/dewret/workflow/#remap","text":"def remap ( self , step_id : 'str' ) -> 'str' Apply name simplification if requested. Parameters: Name Type Description Default step_id None step to check. None Returns: Type Description None Same ID or a remapped name.","title":"remap"},{"location":"reference/dewret/workflow/#set_result","text":"def set_result ( self , result : 'Basic | list[Basic] | tuple[Basic]' ) -> 'None' Choose the result step. Sets a step as being the result for the entire workflow. When we evaluate a dynamic workflow, the engine (e.g. dask) creates a graph to realize the result of a single collection. Similarly, in the static case, we need to have a result that drives the calculation. Parameters: Name Type Description Default result None reference to the chosen step. None","title":"set_result"},{"location":"reference/dewret/workflow/#simplify_ids","text":"def simplify_ids ( self , infix : 'list[str] | None' = None ) -> 'None' Work out mapping to simple ints from hashes. Goes through and numbers each step by the order of use of its task.","title":"simplify_ids"},{"location":"reference/dewret/workflow/#workflowlinkedcomponent","text":"class WorkflowLinkedComponent ( * args , ** kwargs ) Protocol for objects dynamically tied to a Workflow .","title":"WorkflowLinkedComponent"},{"location":"reference/dewret/workflow/#ancestors-in-mro_13","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/backends/","text":"Module dewret.backends Backends for supplying lazy-evaluation. By default, we use dask, but it is possible to extend this functionality as the behaviour is encapsulated within these modules. Sub-modules dewret.backends.backend_dask","title":"Index"},{"location":"reference/dewret/backends/#module-dewretbackends","text":"Backends for supplying lazy-evaluation. By default, we use dask, but it is possible to extend this functionality as the behaviour is encapsulated within these modules.","title":"Module dewret.backends"},{"location":"reference/dewret/backends/#sub-modules","text":"dewret.backends.backend_dask","title":"Sub-modules"},{"location":"reference/dewret/backends/backend_dask/","text":"Module dewret.backends.backend_dask Dask backend. Lazy-evaluation via dask.delayed . Variables config Functions is_lazy def is_lazy ( task : Any ) -> bool Checks if a task is really a lazy-evaluated function for this backend. Parameters: Name Type Description Default task None suspected lazy-evaluated function. None Returns: Type Description None True if so, False otherwise. lazy def lazy ( obj = '__no__default__' , name = None , pure = None , nout = None , traverse = True ) Wraps a function or object to produce a Delayed . Delayed objects act as proxies for the object they wrap, but all operations on them are done lazily by building up a dask graph internally. Parameters: Name Type Description Default obj object The function or object to wrap None name Dask key The key to use in the underlying graph for the wrapped object. Defaults to hashing content. Note that this only affects the name of the object wrapped by this call to delayed, and not the output of delayed function calls - for that use dask_key_name= as described below. .. note:: Because this name is used as the key in task graphs, you should ensure that it uniquely identifies obj . If you'd like to provide a descriptive name that is still unique, combine the descriptive name with :func: dask.base.tokenize of the array_like . See :ref: graphs for more. s pure bool Indicates whether calling the resulting Delayed object is a pure operation. If True, arguments to the call are hashed to produce deterministic keys. If not provided, the default is to check the global delayed_pure setting, and fallback to False if unset. to nout int The number of outputs returned from calling the resulting Delayed object. If provided, the Delayed output of the call can be iterated into nout objects, allowing for unpacking of results. By default iteration over Delayed objects will error. Note, that nout=1 expects obj to return a tuple of length 1, and consequently for nout=0 , obj should return an empty tuple. iteration traverse bool By default dask traverses builtin python collections looking for dask objects passed to delayed . For large collections this can be expensive. If obj doesn't contain any dask objects, set traverse=False to avoid doing this traversal. dask run def run ( workflow : dewret . workflow . Workflow | None , task : dewret . workflow . Lazy | list [ dewret . workflow . Lazy ] | tuple [ dewret . workflow . Lazy , ... ], thread_pool : concurrent . futures . thread . ThreadPoolExecutor | None = None , ** kwargs : Any ) -> Any Execute a task as the output of a workflow. Runs a task with dask. Parameters: Name Type Description Default workflow None Workflow in which to record the execution. None task None dask.delayed function, wrapped by dewret, that we wish to compute. None thread_pool None custom thread pool for executing workflows, copies in correct values for contextvars to each thread before they are accessed by a dask worker. None **kwargs None any configuration arguments for this backend. None unwrap def unwrap ( task : dewret . workflow . Lazy ) -> collections . abc . Callable [ ... , typing . Any ] Unwraps a lazy-evaluated function to get the function. In recent dask (>=2024.3) this works with inspect.wraps, but earlier versions do not have the __wrapped__ property. Parameters: Name Type Description Default task None task to be unwrapped. None Returns: Type Description None Original target. Raises: Type Description RuntimeError if the task is not a wrapped function. Classes Delayed class Delayed ( * args , ** kwargs ) Description of a dask delayed . Since dask.delayed does not have a hintable type, this stands in its place, making sure that all the features of a dask.delayed are available. More info: https://github.com/dask/dask/issues/7779 Ancestors (in MRO) typing.Protocol typing.Generic Methods compute def compute ( self , __workflow__ : dewret . workflow . Workflow | None ) -> dewret . workflow . StepReference [ typing . Any ] Evaluate this dask.delayed . Evaluate a delayed (dask lazy-evaluated) function. dewret will have replaced it with a wrapper that expects a Workflow and all arguments will already be known to the wrapped delayed so the signature here is simple. Parameters: Name Type Description Default workflow None Workflow that this is tied to, if applicable. None Returns: Type Description None Reference to the final output step.","title":"Backend Dask"},{"location":"reference/dewret/backends/backend_dask/#module-dewretbackendsbackend_dask","text":"Dask backend. Lazy-evaluation via dask.delayed .","title":"Module dewret.backends.backend_dask"},{"location":"reference/dewret/backends/backend_dask/#variables","text":"config","title":"Variables"},{"location":"reference/dewret/backends/backend_dask/#functions","text":"","title":"Functions"},{"location":"reference/dewret/backends/backend_dask/#is_lazy","text":"def is_lazy ( task : Any ) -> bool Checks if a task is really a lazy-evaluated function for this backend. Parameters: Name Type Description Default task None suspected lazy-evaluated function. None Returns: Type Description None True if so, False otherwise.","title":"is_lazy"},{"location":"reference/dewret/backends/backend_dask/#lazy","text":"def lazy ( obj = '__no__default__' , name = None , pure = None , nout = None , traverse = True ) Wraps a function or object to produce a Delayed . Delayed objects act as proxies for the object they wrap, but all operations on them are done lazily by building up a dask graph internally. Parameters: Name Type Description Default obj object The function or object to wrap None name Dask key The key to use in the underlying graph for the wrapped object. Defaults to hashing content. Note that this only affects the name of the object wrapped by this call to delayed, and not the output of delayed function calls - for that use dask_key_name= as described below. .. note:: Because this name is used as the key in task graphs, you should ensure that it uniquely identifies obj . If you'd like to provide a descriptive name that is still unique, combine the descriptive name with :func: dask.base.tokenize of the array_like . See :ref: graphs for more. s pure bool Indicates whether calling the resulting Delayed object is a pure operation. If True, arguments to the call are hashed to produce deterministic keys. If not provided, the default is to check the global delayed_pure setting, and fallback to False if unset. to nout int The number of outputs returned from calling the resulting Delayed object. If provided, the Delayed output of the call can be iterated into nout objects, allowing for unpacking of results. By default iteration over Delayed objects will error. Note, that nout=1 expects obj to return a tuple of length 1, and consequently for nout=0 , obj should return an empty tuple. iteration traverse bool By default dask traverses builtin python collections looking for dask objects passed to delayed . For large collections this can be expensive. If obj doesn't contain any dask objects, set traverse=False to avoid doing this traversal. dask","title":"lazy"},{"location":"reference/dewret/backends/backend_dask/#run","text":"def run ( workflow : dewret . workflow . Workflow | None , task : dewret . workflow . Lazy | list [ dewret . workflow . Lazy ] | tuple [ dewret . workflow . Lazy , ... ], thread_pool : concurrent . futures . thread . ThreadPoolExecutor | None = None , ** kwargs : Any ) -> Any Execute a task as the output of a workflow. Runs a task with dask. Parameters: Name Type Description Default workflow None Workflow in which to record the execution. None task None dask.delayed function, wrapped by dewret, that we wish to compute. None thread_pool None custom thread pool for executing workflows, copies in correct values for contextvars to each thread before they are accessed by a dask worker. None **kwargs None any configuration arguments for this backend. None","title":"run"},{"location":"reference/dewret/backends/backend_dask/#unwrap","text":"def unwrap ( task : dewret . workflow . Lazy ) -> collections . abc . Callable [ ... , typing . Any ] Unwraps a lazy-evaluated function to get the function. In recent dask (>=2024.3) this works with inspect.wraps, but earlier versions do not have the __wrapped__ property. Parameters: Name Type Description Default task None task to be unwrapped. None Returns: Type Description None Original target. Raises: Type Description RuntimeError if the task is not a wrapped function.","title":"unwrap"},{"location":"reference/dewret/backends/backend_dask/#classes","text":"","title":"Classes"},{"location":"reference/dewret/backends/backend_dask/#delayed","text":"class Delayed ( * args , ** kwargs ) Description of a dask delayed . Since dask.delayed does not have a hintable type, this stands in its place, making sure that all the features of a dask.delayed are available. More info: https://github.com/dask/dask/issues/7779","title":"Delayed"},{"location":"reference/dewret/backends/backend_dask/#ancestors-in-mro","text":"typing.Protocol typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dewret/backends/backend_dask/#methods","text":"","title":"Methods"},{"location":"reference/dewret/backends/backend_dask/#compute","text":"def compute ( self , __workflow__ : dewret . workflow . Workflow | None ) -> dewret . workflow . StepReference [ typing . Any ] Evaluate this dask.delayed . Evaluate a delayed (dask lazy-evaluated) function. dewret will have replaced it with a wrapper that expects a Workflow and all arguments will already be known to the wrapped delayed so the signature here is simple. Parameters: Name Type Description Default workflow None Workflow that this is tied to, if applicable. None Returns: Type Description None Reference to the final output step.","title":"compute"},{"location":"reference/dewret/renderers/","text":"Module dewret.renderers Renderers for outputting static workflow representations. Take a Workflow and output a static representation in the desired format. Sub-modules dewret.renderers.cwl dewret.renderers.snakemake","title":"Index"},{"location":"reference/dewret/renderers/#module-dewretrenderers","text":"Renderers for outputting static workflow representations. Take a Workflow and output a static representation in the desired format.","title":"Module dewret.renderers"},{"location":"reference/dewret/renderers/#sub-modules","text":"dewret.renderers.cwl dewret.renderers.snakemake","title":"Sub-modules"},{"location":"reference/dewret/renderers/cwl/","text":"Module dewret.renderers.cwl CWL Renderer. Outputs a Common Workflow Language representation of the current workflow. Variables InputSchemaType T Functions cwl_type_from_value def cwl_type_from_value ( label : str , val : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | dewret . utils . Unset ) -> dewret . renderers . cwl . CommandInputSchema Find a CWL type for a given (possibly Unset) value. Parameters: Name Type Description Default label None the label for the variable being checked to prefill the input def and improve debugging info. None val None a raw Python variable or an unset variable. None Returns: Type Description None Input schema type. default_config def default_config ( ) -> dewret . renderers . cwl . CWLRendererConfiguration Default configuration for this renderer. This is a hook-like call to give a configuration dict that this renderer will respect, and sets any necessary default values. Returns: a dict with (preferably) raw type structures to enable easy setting from YAML/JSON. raw_to_command_input_schema def raw_to_command_input_schema ( label : str , value : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | dewret . utils . Unset ) -> str | dewret . renderers . cwl . CommandInputSchema | list [ str ] | list [ 'InputSchemaType' ] | dict [ str , 'str | InputSchemaType' ] Infer the CWL input structure for this value. Inspects the value, to work out an appropriate structure describing it in CWL. Parameters: Name Type Description Default label None name of the variable. None value None basic-typed variable from which to build structure. None Returns: Type Description None Structure used to define (possibly compound) basic types for input. render def render ( workflow : dewret . workflow . Workflow , ** kwargs : *< class ' dewret . renderers . cwl . CWLRendererConfiguration '> ) -> dict [ str , dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]]] Render to a dict-like structure. Parameters: Name Type Description Default workflow None workflow to evaluate result. None **kwargs None additional configuration arguments - these should match CWLRendererConfiguration. None Returns: Type Description None Reduced form as a native Python dict structure for serialization. render_expression def render_expression ( ref : Any ) -> 'ReferenceDefinition' Turn a rich (sympy) expression into a CWL JS expression. Parameters: Name Type Description Default ref None a structure whose elements are all string-renderable or sympy Basic. None to_cwl_type def to_cwl_type ( label : str , typ : Type [ ~ T ] ) -> dewret . renderers . cwl . CommandInputSchema Map Python types to CWL types. Parameters: Name Type Description Default label None the label for the variable being checked to prefill the input def and improve debugging info. None typ None a Python basic type. None Returns: Type Description None CWL specification type dict. to_name def to_name ( result : dewret . core . Reference [ typing . Any ] ) -> str Take a reference and get a name representing it. The primary purpose of this method is to deal with the case where a reference is to the whole result, as we always put this into an imagined out field for CWL consistency. Returns: the name of the reference, including any field portion, appending an \"out\" fieldname if none. to_output_schema def to_output_schema ( label : str , typ : type [ str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | attr . AttrsInstance | dewret . utils . DataclassProtocol ], output_source : str | None = None ) -> dewret . renderers . cwl . CommandOutputSchema Turn a step's output into an output schema. Takes a source, type and label and provides a description for CWL. Parameters: Name Type Description Default label None name of this field. None typ None either a basic type, compound of basic types, or a TypedDict representing a pre-defined result structure. None output_source None if provided, a CWL step result reference to input here. None Returns: Type Description None CWL CommandOutputSchema-like structure for embedding into an outputs block with_field def with_field ( result : Any ) -> str Get a string representing any 'field' suffix of a value. This only makes sense in the context of a Reference, which can represent a deep reference with a known variable (parameter or step result, say) using its __field__ attribute. Defaults to \"out\" as this produces compliant CWL where every output has a \"fieldname\". Returns: a string representation of the field portion of the passed value or \"out\" . with_type def with_type ( result : Any ) -> type | typing . Any Get a Python type from a value. Does so either by using its __type__ field (for example, for References) or if unavailable, using type() . Returns: a Python type. Classes CWLRendererConfiguration class CWLRendererConfiguration ( / , * args , ** kwargs ) Configuration for the renderer. Attributes Name Type Description Default allow_complex_types None can input/output types be other than raw? None factories_as_params None should factories be treated as input or steps? None Ancestors (in MRO) builtins.dict Methods clear def clear ( ... ) D.clear() -> None. Remove all items from D. copy def copy ( ... ) D.copy() -> a shallow copy of D fromkeys def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items def items ( ... ) D.items() -> a set-like object providing a view on D's items keys def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError. popitem def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values def values ( ... ) D.values() -> an object providing a view on D's values CommandInputSchema class CommandInputSchema ( / , * args , ** kwargs ) Structure for referring to a raw type in CWL. Encompasses several CWL types. In future, it may be best to use cwltool or another library for these basic structures. Attributes Name Type Description Default type None CWL type of this input. None label None name to show for this input. None fields None (for record ) individual fields in a dict-like structure. None items None (for array ) type that each field will have. None Ancestors (in MRO) builtins.dict Methods clear def clear ( ... ) D.clear() -> None. Remove all items from D. copy def copy ( ... ) D.copy() -> a shallow copy of D fromkeys def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items def items ( ... ) D.items() -> a set-like object providing a view on D's items keys def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError. popitem def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values def values ( ... ) D.values() -> an object providing a view on D's values CommandOutputSchema class CommandOutputSchema ( / , * args , ** kwargs ) Structure for referring to an output in CWL. As a simplification, this is an input schema with an extra outputSource field. Attributes Name Type Description Default outputSource None step result to use for this output. None Ancestors (in MRO) builtins.dict Methods clear def clear ( ... ) D.clear() -> None. Remove all items from D. copy def copy ( ... ) D.copy() -> a shallow copy of D fromkeys def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items def items ( ... ) D.items() -> a set-like object providing a view on D's items keys def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError. popitem def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values def values ( ... ) D.values() -> an object providing a view on D's values InputsDefinition class InputsDefinition ( inputs : dict [ str , 'CommandInputParameter' ] ) CWL-renderable representation of an input parameter block. Turns dewret results into a CWL input block. Attributes Name Type Description Default input None sequence of results from a workflow. None Class variables CommandInputParameter Static methods from_parameters def from_parameters ( parameters : list [ typing . Union [ dewret . workflow . ParameterReference [ typing . Any ], dewret . workflow . FactoryCall ]] ) -> 'InputsDefinition' Takes a list of parameters into a CWL structure. Uses the parameters to fill out the necessary input fields. Returns: Type Description None CWL-like structure representing all workflow outputs. Instance variables inputs Methods render def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization. OutputsDefinition class OutputsDefinition ( outputs : dict [ str , 'CommandOutputSchema' ] | list [ 'CommandOutputSchema' ] | dewret . renderers . cwl . CommandOutputSchema ) CWL-renderable set of workflow outputs. Turns dewret results into a CWL output block. Attributes Name Type Description Default outputs None sequence of results from a workflow. None Static methods from_results def from_results ( results : dict [ str , dewret . workflow . StepReference [ typing . Any ]] | list [ dewret . workflow . StepReference [ typing . Any ]] | tuple [ dewret . workflow . StepReference [ typing . Any ], ... ] ) -> 'OutputsDefinition' Takes a mapping of results into a CWL structure. Pulls the result type from the signature, ultimately, if possible. Returns: Type Description None CWL-like structure representing all workflow outputs. Instance variables outputs Methods render def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] | list [ str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization. ReferenceDefinition class ReferenceDefinition ( source : str | None , value_from : str | None ) CWL-renderable internal reference. Normally points to a value or a step. Static methods from_reference def from_reference ( ref : dewret . core . Reference [ typing . Any ] ) -> 'ReferenceDefinition' Build from a Reference . Converts a dewret.workflow.Reference into a CWL-rendering object. Parameters: Name Type Description Default ref None reference to convert. None Instance variables source value_from Methods render def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization. StepDefinition class StepDefinition ( name : str , run : str , out : dict [ str , 'CommandInputSchema' ] | list [ str ], in_ : collections . abc . Mapping [ str , dewret . renderers . cwl . ReferenceDefinition | dewret . core . Raw ] ) CWL-renderable step. Coerces the dewret structure of a step into that needed for valid CWL. Attributes Name Type Description Default name None identifier to call this step by. None run None task to execute for this step. None in_ None inputs from values or other steps. None Static methods from_step def from_step ( step : dewret . workflow . BaseStep ) -> 'StepDefinition' Build from a BaseStep . Converts a dewret.workflow.Step into a CWL-rendering object. Parameters: Name Type Description Default step None step to convert. None Instance variables in_ name out run Methods render def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization. WorkflowDefinition class WorkflowDefinition ( steps : list [ dewret . renderers . cwl . StepDefinition ], inputs : dewret . renderers . cwl . InputsDefinition , outputs : dewret . renderers . cwl . OutputsDefinition , name : None | str ) CWL-renderable workflow. Coerces the dewret structure of a workflow into that needed for valid CWL. Attributes Name Type Description Default steps None sequence of steps in the workflow. None Static methods from_workflow def from_workflow ( workflow : dewret . workflow . Workflow , name : None | str = None ) -> 'WorkflowDefinition' Build from a Workflow . Converts a dewret.workflow.Workflow into a CWL-rendering object. Parameters: Name Type Description Default workflow None workflow to convert. None name None name of this workflow, if it should have one. None Instance variables inputs name outputs steps Methods render def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization.","title":"Cwl"},{"location":"reference/dewret/renderers/cwl/#module-dewretrendererscwl","text":"CWL Renderer. Outputs a Common Workflow Language representation of the current workflow.","title":"Module dewret.renderers.cwl"},{"location":"reference/dewret/renderers/cwl/#variables","text":"InputSchemaType T","title":"Variables"},{"location":"reference/dewret/renderers/cwl/#functions","text":"","title":"Functions"},{"location":"reference/dewret/renderers/cwl/#cwl_type_from_value","text":"def cwl_type_from_value ( label : str , val : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | dewret . utils . Unset ) -> dewret . renderers . cwl . CommandInputSchema Find a CWL type for a given (possibly Unset) value. Parameters: Name Type Description Default label None the label for the variable being checked to prefill the input def and improve debugging info. None val None a raw Python variable or an unset variable. None Returns: Type Description None Input schema type.","title":"cwl_type_from_value"},{"location":"reference/dewret/renderers/cwl/#default_config","text":"def default_config ( ) -> dewret . renderers . cwl . CWLRendererConfiguration Default configuration for this renderer. This is a hook-like call to give a configuration dict that this renderer will respect, and sets any necessary default values. Returns: a dict with (preferably) raw type structures to enable easy setting from YAML/JSON.","title":"default_config"},{"location":"reference/dewret/renderers/cwl/#raw_to_command_input_schema","text":"def raw_to_command_input_schema ( label : str , value : str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | dewret . utils . Unset ) -> str | dewret . renderers . cwl . CommandInputSchema | list [ str ] | list [ 'InputSchemaType' ] | dict [ str , 'str | InputSchemaType' ] Infer the CWL input structure for this value. Inspects the value, to work out an appropriate structure describing it in CWL. Parameters: Name Type Description Default label None name of the variable. None value None basic-typed variable from which to build structure. None Returns: Type Description None Structure used to define (possibly compound) basic types for input.","title":"raw_to_command_input_schema"},{"location":"reference/dewret/renderers/cwl/#render","text":"def render ( workflow : dewret . workflow . Workflow , ** kwargs : *< class ' dewret . renderers . cwl . CWLRendererConfiguration '> ) -> dict [ str , dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]]] Render to a dict-like structure. Parameters: Name Type Description Default workflow None workflow to evaluate result. None **kwargs None additional configuration arguments - these should match CWLRendererConfiguration. None Returns: Type Description None Reduced form as a native Python dict structure for serialization.","title":"render"},{"location":"reference/dewret/renderers/cwl/#render_expression","text":"def render_expression ( ref : Any ) -> 'ReferenceDefinition' Turn a rich (sympy) expression into a CWL JS expression. Parameters: Name Type Description Default ref None a structure whose elements are all string-renderable or sympy Basic. None","title":"render_expression"},{"location":"reference/dewret/renderers/cwl/#to_cwl_type","text":"def to_cwl_type ( label : str , typ : Type [ ~ T ] ) -> dewret . renderers . cwl . CommandInputSchema Map Python types to CWL types. Parameters: Name Type Description Default label None the label for the variable being checked to prefill the input def and improve debugging info. None typ None a Python basic type. None Returns: Type Description None CWL specification type dict.","title":"to_cwl_type"},{"location":"reference/dewret/renderers/cwl/#to_name","text":"def to_name ( result : dewret . core . Reference [ typing . Any ] ) -> str Take a reference and get a name representing it. The primary purpose of this method is to deal with the case where a reference is to the whole result, as we always put this into an imagined out field for CWL consistency. Returns: the name of the reference, including any field portion, appending an \"out\" fieldname if none.","title":"to_name"},{"location":"reference/dewret/renderers/cwl/#to_output_schema","text":"def to_output_schema ( label : str , typ : type [ str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ] | attr . AttrsInstance | dewret . utils . DataclassProtocol ], output_source : str | None = None ) -> dewret . renderers . cwl . CommandOutputSchema Turn a step's output into an output schema. Takes a source, type and label and provides a description for CWL. Parameters: Name Type Description Default label None name of this field. None typ None either a basic type, compound of basic types, or a TypedDict representing a pre-defined result structure. None output_source None if provided, a CWL step result reference to input here. None Returns: Type Description None CWL CommandOutputSchema-like structure for embedding into an outputs block","title":"to_output_schema"},{"location":"reference/dewret/renderers/cwl/#with_field","text":"def with_field ( result : Any ) -> str Get a string representing any 'field' suffix of a value. This only makes sense in the context of a Reference, which can represent a deep reference with a known variable (parameter or step result, say) using its __field__ attribute. Defaults to \"out\" as this produces compliant CWL where every output has a \"fieldname\". Returns: a string representation of the field portion of the passed value or \"out\" .","title":"with_field"},{"location":"reference/dewret/renderers/cwl/#with_type","text":"def with_type ( result : Any ) -> type | typing . Any Get a Python type from a value. Does so either by using its __type__ field (for example, for References) or if unavailable, using type() . Returns: a Python type.","title":"with_type"},{"location":"reference/dewret/renderers/cwl/#classes","text":"","title":"Classes"},{"location":"reference/dewret/renderers/cwl/#cwlrendererconfiguration","text":"class CWLRendererConfiguration ( / , * args , ** kwargs ) Configuration for the renderer.","title":"CWLRendererConfiguration"},{"location":"reference/dewret/renderers/cwl/#attributes","text":"Name Type Description Default allow_complex_types None can input/output types be other than raw? None factories_as_params None should factories be treated as input or steps? None","title":"Attributes"},{"location":"reference/dewret/renderers/cwl/#ancestors-in-mro","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"reference/dewret/renderers/cwl/#methods","text":"","title":"Methods"},{"location":"reference/dewret/renderers/cwl/#clear","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"reference/dewret/renderers/cwl/#copy","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"reference/dewret/renderers/cwl/#fromkeys","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"reference/dewret/renderers/cwl/#get","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"reference/dewret/renderers/cwl/#items","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"reference/dewret/renderers/cwl/#keys","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"reference/dewret/renderers/cwl/#pop","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError.","title":"pop"},{"location":"reference/dewret/renderers/cwl/#popitem","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"reference/dewret/renderers/cwl/#setdefault","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"reference/dewret/renderers/cwl/#update","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"reference/dewret/renderers/cwl/#values","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"reference/dewret/renderers/cwl/#commandinputschema","text":"class CommandInputSchema ( / , * args , ** kwargs ) Structure for referring to a raw type in CWL. Encompasses several CWL types. In future, it may be best to use cwltool or another library for these basic structures.","title":"CommandInputSchema"},{"location":"reference/dewret/renderers/cwl/#attributes_1","text":"Name Type Description Default type None CWL type of this input. None label None name to show for this input. None fields None (for record ) individual fields in a dict-like structure. None items None (for array ) type that each field will have. None","title":"Attributes"},{"location":"reference/dewret/renderers/cwl/#ancestors-in-mro_1","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"reference/dewret/renderers/cwl/#methods_1","text":"","title":"Methods"},{"location":"reference/dewret/renderers/cwl/#clear_1","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"reference/dewret/renderers/cwl/#copy_1","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"reference/dewret/renderers/cwl/#fromkeys_1","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"reference/dewret/renderers/cwl/#get_1","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"reference/dewret/renderers/cwl/#items_1","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"reference/dewret/renderers/cwl/#keys_1","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"reference/dewret/renderers/cwl/#pop_1","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError.","title":"pop"},{"location":"reference/dewret/renderers/cwl/#popitem_1","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"reference/dewret/renderers/cwl/#setdefault_1","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"reference/dewret/renderers/cwl/#update_1","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"reference/dewret/renderers/cwl/#values_1","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"reference/dewret/renderers/cwl/#commandoutputschema","text":"class CommandOutputSchema ( / , * args , ** kwargs ) Structure for referring to an output in CWL. As a simplification, this is an input schema with an extra outputSource field.","title":"CommandOutputSchema"},{"location":"reference/dewret/renderers/cwl/#attributes_2","text":"Name Type Description Default outputSource None step result to use for this output. None","title":"Attributes"},{"location":"reference/dewret/renderers/cwl/#ancestors-in-mro_2","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"reference/dewret/renderers/cwl/#methods_2","text":"","title":"Methods"},{"location":"reference/dewret/renderers/cwl/#clear_2","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"reference/dewret/renderers/cwl/#copy_2","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"reference/dewret/renderers/cwl/#fromkeys_2","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"reference/dewret/renderers/cwl/#get_2","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"reference/dewret/renderers/cwl/#items_2","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"reference/dewret/renderers/cwl/#keys_2","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"reference/dewret/renderers/cwl/#pop_2","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If the key is not found, return the default if given; otherwise, raise a KeyError.","title":"pop"},{"location":"reference/dewret/renderers/cwl/#popitem_2","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"reference/dewret/renderers/cwl/#setdefault_2","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"reference/dewret/renderers/cwl/#update_2","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"reference/dewret/renderers/cwl/#values_2","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"reference/dewret/renderers/cwl/#inputsdefinition","text":"class InputsDefinition ( inputs : dict [ str , 'CommandInputParameter' ] ) CWL-renderable representation of an input parameter block. Turns dewret results into a CWL input block.","title":"InputsDefinition"},{"location":"reference/dewret/renderers/cwl/#attributes_3","text":"Name Type Description Default input None sequence of results from a workflow. None","title":"Attributes"},{"location":"reference/dewret/renderers/cwl/#class-variables","text":"CommandInputParameter","title":"Class variables"},{"location":"reference/dewret/renderers/cwl/#static-methods","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/cwl/#from_parameters","text":"def from_parameters ( parameters : list [ typing . Union [ dewret . workflow . ParameterReference [ typing . Any ], dewret . workflow . FactoryCall ]] ) -> 'InputsDefinition' Takes a list of parameters into a CWL structure. Uses the parameters to fill out the necessary input fields. Returns: Type Description None CWL-like structure representing all workflow outputs.","title":"from_parameters"},{"location":"reference/dewret/renderers/cwl/#instance-variables","text":"inputs","title":"Instance variables"},{"location":"reference/dewret/renderers/cwl/#methods_3","text":"","title":"Methods"},{"location":"reference/dewret/renderers/cwl/#render_1","text":"def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization.","title":"render"},{"location":"reference/dewret/renderers/cwl/#outputsdefinition","text":"class OutputsDefinition ( outputs : dict [ str , 'CommandOutputSchema' ] | list [ 'CommandOutputSchema' ] | dewret . renderers . cwl . CommandOutputSchema ) CWL-renderable set of workflow outputs. Turns dewret results into a CWL output block.","title":"OutputsDefinition"},{"location":"reference/dewret/renderers/cwl/#attributes_4","text":"Name Type Description Default outputs None sequence of results from a workflow. None","title":"Attributes"},{"location":"reference/dewret/renderers/cwl/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/cwl/#from_results","text":"def from_results ( results : dict [ str , dewret . workflow . StepReference [ typing . Any ]] | list [ dewret . workflow . StepReference [ typing . Any ]] | tuple [ dewret . workflow . StepReference [ typing . Any ], ... ] ) -> 'OutputsDefinition' Takes a mapping of results into a CWL structure. Pulls the result type from the signature, ultimately, if possible. Returns: Type Description None CWL-like structure representing all workflow outputs.","title":"from_results"},{"location":"reference/dewret/renderers/cwl/#instance-variables_1","text":"outputs","title":"Instance variables"},{"location":"reference/dewret/renderers/cwl/#methods_4","text":"","title":"Methods"},{"location":"reference/dewret/renderers/cwl/#render_2","text":"def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] | list [ str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization.","title":"render"},{"location":"reference/dewret/renderers/cwl/#referencedefinition","text":"class ReferenceDefinition ( source : str | None , value_from : str | None ) CWL-renderable internal reference. Normally points to a value or a step.","title":"ReferenceDefinition"},{"location":"reference/dewret/renderers/cwl/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/cwl/#from_reference","text":"def from_reference ( ref : dewret . core . Reference [ typing . Any ] ) -> 'ReferenceDefinition' Build from a Reference . Converts a dewret.workflow.Reference into a CWL-rendering object. Parameters: Name Type Description Default ref None reference to convert. None","title":"from_reference"},{"location":"reference/dewret/renderers/cwl/#instance-variables_2","text":"source value_from","title":"Instance variables"},{"location":"reference/dewret/renderers/cwl/#methods_5","text":"","title":"Methods"},{"location":"reference/dewret/renderers/cwl/#render_3","text":"def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization.","title":"render"},{"location":"reference/dewret/renderers/cwl/#stepdefinition","text":"class StepDefinition ( name : str , run : str , out : dict [ str , 'CommandInputSchema' ] | list [ str ], in_ : collections . abc . Mapping [ str , dewret . renderers . cwl . ReferenceDefinition | dewret . core . Raw ] ) CWL-renderable step. Coerces the dewret structure of a step into that needed for valid CWL.","title":"StepDefinition"},{"location":"reference/dewret/renderers/cwl/#attributes_5","text":"Name Type Description Default name None identifier to call this step by. None run None task to execute for this step. None in_ None inputs from values or other steps. None","title":"Attributes"},{"location":"reference/dewret/renderers/cwl/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/cwl/#from_step","text":"def from_step ( step : dewret . workflow . BaseStep ) -> 'StepDefinition' Build from a BaseStep . Converts a dewret.workflow.Step into a CWL-rendering object. Parameters: Name Type Description Default step None step to convert. None","title":"from_step"},{"location":"reference/dewret/renderers/cwl/#instance-variables_3","text":"in_ name out run","title":"Instance variables"},{"location":"reference/dewret/renderers/cwl/#methods_6","text":"","title":"Methods"},{"location":"reference/dewret/renderers/cwl/#render_4","text":"def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization.","title":"render"},{"location":"reference/dewret/renderers/cwl/#workflowdefinition","text":"class WorkflowDefinition ( steps : list [ dewret . renderers . cwl . StepDefinition ], inputs : dewret . renderers . cwl . InputsDefinition , outputs : dewret . renderers . cwl . OutputsDefinition , name : None | str ) CWL-renderable workflow. Coerces the dewret structure of a workflow into that needed for valid CWL.","title":"WorkflowDefinition"},{"location":"reference/dewret/renderers/cwl/#attributes_6","text":"Name Type Description Default steps None sequence of steps in the workflow. None","title":"Attributes"},{"location":"reference/dewret/renderers/cwl/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/cwl/#from_workflow","text":"def from_workflow ( workflow : dewret . workflow . Workflow , name : None | str = None ) -> 'WorkflowDefinition' Build from a Workflow . Converts a dewret.workflow.Workflow into a CWL-rendering object. Parameters: Name Type Description Default workflow None workflow to convert. None name None name of this workflow, if it should have one. None","title":"from_workflow"},{"location":"reference/dewret/renderers/cwl/#instance-variables_4","text":"inputs name outputs steps","title":"Instance variables"},{"location":"reference/dewret/renderers/cwl/#methods_7","text":"","title":"Methods"},{"location":"reference/dewret/renderers/cwl/#render_5","text":"def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ 'RawType' ] | dict [ str , 'RawType' ]] Render to a dict-like structure. Returns: Type Description None Reduced form as a native Python dict structure for serialization.","title":"render"},{"location":"reference/dewret/renderers/snakemake/","text":"Module dewret.renderers.snakemake Snakemake Renderer. Outputs a Snakemake representation of the current workflow. Variables MainTypes Functions get_method_args def get_method_args ( func : dewret . workflow . Lazy ) -> inspect . Signature Retrieve the argument names and types of a lazy-evaluatable function. Parameters: Name Type Description Default func None A function that adheres to the Lazy protocol. None Returns: Type Description None An ItemsView object containing the argument names and their corresponding inspect.Parameter objects. get_method_rel_path def get_method_rel_path ( func : dewret . workflow . Lazy ) -> Any Get the relative path of the module containing the given function. Parameters: Name Type Description Default func Lazy The function for which the relative path is to be determined. None Returns: Type Description any The relative path of the module containing the function. raw_render def raw_render ( workflow : dewret . workflow . Workflow ) -> dict [ str , str | float | bool | bytes | int | None | list [ str ] | list [ 'MainTypes' ] | dict [ str , 'MainTypes' ]] Render the workflow as a Snakemake (SMK) string. This function converts a Workflow object into a object containing snakemake rules. Parameters: Name Type Description Default workflow Workflow The workflow to be rendered. None Returns: Type Description dict[str, MainTypes] A dictionary containing the components of the Workflow definition, for use in Snakemake workflows. render def render ( workflow : dewret . workflow . Workflow ) -> dict [ str , typing . Any ] Render the workflow as a Snakemake (SMK) string. This function converts a Workflow object into a Snakemake-compatible yaml. Parameters: Name Type Description Default workflow Workflow The workflow to be rendered. None Returns: Type Description str A Snakemake-compatible yaml representation of the workflow. to_snakemake_type def to_snakemake_type ( param : dewret . core . Raw ) -> str Convert a raw type to a corresponding Snakemake-compatible Python type. This function maps raw types to their corresponding Python types as used in Snakemake. Snakemake primarily uses Python types for its parameters, and this function ensures that the provided type is appropriately converted. Parameters: Name Type Description Default param None The raw type to be converted, which can be of any type. None Returns: Type Description None A string representing the corresponding Python type for Snakemake. Raises: Type Description TypeError If the parameter's type cannot be mapped to a known Python type. Classes InputDefinition class InputDefinition ( inputs : list [ str ], params : list [ str ] ) Represents input and parameter definitions block for a Snakemake-renderable workflow step. Attributes Name Type Description Default inputs List[str] A list of input definitions. None params List[str] A list of parameter definitions. None Static methods from_step def from_step ( step : dewret . workflow . BaseStep ) -> 'InputDefinition' Constructs an InputDefinition object from a Step. Parameters: Name Type Description Default step Step The Step object from which input and parameter block definitions are extracted. None Returns: Type Description InputDefinition An InputDefinition object. Instance variables inputs params Methods render def render ( self ) -> dict [ str , list [ str ]] Renders the input and parameter definitions as a dictionary. Returns: Type Description dict[str, list[MainTypes]] A dictionary containing the input and parameter definitions, for use in Snakemake Input and Params blocks. OutputDefinition class OutputDefinition ( output_file : str ) Represents the output definition block for a Snakemake-renderable workflow step. Attributes Name Type Description Default output_file str The output file definition. None Static methods from_step def from_step ( step : dewret . workflow . BaseStep ) -> 'OutputDefinition' Constructs an OutputDefinition object from a Step. Parameters: Name Type Description Default step Step The Step object from which the output file definition is extracted. None Returns: Type Description OutputDefinition An OutputDefinition object, for use in Snakemake Output block. Instance variables output_file Methods render def render ( self ) -> list [ str ] Renders the output definition as a list. Returns: Type Description list[str] A list containing the output file definition, for use in a Snakemake Output block. ReferenceDefinition class ReferenceDefinition ( source : str ) Represents a Snakemake-renderable internal reference. Attributes Name Type Description Default source str The source of the internal reference. None Static methods from_reference def from_reference ( ref : dewret . core . Reference [ typing . Any ] ) -> 'ReferenceDefinition' Build from a Reference . Converts a dewret.workflow.Reference into a Snakemake-rendering object. Parameters: Name Type Description Default ref None reference to convert. None Instance variables source Methods render def render ( self ) -> str Render the internal reference definition as a string. Returns: Type Description str internal reference. RunDefinition class RunDefinition ( method_name : str , rel_import : str , args : list [ str ] ) Represents a Snakemake-renderable run block for a dewret workflow step. Attributes Name Type Description Default method_name str The name of the method to be executed in the snakefile run block. None rel_import str The relative import path of the method. None args List[str] The arguments to be passed to the method. None Static methods from_task def from_task ( task : dewret . workflow . Task | dewret . workflow . Workflow ) -> 'RunDefinition' Constructs a RunDefinition object from a Task. Parameters: Name Type Description Default task Task The Task object from which method information and arguments are extracted. None Returns: Type Description RunDefinition A RunDefinition object containing the converted method information and arguments. Instance variables args method_name rel_import Methods render def render ( self ) -> list [ str ] Renders the run block as a list of strings. Returns: Type Description list[str] A list containing the import statement and the method call statement, for use in Snakemake run block. StepDefinition class StepDefinition ( name : str , run : list [ str ], params : list [ str ], output : list [ str ], input : list [ str ] ) Represents a Snakemake-renderable step definition in a dewret workflow. Attributes Name Type Description Default name str The name of the step. None run str The run block definition for the step. None params List[str] The parameter definitions for the step. None output (list[str] None The output definition for the step. None input List[str] The input definitions for the step. None Static methods from_step def from_step ( step : dewret . workflow . BaseStep ) -> 'StepDefinition' Constructs a StepDefinition object from a Step. Parameters: Name Type Description Default step Step The Step object from which step information and components are extracted. None Returns: Type Description StepDefinition A StepDefinition object containing the converted step information and components. Instance variables input name output params run Methods render def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ str ] | list [ 'MainTypes' ] | dict [ str , 'MainTypes' ]] Renders the step definition as a dictionary. Returns: Type Description dict[str, MainTypes] A dictionary containing the components of the step definition, for use in Snakemake workflows. WorkflowDefinition class WorkflowDefinition ( steps : list [ dewret . renderers . snakemake . StepDefinition ] ) Represents a Snakemake-renderable workflow definition from a dewret workflow. Attributes Name Type Description Default steps List[StepDefinition] A list of StepDefinition objects representing the steps in the workflow. None Static methods from_workflow def from_workflow ( workflow : dewret . workflow . Workflow ) -> 'WorkflowDefinition' Creates a WorkflowDefinition object from a Workflow object. Parameters: Name Type Description Default workflow Workflow The workflow to be rendered. None Returns: Type Description str WorkflowDefinition with definited steps. Instance variables steps Methods render def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ str ] | list [ 'MainTypes' ] | dict [ str , 'MainTypes' ]] Render the WorkflowDefinition. Returns: Type Description dict[str, MainTypes] A dictionary containing the components of the Workflow definition, for use in Snakemake workflows.","title":"Snakemake"},{"location":"reference/dewret/renderers/snakemake/#module-dewretrendererssnakemake","text":"Snakemake Renderer. Outputs a Snakemake representation of the current workflow.","title":"Module dewret.renderers.snakemake"},{"location":"reference/dewret/renderers/snakemake/#variables","text":"MainTypes","title":"Variables"},{"location":"reference/dewret/renderers/snakemake/#functions","text":"","title":"Functions"},{"location":"reference/dewret/renderers/snakemake/#get_method_args","text":"def get_method_args ( func : dewret . workflow . Lazy ) -> inspect . Signature Retrieve the argument names and types of a lazy-evaluatable function. Parameters: Name Type Description Default func None A function that adheres to the Lazy protocol. None Returns: Type Description None An ItemsView object containing the argument names and their corresponding inspect.Parameter objects.","title":"get_method_args"},{"location":"reference/dewret/renderers/snakemake/#get_method_rel_path","text":"def get_method_rel_path ( func : dewret . workflow . Lazy ) -> Any Get the relative path of the module containing the given function. Parameters: Name Type Description Default func Lazy The function for which the relative path is to be determined. None Returns: Type Description any The relative path of the module containing the function.","title":"get_method_rel_path"},{"location":"reference/dewret/renderers/snakemake/#raw_render","text":"def raw_render ( workflow : dewret . workflow . Workflow ) -> dict [ str , str | float | bool | bytes | int | None | list [ str ] | list [ 'MainTypes' ] | dict [ str , 'MainTypes' ]] Render the workflow as a Snakemake (SMK) string. This function converts a Workflow object into a object containing snakemake rules. Parameters: Name Type Description Default workflow Workflow The workflow to be rendered. None Returns: Type Description dict[str, MainTypes] A dictionary containing the components of the Workflow definition, for use in Snakemake workflows.","title":"raw_render"},{"location":"reference/dewret/renderers/snakemake/#render","text":"def render ( workflow : dewret . workflow . Workflow ) -> dict [ str , typing . Any ] Render the workflow as a Snakemake (SMK) string. This function converts a Workflow object into a Snakemake-compatible yaml. Parameters: Name Type Description Default workflow Workflow The workflow to be rendered. None Returns: Type Description str A Snakemake-compatible yaml representation of the workflow.","title":"render"},{"location":"reference/dewret/renderers/snakemake/#to_snakemake_type","text":"def to_snakemake_type ( param : dewret . core . Raw ) -> str Convert a raw type to a corresponding Snakemake-compatible Python type. This function maps raw types to their corresponding Python types as used in Snakemake. Snakemake primarily uses Python types for its parameters, and this function ensures that the provided type is appropriately converted. Parameters: Name Type Description Default param None The raw type to be converted, which can be of any type. None Returns: Type Description None A string representing the corresponding Python type for Snakemake. Raises: Type Description TypeError If the parameter's type cannot be mapped to a known Python type.","title":"to_snakemake_type"},{"location":"reference/dewret/renderers/snakemake/#classes","text":"","title":"Classes"},{"location":"reference/dewret/renderers/snakemake/#inputdefinition","text":"class InputDefinition ( inputs : list [ str ], params : list [ str ] ) Represents input and parameter definitions block for a Snakemake-renderable workflow step.","title":"InputDefinition"},{"location":"reference/dewret/renderers/snakemake/#attributes","text":"Name Type Description Default inputs List[str] A list of input definitions. None params List[str] A list of parameter definitions. None","title":"Attributes"},{"location":"reference/dewret/renderers/snakemake/#static-methods","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/snakemake/#from_step","text":"def from_step ( step : dewret . workflow . BaseStep ) -> 'InputDefinition' Constructs an InputDefinition object from a Step. Parameters: Name Type Description Default step Step The Step object from which input and parameter block definitions are extracted. None Returns: Type Description InputDefinition An InputDefinition object.","title":"from_step"},{"location":"reference/dewret/renderers/snakemake/#instance-variables","text":"inputs params","title":"Instance variables"},{"location":"reference/dewret/renderers/snakemake/#methods","text":"","title":"Methods"},{"location":"reference/dewret/renderers/snakemake/#render_1","text":"def render ( self ) -> dict [ str , list [ str ]] Renders the input and parameter definitions as a dictionary. Returns: Type Description dict[str, list[MainTypes]] A dictionary containing the input and parameter definitions, for use in Snakemake Input and Params blocks.","title":"render"},{"location":"reference/dewret/renderers/snakemake/#outputdefinition","text":"class OutputDefinition ( output_file : str ) Represents the output definition block for a Snakemake-renderable workflow step.","title":"OutputDefinition"},{"location":"reference/dewret/renderers/snakemake/#attributes_1","text":"Name Type Description Default output_file str The output file definition. None","title":"Attributes"},{"location":"reference/dewret/renderers/snakemake/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/snakemake/#from_step_1","text":"def from_step ( step : dewret . workflow . BaseStep ) -> 'OutputDefinition' Constructs an OutputDefinition object from a Step. Parameters: Name Type Description Default step Step The Step object from which the output file definition is extracted. None Returns: Type Description OutputDefinition An OutputDefinition object, for use in Snakemake Output block.","title":"from_step"},{"location":"reference/dewret/renderers/snakemake/#instance-variables_1","text":"output_file","title":"Instance variables"},{"location":"reference/dewret/renderers/snakemake/#methods_1","text":"","title":"Methods"},{"location":"reference/dewret/renderers/snakemake/#render_2","text":"def render ( self ) -> list [ str ] Renders the output definition as a list. Returns: Type Description list[str] A list containing the output file definition, for use in a Snakemake Output block.","title":"render"},{"location":"reference/dewret/renderers/snakemake/#referencedefinition","text":"class ReferenceDefinition ( source : str ) Represents a Snakemake-renderable internal reference.","title":"ReferenceDefinition"},{"location":"reference/dewret/renderers/snakemake/#attributes_2","text":"Name Type Description Default source str The source of the internal reference. None","title":"Attributes"},{"location":"reference/dewret/renderers/snakemake/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/snakemake/#from_reference","text":"def from_reference ( ref : dewret . core . Reference [ typing . Any ] ) -> 'ReferenceDefinition' Build from a Reference . Converts a dewret.workflow.Reference into a Snakemake-rendering object. Parameters: Name Type Description Default ref None reference to convert. None","title":"from_reference"},{"location":"reference/dewret/renderers/snakemake/#instance-variables_2","text":"source","title":"Instance variables"},{"location":"reference/dewret/renderers/snakemake/#methods_2","text":"","title":"Methods"},{"location":"reference/dewret/renderers/snakemake/#render_3","text":"def render ( self ) -> str Render the internal reference definition as a string. Returns: Type Description str internal reference.","title":"render"},{"location":"reference/dewret/renderers/snakemake/#rundefinition","text":"class RunDefinition ( method_name : str , rel_import : str , args : list [ str ] ) Represents a Snakemake-renderable run block for a dewret workflow step.","title":"RunDefinition"},{"location":"reference/dewret/renderers/snakemake/#attributes_3","text":"Name Type Description Default method_name str The name of the method to be executed in the snakefile run block. None rel_import str The relative import path of the method. None args List[str] The arguments to be passed to the method. None","title":"Attributes"},{"location":"reference/dewret/renderers/snakemake/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/snakemake/#from_task","text":"def from_task ( task : dewret . workflow . Task | dewret . workflow . Workflow ) -> 'RunDefinition' Constructs a RunDefinition object from a Task. Parameters: Name Type Description Default task Task The Task object from which method information and arguments are extracted. None Returns: Type Description RunDefinition A RunDefinition object containing the converted method information and arguments.","title":"from_task"},{"location":"reference/dewret/renderers/snakemake/#instance-variables_3","text":"args method_name rel_import","title":"Instance variables"},{"location":"reference/dewret/renderers/snakemake/#methods_3","text":"","title":"Methods"},{"location":"reference/dewret/renderers/snakemake/#render_4","text":"def render ( self ) -> list [ str ] Renders the run block as a list of strings. Returns: Type Description list[str] A list containing the import statement and the method call statement, for use in Snakemake run block.","title":"render"},{"location":"reference/dewret/renderers/snakemake/#stepdefinition","text":"class StepDefinition ( name : str , run : list [ str ], params : list [ str ], output : list [ str ], input : list [ str ] ) Represents a Snakemake-renderable step definition in a dewret workflow.","title":"StepDefinition"},{"location":"reference/dewret/renderers/snakemake/#attributes_4","text":"Name Type Description Default name str The name of the step. None run str The run block definition for the step. None params List[str] The parameter definitions for the step. None output (list[str] None The output definition for the step. None input List[str] The input definitions for the step. None","title":"Attributes"},{"location":"reference/dewret/renderers/snakemake/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/snakemake/#from_step_2","text":"def from_step ( step : dewret . workflow . BaseStep ) -> 'StepDefinition' Constructs a StepDefinition object from a Step. Parameters: Name Type Description Default step Step The Step object from which step information and components are extracted. None Returns: Type Description StepDefinition A StepDefinition object containing the converted step information and components.","title":"from_step"},{"location":"reference/dewret/renderers/snakemake/#instance-variables_4","text":"input name output params run","title":"Instance variables"},{"location":"reference/dewret/renderers/snakemake/#methods_4","text":"","title":"Methods"},{"location":"reference/dewret/renderers/snakemake/#render_5","text":"def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ str ] | list [ 'MainTypes' ] | dict [ str , 'MainTypes' ]] Renders the step definition as a dictionary. Returns: Type Description dict[str, MainTypes] A dictionary containing the components of the step definition, for use in Snakemake workflows.","title":"render"},{"location":"reference/dewret/renderers/snakemake/#workflowdefinition","text":"class WorkflowDefinition ( steps : list [ dewret . renderers . snakemake . StepDefinition ] ) Represents a Snakemake-renderable workflow definition from a dewret workflow.","title":"WorkflowDefinition"},{"location":"reference/dewret/renderers/snakemake/#attributes_5","text":"Name Type Description Default steps List[StepDefinition] A list of StepDefinition objects representing the steps in the workflow. None","title":"Attributes"},{"location":"reference/dewret/renderers/snakemake/#static-methods_5","text":"","title":"Static methods"},{"location":"reference/dewret/renderers/snakemake/#from_workflow","text":"def from_workflow ( workflow : dewret . workflow . Workflow ) -> 'WorkflowDefinition' Creates a WorkflowDefinition object from a Workflow object. Parameters: Name Type Description Default workflow Workflow The workflow to be rendered. None Returns: Type Description str WorkflowDefinition with definited steps.","title":"from_workflow"},{"location":"reference/dewret/renderers/snakemake/#instance-variables_5","text":"steps","title":"Instance variables"},{"location":"reference/dewret/renderers/snakemake/#methods_5","text":"","title":"Methods"},{"location":"reference/dewret/renderers/snakemake/#render_6","text":"def render ( self ) -> dict [ str , str | float | bool | bytes | int | None | list [ str ] | list [ 'MainTypes' ] | dict [ str , 'MainTypes' ]] Render the WorkflowDefinition. Returns: Type Description dict[str, MainTypes] A dictionary containing the components of the Workflow definition, for use in Snakemake workflows.","title":"render"}]}