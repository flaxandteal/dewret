
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.5.4">
    
    
      
        <title>Workflow - dewret</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.80dcb947.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#4cae4f">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="green" data-md-color-accent="lightgreen">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module-dewretworkflow" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="dewret" class="md-header__button md-logo" aria-label="dewret" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            dewret
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Workflow
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/flaxandteal/dewret" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    dewret
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="dewret" class="md-nav__button md-logo" aria-label="dewret" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    dewret
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/flaxandteal/dewret" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    dewret
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/comparison/" class="md-nav__link">
        Comparison
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/eager_execution/" class="md-nav__link">
        Eager Execution
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/glossary/" class="md-nav__link">
        Glossary
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/overview/" class="md-nav__link">
        Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/quickstart/" class="md-nav__link">
        Quickstart
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/renderer_tutorial/" class="md-nav__link">
        Renderer Tutorial
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/renderers/" class="md-nav__link">
        Renderers
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../docs/workflows/" class="md-nav__link">
        Workflows
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10" type="checkbox" id="__nav_10" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_10">
          Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_10">
          <span class="md-nav__icon md-icon"></span>
          Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10_1" type="checkbox" id="__nav_10_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_10_1">
          Dewret
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Dewret" data-md-level="2">
        <label class="md-nav__title" for="__nav_10_1">
          <span class="md-nav__icon md-icon"></span>
          Dewret
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../annotations/" class="md-nav__link">
        Annotations
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cli/" class="md-nav__link">
        CLI
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../core/" class="md-nav__link">
        Core
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../render/" class="md-nav__link">
        Render
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tasks/" class="md-nav__link">
        Tasks
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        Utils
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Workflow
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Workflow
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#variables" class="md-nav__link">
    Variables
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#execute_step" class="md-nav__link">
    execute_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expr_to_references" class="md-nav__link">
    expr_to_references
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_task" class="md-nav__link">
    is_task
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#param" class="md-nav__link">
    param
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unify_workflows" class="md-nav__link">
    unify_workflows
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basestep" class="md-nav__link">
    BaseStep
  </a>
  
    <nav class="md-nav" aria-label="BaseStep">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#attributes" class="md-nav__link">
    Attributes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#descendants" class="md-nav__link">
    Descendants
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_reference" class="md-nav__link">
    make_reference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_workflow" class="md-nav__link">
    set_workflow
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#factorycall" class="md-nav__link">
    FactoryCall
  </a>
  
    <nav class="md-nav" aria-label="FactoryCall">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_1" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables_1" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables_1" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods_1" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_reference_1" class="md-nav__link">
    make_reference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_workflow_1" class="md-nav__link">
    set_workflow
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fieldablemixin" class="md-nav__link">
    FieldableMixin
  </a>
  
    <nav class="md-nav" aria-label="FieldableMixin">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#descendants_1" class="md-nav__link">
    Descendants
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods_2" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#find_field" class="md-nav__link">
    find_field
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fieldableprotocol" class="md-nav__link">
    FieldableProtocol
  </a>
  
    <nav class="md-nav" aria-label="FieldableProtocol">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#attributes_1" class="md-nav__link">
    Attributes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_2" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables_2" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterableparameterreference" class="md-nav__link">
    IterableParameterReference
  </a>
  
    <nav class="md-nav" aria-label="IterableParameterReference">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_3" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables_2" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static-methods" class="md-nav__link">
    Static methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class_key" class="md-nav__link">
    class_key
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fromiter" class="md-nav__link">
    fromiter
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10_1_9" type="checkbox" id="__nav_10_1_9" >
      
      
      
      
        <label class="md-nav__link" for="__nav_10_1_9">
          Backends
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Backends" data-md-level="3">
        <label class="md-nav__title" for="__nav_10_1_9">
          <span class="md-nav__icon md-icon"></span>
          Backends
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../backends/backend_dask/" class="md-nav__link">
        Backend Dask
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../backends/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10_1_10" type="checkbox" id="__nav_10_1_10" >
      
      
      
      
        <label class="md-nav__link" for="__nav_10_1_10">
          Renderers
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Renderers" data-md-level="3">
        <label class="md-nav__title" for="__nav_10_1_10">
          <span class="md-nav__icon md-icon"></span>
          Renderers
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../renderers/cwl/" class="md-nav__link">
        Cwl
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../renderers/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../renderers/snakemake/" class="md-nav__link">
        Snakemake
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#variables" class="md-nav__link">
    Variables
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#execute_step" class="md-nav__link">
    execute_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expr_to_references" class="md-nav__link">
    expr_to_references
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_task" class="md-nav__link">
    is_task
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#param" class="md-nav__link">
    param
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unify_workflows" class="md-nav__link">
    unify_workflows
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basestep" class="md-nav__link">
    BaseStep
  </a>
  
    <nav class="md-nav" aria-label="BaseStep">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#attributes" class="md-nav__link">
    Attributes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#descendants" class="md-nav__link">
    Descendants
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_reference" class="md-nav__link">
    make_reference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_workflow" class="md-nav__link">
    set_workflow
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#factorycall" class="md-nav__link">
    FactoryCall
  </a>
  
    <nav class="md-nav" aria-label="FactoryCall">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_1" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables_1" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables_1" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods_1" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_reference_1" class="md-nav__link">
    make_reference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_workflow_1" class="md-nav__link">
    set_workflow
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fieldablemixin" class="md-nav__link">
    FieldableMixin
  </a>
  
    <nav class="md-nav" aria-label="FieldableMixin">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#descendants_1" class="md-nav__link">
    Descendants
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods_2" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#find_field" class="md-nav__link">
    find_field
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fieldableprotocol" class="md-nav__link">
    FieldableProtocol
  </a>
  
    <nav class="md-nav" aria-label="FieldableProtocol">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#attributes_1" class="md-nav__link">
    Attributes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_2" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables_2" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterableparameterreference" class="md-nav__link">
    IterableParameterReference
  </a>
  
    <nav class="md-nav" aria-label="IterableParameterReference">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_3" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables_2" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static-methods" class="md-nav__link">
    Static methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class_key" class="md-nav__link">
    class_key
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fromiter" class="md-nav__link">
    fromiter
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  <a href="https://github.com/flaxandteal/dewret/edit/main/reference/dewret/workflow.md" title="Edit this page" class="md-content__button md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>


<h1 id="module-dewretworkflow">Module dewret.workflow</h1>
<p>Overarching workflow concepts.</p>
<p>Basic constructs for describing a workflow.</p>
<h2 id="variables">Variables</h2>
<div class="highlight"><pre><span></span><code><span class="n">AVAILABLE_TYPES</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">CHECK_IDS</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">LazyFactory</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Param</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">RetType</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">StepExecution</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">T</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">TYPE_CHECKING</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Target</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">U</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">UNSET</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">logger</span>
</code></pre></div>
<h2 id="functions">Functions</h2>
<h3 id="execute_step">execute_step</h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">execute_step</span><span class="p">(</span>
    <span class="n">task</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Any&#39;</span>
</code></pre></div>
<p>Evaluate a single task for a known workflow.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>task</td>
<td>None</td>
<td>the task to evaluate.</td>
<td>None</td>
</tr>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>any arguments to pass to the task.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h3 id="expr_to_references">expr_to_references</h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">expr_to_references</span><span class="p">(</span>
    <span class="n">expression</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
    <span class="n">remap</span><span class="p">:</span> <span class="s1">&#39;Callable[[Any], Any] | None&#39;</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[ExprType, list[Reference[Any] | Parameter[Any]]]&#39;</span>
</code></pre></div>
<p>Pull out any references, or other free symbols, from an expression.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>expression</td>
<td>None</td>
<td>normally a reference that can be immediately returned, but may be a sympy expression or a dict/tuple/list/etc. of such.</td>
<td>None</td>
</tr>
<tr>
<td>remap</td>
<td>None</td>
<td>a callable to project certain values down before extracting symbols, or None.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h3 id="is_task">is_task</h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_task</span><span class="p">(</span>
    <span class="n">task</span><span class="p">:</span> <span class="s1">&#39;Lazy&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;bool&#39;</span>
</code></pre></div>
<p>Decide whether this is a task.</p>
<p>Checks whether the wrapped function has the magic
attribute <code>__step_expression__</code> set to True, which is
done within task creation.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>task</td>
<td>None</td>
<td>lazy-evaluated value, suspected to be a task.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>True if <code>task</code> is indeed a task.</td>
</tr>
</tbody>
</table>
<h3 id="param">param</h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">param</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;str&#39;</span><span class="p">,</span>
    <span class="n">default</span><span class="p">:</span> <span class="s1">&#39;T | UnsetType[T] | Unset&#39;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">dewret</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">Unset</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f2d6ea66910</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tethered</span><span class="p">:</span> <span class="s1">&#39;Literal[False] | None | Step | Workflow&#39;</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">typ</span><span class="p">:</span> <span class="s1">&#39;type[T] | Unset&#39;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">dewret</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">Unset</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f2d6ea66910</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">autoname</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;T&#39;</span>
</code></pre></div>
<p>Create a parameter.</p>
<p>Will cast so it looks like the original type.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>Parameter class cast to the type of the supplied default.</td>
</tr>
</tbody>
</table>
<h3 id="unify_workflows">unify_workflows</h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">unify_workflows</span><span class="p">(</span>
    <span class="n">expression</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
    <span class="n">base_workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow | None&#39;</span><span class="p">,</span>
    <span class="n">set_only</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Basic | None, Workflow | None]&#39;</span>
</code></pre></div>
<p>Takes an expression and ensures all of its references exist in the same workflow.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>expression</td>
<td>None</td>
<td>any valid argument to <code>dewret.workflow.expr_to_references</code>.</td>
<td>None</td>
</tr>
<tr>
<td>base_workflow</td>
<td>None</td>
<td>the desired workflow to align on, or None.</td>
<td>None</td>
</tr>
<tr>
<td>set_only</td>
<td>None</td>
<td>whether to bother assimilating all the workflows (False), or to assume that has been done (False).</td>
<td>None</td>
</tr>
</tbody>
</table>
<h2 id="classes">Classes</h2>
<h3 id="basestep">BaseStep</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BaseStep</span><span class="p">(</span>
    <span class="n">workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">task</span><span class="p">:</span> <span class="s1">&#39;Task | Workflow&#39;</span><span class="p">,</span>
    <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Mapping[str, Reference[Any] | Raw]&#39;</span><span class="p">,</span>
    <span class="n">raw_as_parameter</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Lazy-evaluated function call.</p>
<p>Individual function call to a lazy-evaluatable function, tracked
for building up the <code>Workflow</code>.</p>
<h4 id="attributes">Attributes</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>task</td>
<td>None</td>
<td>the <code>Task</code> being called in this step.</td>
<td>None</td>
</tr>
<tr>
<td>arguments</td>
<td>None</td>
<td>key-value pairs of arguments to this step.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="ancestors-in-mro">Ancestors (in MRO)</h4>
<ul>
<li>dewret.core.WorkflowComponent</li>
</ul>
<h4 id="descendants">Descendants</h4>
<ul>
<li>dewret.workflow.NestedStep</li>
<li>dewret.workflow.Step</li>
</ul>
<h4 id="class-variables">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">positional_args</span>
</code></pre></div>
<h4 id="instance-variables">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="nb">id</span>
</code></pre></div>
<p>Consistent ID based on the value.</p>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Name for this step.</p>
<p>May be remapped by the workflow to something nicer
than the ID.</p>
<div class="highlight"><pre><span></span><code><span class="n">return_type</span>
</code></pre></div>
<p>Take the type of the wrapped function from the target.</p>
<p>Unwraps and inspects the signature, meaning that the original
wrapped function <em>must</em> have a typehint for the return value.</p>
<h4 id="methods">Methods</h4>
<h4 id="make_reference">make_reference</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_reference</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;&#39;StepReference[T]&#39;&quot;</span>
</code></pre></div>
<p>Create a reference to this step.</p>
<p>Builds a reference to the (result of) this step, which will be iterable if appropriate.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>arguments for reference constructor, which will be supplemented appropriately.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="set_workflow">set_workflow</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set_workflow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">with_arguments</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;None&#39;</span>
</code></pre></div>
<p>Move the step reference to another workflow.</p>
<p>This method is primarily intended to be called by a step, allowing it to
switch to a new workflow. It also updates the workflow reference for any
arguments that are steps themselves, if specified.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>workflow</td>
<td>None</td>
<td>The new target workflow to which the step should be moved.</td>
<td>None</td>
</tr>
<tr>
<td>with_arguments</td>
<td>None</td>
<td>If True, also update the workflow reference for the step's arguments.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h3 id="factorycall">FactoryCall</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FactoryCall</span><span class="p">(</span>
    <span class="n">workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">task</span><span class="p">:</span> <span class="s1">&#39;Task | Workflow&#39;</span><span class="p">,</span>
    <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Mapping[str, Reference[Any] | Raw]&#39;</span><span class="p">,</span>
    <span class="n">raw_as_parameter</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Call to a factory function.</p>
<h4 id="ancestors-in-mro_1">Ancestors (in MRO)</h4>
<ul>
<li>dewret.workflow.Step</li>
<li>dewret.workflow.BaseStep</li>
<li>dewret.core.WorkflowComponent</li>
</ul>
<h4 id="class-variables_1">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">positional_args</span>
</code></pre></div>
<h4 id="instance-variables_1">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="nb">id</span>
</code></pre></div>
<p>Consistent ID based on the value.</p>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Name for this step.</p>
<p>May be remapped by the workflow to something nicer
than the ID.</p>
<div class="highlight"><pre><span></span><code><span class="n">return_type</span>
</code></pre></div>
<p>Take the type of the wrapped function from the target.</p>
<p>Unwraps and inspects the signature, meaning that the original
wrapped function <em>must</em> have a typehint for the return value.</p>
<h4 id="methods_1">Methods</h4>
<h4 id="make_reference_1">make_reference</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_reference</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;&#39;StepReference[T]&#39;&quot;</span>
</code></pre></div>
<p>Create a reference to this step.</p>
<p>Builds a reference to the (result of) this step, which will be iterable if appropriate.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>arguments for reference constructor, which will be supplemented appropriately.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="set_workflow_1">set_workflow</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set_workflow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">with_arguments</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;None&#39;</span>
</code></pre></div>
<p>Move the step reference to another workflow.</p>
<p>This method is primarily intended to be called by a step, allowing it to
switch to a new workflow. It also updates the workflow reference for any
arguments that are steps themselves, if specified.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>workflow</td>
<td>None</td>
<td>The new target workflow to which the step should be moved.</td>
<td>None</td>
</tr>
<tr>
<td>with_arguments</td>
<td>None</td>
<td>If True, also update the workflow reference for the step's arguments.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h3 id="fieldablemixin">FieldableMixin</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FieldableMixin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s1">&#39;FieldableProtocol&#39;</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;str | int | tuple[str | int, ...] | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Tooling for enhancing a type with referenceable fields.</p>
<h4 id="descendants_1">Descendants</h4>
<ul>
<li>dewret.workflow.ParameterReference</li>
<li>dewret.workflow.StepReference</li>
</ul>
<h4 id="methods_2">Methods</h4>
<h4 id="find_field">find_field</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_field</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s1">&#39;FieldableProtocol&#39;</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;str | int&#39;</span><span class="p">,</span>
    <span class="n">fallback_type</span><span class="p">:</span> <span class="s1">&#39;type | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">init_kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Reference[Any]&#39;</span>
</code></pre></div>
<p>Field within the reference, if possible.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>field</td>
<td>None</td>
<td>the field to search for.</td>
<td>None</td>
</tr>
<tr>
<td>fallback_type</td>
<td>None</td>
<td>the type to use if we do not know a more specific one.</td>
<td>None</td>
</tr>
<tr>
<td>**init_kwargs</td>
<td>None</td>
<td>arguments to use for constructing a new reference (via <code>__make_reference__</code>).</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A field-specific version of this reference.</td>
</tr>
</tbody>
</table>
<h3 id="fieldableprotocol">FieldableProtocol</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FieldableProtocol</span><span class="p">(</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;str | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Expected interfaces for a type that can take fields.</p>
<h4 id="attributes_1">Attributes</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>field</strong></td>
<td>None</td>
<td>tuple representing the named fields, either strings or integers.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="ancestors-in-mro_2">Ancestors (in MRO)</h4>
<ul>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h4 id="instance-variables_2">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>The name for the target, accounting for the field.</p>
<h3 id="iterableparameterreference">IterableParameterReference</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">IterableParameterReference</span><span class="p">(</span>
    <span class="n">typ</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="o">~</span><span class="n">U</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
<span class="p">)</span>
</code></pre></div>
<p>Iterable form of parameter references.</p>
<h4 id="ancestors-in-mro_3">Ancestors (in MRO)</h4>
<ul>
<li>dewret.core.IterableMixin</li>
<li>dewret.workflow.ParameterReference</li>
<li>dewret.workflow.FieldableMixin</li>
<li>dewret.core.Reference</li>
<li>typing.Generic</li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.printing.defaults.Printable</li>
<li>sympy.core.evalf.EvalfMixin</li>
<li>dewret.core.WorkflowComponent</li>
</ul>
<h4 id="class-variables_2">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">ParameterReferenceMetadata</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">default_assumptions</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Add</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_AlgebraicNumber</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Atom</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Boolean</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Derivative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Dummy</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Equality</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Float</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Function</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Indexed</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatAdd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatMul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Matrix</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Mul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Not</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_NumberSymbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Order</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Piecewise</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Point</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Poly</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Pow</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Relational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Symbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Vector</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Wild</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_comparable</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_scalar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_symbol</span>
</code></pre></div>
<h4 id="static-methods">Static methods</h4>
<h4 id="class_key">class_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">class_key</span><span class="p">(</span>
    
<span class="p">)</span>
</code></pre></div>
<p>Nice order of classes.</p>
<h4 id="fromiter">fromiter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fromiter</span><span class="p">(</span>
    <span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<h1 id="examples">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Tuple
Tuple.fromiter(i for i in range(5))
(0, 1, 2, 3, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="instance-variables_3">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">args</span>
</code></pre></div>
<p>Returns a tuple of arguments of 'self'.</p>
<h1 id="examples_1">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cot
from sympy.abc import x, y</p>
<p>cot(x).args
(x,)</p>
<p>cot(x).args[0]
x</p>
<p>(x*y).args
(x, y)</p>
<p>(x*y).args[1]
y</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes">Notes</h1>
<p>Never use self._args, always use self.args.
Only use _args in <strong>new</strong> when creating a new function.
Do not override .args() from Basic (so that it is easy to
change the interface in the future if needed).</p>
<div class="highlight"><pre><span></span><code><span class="n">assumptions0</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">binary_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">canonical_variables</span>
</code></pre></div>
<p>Return a dictionary mapping any variable defined in</p>
<p><code>self.bound_symbols</code> to Symbols that do not clash
with any free symbols in the expression.</p>
<h1 id="examples_2">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x
Lambda(x, 2*x).canonical_variables
{x: _0}</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">expr_free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">func</span>
</code></pre></div>
<p>The top-level function in an expression.</p>
<p>The following should hold for all objects::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt; x == x.func(*x.args)
</code></pre></div>
<h1 id="examples_3">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
a = 2<em>x
a.func
<class 'sympy.core.mul.Mul'>
a.args
(2, x)
a.func(</em>a.args)
2<em>x
a == a.func(</em>a.args)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">is_algebraic</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_antihermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_commutative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_complex</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_composite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_even</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_finite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_hermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_imaginary</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_infinite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_irrational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_noninteger</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_odd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_polar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_prime</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_transcendental</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_zero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">kind</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Printable name of the reference.</p>
<h4 id="methods_3">Methods</h4>
<h4 id="adjoint">adjoint</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">adjoint</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="apart">apart</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apart</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the apart function in sympy.polys</p>
<h4 id="args_cnc">args_cnc</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">args_cnc</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">split_1</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Return [commutative factors, non-commutative factors] of self.</p>
<h1 id="explanation">Explanation</h1>
<p>self is treated as a Mul and the ordering of the factors is maintained.
If <code>cset</code> is True the commutative factors will be returned in a set.
If there were repeated factors (as may happen with an unevaluated Mul)
then an error will be raised unless it is explicitly suppressed by
setting <code>warn</code> to False.</p>
<p>Note: -1 is always separated from a Number unless split_1 is False.</p>
<h1 id="examples_4">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, oo
A, B = symbols('A B', commutative=0)
x, y = symbols('x y')
(-2<em>x</em>y).args_cnc()
[[-1, 2, x, y], []]
(-2.5<em>x).args_cnc()
[[-1, 2.5, x], []]
(-2</em>x<em>A</em>B<em>y).args_cnc()
[[-1, 2, x, y], [A, B]]
(-2</em>x<em>A</em>B<em>y).args_cnc(split_1=False)
[[-2, x, y], [A, B]]
(-2</em>x*y).args_cnc(cset=True)
[{-1, 2, x, y}, []]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The arg is always treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-2 + x + A).args_cnc()
[[], [x - 2 + A]]
(-oo).args_cnc() # -oo is a singleton
[[-1, oo], []]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_base_exp">as_base_exp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_base_exp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<h4 id="as_coeff_add">as_coeff_Add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a summation.</p>
<h4 id="as_coeff_mul">as_coeff_Mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a product.</p>
<h4 id="as_coeff_add_1">as_coeff_add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as an Add, <code>a</code>.</p>
<p>c should be a Rational added to any terms of the Add that are
independent of deps.</p>
<p>args should be a tuple of all other terms of <code>a</code>; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is an Add or not but
you want to treat self as an Add or if you want to process the
individual arguments of the tail of self as an Add.</p>
<ul>
<li>if you know self is an Add and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail.</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_add()
(3, ())
(3 + x).as_coeff_add()
(3, (x,))
(3 + x + y).as_coeff_add(x)
(y + 3, (x,))
(3 + y).as_coeff_add(x)
(y + 3, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coeff_exponent">as_coeff_exponent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_exponent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p><code>c*x**e -&gt; c,e</code> where x can be any symbolic expression.</p>
<h4 id="as_coeff_mul_1">as_coeff_mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as a Mul, <code>m</code>.</p>
<p>c should be a Rational multiplied by any factors of the Mul that are
independent of deps.</p>
<p>args should be a tuple of all other factors of m; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is a Mul or not but
you want to treat self as a Mul or if you want to process the
individual arguments of the tail of self as a Mul.</p>
<ul>
<li>if you know self is a Mul and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail;</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_mul()
(3, ())
(3<em>x</em>y).as_coeff_mul()
(3, (x, y))
(3<em>x</em>y).as_coeff_mul(x)
(3<em>y, (x,))
(3</em>y).as_coeff_mul(x)
(3*y, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coefficient">as_coefficient</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Extracts symbolic coefficient at the given expression. In</p>
<p>other words, this functions separates 'self' into the product
of 'expr' and 'expr'-free coefficient. If such separation
is not possible it will return None.</p>
<h1 id="examples_5">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import E, pi, sin, I, Poly
from sympy.abc import x</p>
<p>E.as_coefficient(E)
1
(2<em>E).as_coefficient(E)
2
(2</em>sin(E)*E).as_coefficient(E)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two terms have E in them so a sum is returned. (If one were
desiring the coefficient of the term exactly matching E then
the constant from the returned expression could be selected.
Or, for greater precision, a method of Poly can be used to
indicate the desired term from which the coefficient is
desired.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E + x</em>E).as_coefficient(E)
x + 2
_.args[0]  # just want the exact match
2
p = Poly(2<em>E + x</em>E); p
Poly(x<em>E + 2</em>E, x, E, domain='ZZ')
p.coeff_monomial(E)
2
p.nth(0, 1)
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since the following cannot be written as a product containing
E as a factor, None is returned. (If the coefficient <code>2*x</code> is
desired then the <code>coeff</code> method should be used.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E</em>x + x).as_coefficient(E)
(2<em>E</em>x + x).coeff(E)
2*x</p>
<p>(E*(x + 1) + x).as_coefficient(E)</p>
<p>(2<em>pi</em>I).as_coefficient(pi<em>I)
2
(2</em>I).as_coefficient(pi*I)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also">See Also</h1>
<p>coeff: return sum of terms have a given factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="as_coefficients_dict">as_coefficients_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficients_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a dictionary mapping terms to their Rational coefficient.</p>
<p>Since the dictionary is a defaultdict, inquiries about terms which
were not present will return a coefficient of 0.</p>
<p>If symbols <code>syms</code> are provided, any multiplicative terms
independent of them will be considered a coefficient and a
regular dictionary of syms-dependent generators as keys and
their corresponding coefficients as values will be returned.</p>
<h1 id="examples_6">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import a, x, y
(3<em>x + a</em>x + 4).as_coefficients_dict()
{1: 4, x: 3, a<em>x: 1}
_[a]
0
(3</em>a<em>x).as_coefficients_dict()
{a</em>x: 3}
(3<em>a</em>x).as_coefficients_dict(x)
{x: 3<em>a}
(3</em>a<em>x).as_coefficients_dict(y)
{1: 3</em>a*x}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_content_primitive">as_content_primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_content_primitive</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">radical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">clear</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>This method should recursively remove a Rational from all arguments</p>
<p>and return that (content) and the new self (primitive). The content
should always be positive and <code>Mul(*foo.as_content_primitive()) == foo</code>.
The primitive need not be in canonical form and should try to preserve
the underlying structure if possible (i.e. expand_mul should not be
applied to self).</p>
<h1 id="examples_7">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt
from sympy.abc import x, y, z</p>
<p>eq = 2 + 2<em>x + 2</em>y<em>(3 + 3</em>y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The as_content_primitive function is recursive and retains structure:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eq.as_content_primitive()
(2, x + 3<em>y</em>(y + 1) + 1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Integer powers will have Rationals extracted from the base:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((2 + 6<em>x)</em><em>2).as_content_primitive()
(4, (3</em>x + 1)<strong>2)
((2 + 6*x)</strong>(2<em>y)).as_content_primitive()
(1, (2</em>(3<em>x + 1))</em><em>(2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Terms may end up joining once their as_content_primitives are added:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((5<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(11, x</em>(y + 1))
((3<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(9, x</em>(y + 1))
((3<em>(z</em>(1 + y)) + 2.0<em>x</em>(3 + 3<em>y))).as_content_primitive()
(1, 6.0</em>x<em>(y + 1) + 3</em>z<em>(y + 1))
((5</em>(x<em>(1 + y)) + 2</em>x<em>(3 + 3</em>y))<strong>2).as_content_primitive()
(121, x</strong>2<em>(y + 1)</em><em>2)
((x</em>(1 + y) + 0.4<em>x</em>(3 + 3<em>y))</em><em>2).as_content_primitive()
(1, 4.84</em>x<strong>2*(y + 1)</strong>2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Radical content can also be factored out of the primitive:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>sqrt(2) + 4</em>sqrt(10)).as_content_primitive(radical=True)
(2, sqrt(2)<em>(1 + 2</em>sqrt(5)))</p>
</blockquote>
</blockquote>
</blockquote>
<p>If clear=False (default is True) then content will not be removed
from an Add if it can be distributed to leave one or more
terms with integer coefficients.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/2 + y).as_content_primitive()
(1/2, x + 2*y)
(x/2 + y).as_content_primitive(clear=False)
(1, x/2 + y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_dummy">as_dummy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_dummy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression with any objects having structurally</p>
<p>bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<h1 id="examples_8">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Symbol
from sympy.abc import x
r = Symbol('r', real=True)
Integral(r, (r, x)).as_dummy()
Integral(<em>0, (_0, x))
</em>.variables[0].is_real is None
True
r.as_dummy()
_r</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_1">Notes</h1>
<p>Any object that has structurally bound variables should have
a property, <code>bound_symbols</code> that returns those symbols
appearing in the object.</p>
<h4 id="as_expr">as_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span>
<span class="p">)</span>
</code></pre></div>
<p>Convert a polynomial to a SymPy expression.</p>
<h1 id="examples_9">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>f = (x<strong>2 + x*y).as_poly(x, y)
f.as_expr()
x</strong>2 + x*y</p>
<p>sin(x).as_expr()
sin(x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_independent">as_independent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_independent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hint</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>A mostly naive separation of a Mul or Add into arguments that are not</p>
<p>are dependent on deps. To obtain as complete a separation of variables
as possible, use a separation method first, e.g.:</p>
<ul>
<li>separatevars() to change Mul, Add and Pow (including exp) into Mul</li>
<li>.expand(mul=True) to change Add or Mul into Add</li>
<li>.expand(log=True) to change log expr into an Add</li>
</ul>
<p>The only non-naive thing that is done here is to respect noncommutative
ordering of variables and to always return (0, 0) for <code>self</code> of zero
regardless of hints.</p>
<p>For nonzero <code>self</code>, the returned tuple (i, d) has the
following interpretation:</p>
<ul>
<li>i will has no variable that appears in deps</li>
<li>d will either have terms that contain variables that are in deps, or
  be equal to 0 (when self is an Add) or 1 (when self is a Mul)</li>
<li>if self is an Add then self = i + d</li>
<li>if self is a Mul then self = i*d</li>
<li>otherwise (self, S.One) or (S.One, self) is returned.</li>
</ul>
<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>
<h1 id="examples_10">Examples</h1>
<p>-- self is an Add</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos, exp
from sympy.abc import x, y, z</p>
<p>(x + x<em>y).as_independent(x)
(0, x</em>y + x)
(x + x<em>y).as_independent(y)
(x, x</em>y)
(2<em>x</em>sin(x) + y + x + z).as_independent(x)
(y + z, 2<em>x</em>sin(x) + x)
(2<em>x</em>sin(x) + y + x + z).as_independent(x, y)
(z, 2<em>x</em>sin(x) + x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>sin(x)</em>cos(y)).as_independent(x)
(cos(y), x*sin(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>non-commutative terms cannot always be separated out when self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
(n1 + n1<em>n2).as_independent(n2)
(n1, n1</em>n2)
(n2<em>n1 + n1</em>n2).as_independent(n2)
(0, n1<em>n2 + n2</em>n1)
(n1<em>n2</em>n3).as_independent(n1)
(1, n1<em>n2</em>n3)
(n1<em>n2</em>n3).as_independent(n2)
(n1, n2<em>n3)
((x-n1)</em>(x-y)).as_independent(x)
(1, (x - y)*(x - n1))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is anything else:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(sin(x)).as_independent(x)
(1, sin(x))
(sin(x)).as_independent(y)
(sin(x), 1)
exp(x+y).as_independent(x)
(1, exp(x + y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as an Add:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3<em>x).as_independent(x, as_Add=True)
(0, 3</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3+x).as_independent(x, as_Add=False)
(1, x + 3)
(-3+x).as_independent(x, as_Add=False)
(1, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note how the below differs from the above in making the
constant on the dep term positive.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(y*(-3+x)).as_independent(x)
(y, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- use .as_independent() for true independence testing instead
   of .has(). The former considers only symbols in the free
   symbols while the latter considers all symbols</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
I = Integral(x, (x, 1, 2))
I.has(x)
True
x in I.free_symbols
False
I.as_independent(x) == (I, 1)
True
(I + x).as_independent(x) == (I, x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note: when trying to get independent terms, a separation method
might need to be used first. In this case, it is important to keep
track of what you send to this routine so you know how to interpret
the returned values</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import separatevars, log
separatevars(exp(x+y)).as_independent(x)
(exp(y), exp(x))
(x + x<em>y).as_independent(y)
(x, x</em>y)
separatevars(x + x<em>y).as_independent(y)
(x, y + 1)
(x</em>(1 + y)).as_independent(y)
(x, y + 1)
(x<em>(1 + y)).expand(mul=True).as_independent(y)
(x, x</em>y)
a, b=symbols('a b', positive=True)
(log(a*b).expand(log=True)).as_independent(b)
(log(a), log(b))</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_1">See Also</h1>
<p>separatevars
expand_log
sympy.core.add.Add.as_two_terms
sympy.core.mul.Mul.as_two_terms
as_coeff_mul</p>
<h4 id="as_leading_term">as_leading_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_leading_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading (nonzero) term of the series expansion of self.</p>
<p>The _eval_as_leading_term routines are used to do this, and they must
always return a non-zero value.</p>
<h1 id="examples_11">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1 + x + x<strong>2).as_leading_term(x)
1
(1/x</strong>2 + x + x<strong>2).as_leading_term(x)
x</strong>(-2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_numer_denom">as_numer_denom</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_numer_denom</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>Return the numerator and the denominator of an expression.</p>
<p>expression -&gt; a/b -&gt; a, b</p>
<p>This is just a stub that should be defined by
an object's class methods to get anything else.</p>
<h1 id="see-also_2">See Also</h1>
<p>normal: return <code>a/b</code> instead of <code>(a, b)</code></p>
<h4 id="as_ordered_factors">as_ordered_factors</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_factors</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return list of ordered factors (if Mul) else [self].</p>
<h4 id="as_ordered_terms">as_ordered_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_terms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to an ordered list of terms.</p>
<h1 id="examples_12">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos
from sympy.abc import x</p>
<p>(sin(x)<strong>2*cos(x) + sin(x)</strong>2 + 1).as_ordered_terms()
[sin(x)<strong>2*cos(x), sin(x)</strong>2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_poly">as_poly</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_poly</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Converts <code>self</code> to a polynomial or returns <code>None</code>.</p>
<h1 id="explanation_1">Explanation</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>print((x<strong>2 + x*y).as_poly())
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x<strong>2 + x*y).as_poly(x, y))
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x**2 + sin(y)).as_poly(x, y))
None</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_powers_dict">as_powers_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_powers_dict</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self as a dictionary of factors with each factor being</p>
<p>treated as a power. The keys are the bases of the factors and the
values, the corresponding exponents. The resulting dictionary should
be used with caution if the expression is a Mul and contains non-
commutative factors since the order that they appeared will be lost in
the dictionary.</p>
<h1 id="see-also_3">See Also</h1>
<p>as_ordered_factors: An alternative for noncommutative applications,
                    returning an ordered list of factors.
args_cnc: Similar to as_ordered_factors, but guarantees separation
          of commutative and noncommutative factors.</p>
<h4 id="as_real_imag">as_real_imag</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_real_imag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Performs complex expansion on 'self' and returns a tuple</p>
<p>containing collected both real and imaginary parts. This
method cannot be confused with re() and im() functions,
which does not perform complex expansion at evaluation.</p>
<p>However it is possible to expand both re() and im()
functions and get exactly the same results as with
a single call to this function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, I</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>(x + y*I).as_real_imag()
(x, y)</p>
<p>from sympy.abc import z, w</p>
<p>(z + w*I).as_real_imag()
(re(z) - im(w), re(w) + im(z))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_set">as_set</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_set</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrites Boolean expression in terms of real sets.</p>
<h1 id="examples_13">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Eq, Or, And
x = Symbol('x', real=True)
Eq(x, 0).as_set()
{0}
(x &gt; 0).as_set()
Interval.open(0, oo)
And(-2 &lt; x, x &lt; 2).as_set()
Interval.open(-2, 2)
Or(x &lt; -2, 2 &lt; x).as_set()
Union(Interval.open(-oo, -2), Interval.open(2, oo))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_terms">as_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_terms</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to a list of terms. </p>
<h4 id="aseries">aseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">aseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">hir</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Asymptotic Series expansion of self.</p>
<p>This is equivalent to <code>self.series(x, oo, n)</code>.</p>
<h1 id="parameters">Parameters</h1>
<p>self : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>hir : Boolean
      Set this parameter to be True to produce hierarchical series.
      It stops the recursion at an early level and may provide nicer
      and more useful results.</p>
<p>bound : Value, Integer
        Use the <code>bound</code> parameter to give limit on rewriting
        coefficients in its normalised form.</p>
<h1 id="examples_14">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, exp
from sympy.abc import x</p>
<p>e = sin(1/x + exp(-x)) - sin(1/x)</p>
<p>e.aseries(x)
(1/(24<em>x</em><em>4) - 1/(2</em>x<strong>2) + 1 + O(x</strong>(-6), (x, oo)))*exp(-x)</p>
<p>e.aseries(x, n=3, hir=True)
-exp(-2<em>x)</em>sin(1/x)/2 + exp(-x)<em>cos(1/x) + O(exp(-3</em>x), (x, oo))</p>
<p>e = exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x)
exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x, bound=3) # doctest: +SKIP
exp(exp(x)/x<strong>2)<em>exp(exp(x)/x)</em>exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x</strong>2)*exp(exp(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).aseries(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns">Returns</h1>
<p>Expr
    Asymptotic series expansion of the expression.</p>
<h1 id="notes_2">Notes</h1>
<p>This algorithm is directly induced from the limit computational algorithm provided by Gruntz.
It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first
to look for the most rapidly varying subexpression w of a given expression f and then expands f
in a series in w. Then same thing is recursively done on the leading coefficient
till we get constant coefficients.</p>
<p>If the most rapidly varying subexpression of a given expression f is f itself,
the algorithm tries to find a normalised representation of the mrv set and rewrites f
using this normalised representation.</p>
<p>If the expansion contains an order term, it will be either <code>O(x ** (-n))</code> or <code>O(w ** (-n))</code>
where <code>w</code> belongs to the most rapidly varying expression of <code>self</code>.</p>
<h1 id="references">References</h1>
<p>.. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series.
       In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993.
       pp. 239-244.
.. [2] Gruntz thesis - p90
.. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion</p>
<h1 id="see-also_4">See Also</h1>
<p>Expr.aseries: See the docstring of this function for complete details of this wrapper.</p>
<h4 id="atoms">atoms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">atoms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">types</span><span class="p">:</span> <span class="s1">&#39;Tbasic | type[Tbasic]&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;set[Basic] | set[Tbasic]&#39;</span>
</code></pre></div>
<p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and cannot
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<h1 id="examples_15">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import I, pi, sin
from sympy.abc import x, y
(1 + x + 2<em>sin(y + I</em>pi)).atoms()
{1, 2, I, pi, x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Number, NumberSymbol, Symbol
(1 + x + 2<em>sin(y + I</em>pi)).atoms(Symbol)
{x, y}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number)
{1, 2}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol)
{1, 2, pi}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol, I)
{1, 2, I, pi}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(x) # x is a Symbol
{x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Be careful to check your assumptions when using the implicit option
since <code>S(1).is_Integer = True</code> but <code>type(S(1))</code> is <code>One</code>, a special type
of SymPy atom, while <code>type(S(2))</code> is type <code>Integer</code> and will find all
integers in an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(1))
{1}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(2))
{1, 2}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
SymPy type (loaded in core/<strong>init</strong>.py) can be listed as an argument
and those types of "atoms" as found in scanning the arguments of the
expression recursively:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function, Mul
from sympy.core.function import AppliedUndef
f = Function('f')
(1 + f(x) + 2<em>sin(y + I</em>pi)).atoms(Function)
{f(x), sin(y + I<em>pi)}
(1 + f(x) + 2</em>sin(y + I*pi)).atoms(AppliedUndef)
{f(x)}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Mul)
{I<em>pi, 2</em>sin(y + I*pi)}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="cancel">cancel</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cancel</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the cancel function in sympy.polys</p>
<h4 id="coeff">coeff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">coeff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">_first</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the coefficient from the term(s) containing <code>x**n</code>. If <code>n</code></p>
<p>is zero then all terms independent of <code>x</code> will be returned.</p>
<h1 id="explanation_2">Explanation</h1>
<p>When <code>x</code> is noncommutative, the coefficient to the left (default) or
right of <code>x</code> can be returned. The keyword 'right' is ignored when
<code>x</code> is commutative.</p>
<h1 id="examples_16">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
from sympy.abc import x, y, z</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have an explicit negative in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x + 2<em>y).coeff(-1)
x
(x - 2</em>y).coeff(-1)
2*y</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms with no Rational coefficient:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + 2<em>y).coeff(1)
x
(3 + 2</em>x + 4<em>x</em>*2).coeff(1)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms independent of x by making n=0; in this case
expr.as_independent(x)[0] is returned (and 0 will be returned instead
of None):</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x, 0)
3
eq = ((x + 1)</strong>3).expand() + 1
eq
x<strong>3 + 3*x</strong>2 + 3*x + 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 2]
eq -= 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 0]</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have a numerical term in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x - 2<em>y).coeff(2)
-y
from sympy import sqrt
(x + sqrt(2)</em>x).coeff(sqrt(2))
x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The matching is exact:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x)
2
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>2)
4
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>3)
0
(z*(x + y)</strong>2).coeff((x + y)<strong>2)
z
(z*(x + y)</strong>2).coeff(x + y)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
from the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + z<em>(x + x</em>y)).coeff(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<p>If such factoring is desired, factor_terms can be used first:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import factor_terms
factor_terms(x + z<em>(x + x</em>y)).coeff(x)
z*(y + 1) + 1</p>
<p>n, m, o = symbols('n m o', commutative=False)
n.coeff(n)
1
(3<em>n).coeff(n)
3
(n</em>m + m<em>n</em>m).coeff(n) # = (1 + m)<em>n</em>m
1 + m
(n<em>m + m</em>n<em>m).coeff(n, right=True) # = (1 + m)</em>n*m
m</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is more than one possible coefficient 0 is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + m</em>n).coeff(n)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is only one possible coefficient, it is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + x</em>m<em>n).coeff(m</em>n)
x
(n<em>m + x</em>m<em>n).coeff(m</em>n, right=1)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_5">See Also</h1>
<p>as_coefficient: separate the expression into a coefficient and factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="collect">collect</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">syms</span><span class="p">,</span>
    <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">distribute_order_term</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the collect function in sympy.simplify</p>
<h4 id="combsimp">combsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">combsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the combsimp function in sympy.simplify</p>
<h4 id="compare">compare</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compare</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span>
<span class="p">)</span>
</code></pre></div>
<p>Return -1, 0, 1 if the object is less than, equal,</p>
<p>or greater than other in a canonical sense.
Non-Basic are always greater than Basic.
If both names of the classes being compared appear
in the <code>ordering_of_classes</code> then the ordering will
depend on the appearance of the names there.
If either does not appear in that list, then the
comparison is based on the class name.
If the names are the same then a comparison is made
on the length of the hashable content.
Items of the equal-lengthed contents are then
successively compared using the same rules. If there
is never a difference then 0 is returned.</p>
<h1 id="examples_17">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
x.compare(y)
-1
x.compare(x)
0
y.compare(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="conjugate">conjugate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">conjugate</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the complex conjugate of 'self'.</p>
<h4 id="copy">copy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="could_extract_minus_sign">could_extract_minus_sign</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">could_extract_minus_sign</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;bool&#39;</span>
</code></pre></div>
<p>Return True if self has -1 as a leading factor or has</p>
<p>more literal negative signs than positive signs in a sum,
otherwise False.</p>
<h1 id="examples_18">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = x - y
{i.could_extract_minus_sign() for i in (e, -e)}
{False, True}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Though the <code>y - x</code> is considered like <code>-(x - y)</code>, since it
is in a product without a leading factor of -1, the result is
false below:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*(y - x)).could_extract_minus_sign()
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>To put something in canonical form wrt to sign, use <code>signsimp</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import signsimp
signsimp(x<em>(y - x))
-x</em>(x - y)
_.could_extract_minus_sign()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="count">count</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span>
<span class="p">)</span>
</code></pre></div>
<p>Count the number of matching subexpressions.</p>
<h4 id="count_ops">count_ops</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_ops</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">visual</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for count_ops that returns the operation count.</p>
<h4 id="diff">diff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">diff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="dir">dir</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dir</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">cdir</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="doit">doit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">doit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate objects that are not evaluated by default like limits,</p>
<p>integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via 'hints'
or unless the 'deep' hint was set to 'False'.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
from sympy.abc import x</p>
<p>2<em>Integral(x, x)
2</em>Integral(x, x)</p>
<p>(2<em>Integral(x, x)).doit()
x</em>*2</p>
<p>(2<em>Integral(x, x)).doit(deep=False)
2</em>Integral(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="dummy_eq">dummy_eq</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dummy_eq</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">symbol</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compare two expressions and handle dummy symbols.</p>
<h1 id="examples_19">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Dummy
from sympy.abc import x, y</p>
<p>u = Dummy('u')</p>
<p>(u<strong>2 + 1).dummy_eq(x</strong>2 + 1)
True
(u<strong>2 + 1) == (x</strong>2 + 1)
False</p>
<p>(u<strong>2 + y).dummy_eq(x</strong>2 + y, x)
True
(u<strong>2 + y).dummy_eq(x</strong>2 + y, y)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="equals">equals</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">failing_expression</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self == other, False if it does not, or None. If</p>
<p>failing_expression is True then the expression which did not simplify
to a 0 will be returned instead of None.</p>
<h1 id="explanation_3">Explanation</h1>
<p>If <code>self</code> is a Number (or complex number) that is not zero, then
the result is False.</p>
<p>If <code>self</code> is a number and has not evaluated to zero, evalf will be
used to test whether the expression evaluates to zero. If it does so
and the result has significance (i.e. the precision is either -1, for
a Rational result, or is greater than 1) then the evalf value will be
used to return True or False.</p>
<h4 id="evalf">evalf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">evalf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_1">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_3">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="expand">expand</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">modulus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">power_base</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">power_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">multinomial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Expand an expression using hints.</p>
<p>See the docstring of the expand() function in sympy.core.function for
more information.</p>
<h4 id="extract_additively">extract_additively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_additively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self - c if it's possible to subtract c from self and</p>
<p>make all matching coefficients move towards zero, else return None.</p>
<h1 id="examples_20">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = 2<em>x + 3
e.extract_additively(x + 1)
x + 2
e.extract_additively(3</em>x)
e.extract_additively(4)
(y<em>(x + 1)).extract_additively(x + 1)
((x + 1)</em>(x + 2<em>y + 1) + 3).extract_additively(x + 1)
(x + 1)</em>(x + 2*y) + 3</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_6">See Also</h1>
<p>extract_multiplicatively
coeff
as_coefficient</p>
<h4 id="extract_branch_factor">extract_branch_factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_branch_factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">allow_half</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Try to write self as <code>exp_polar(2*pi*I*n)*z</code> in a nice way.</p>
<p>Return (z, n).</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp_polar, I, pi
from sympy.abc import x, y
exp_polar(I<em>pi).extract_branch_factor()
(exp_polar(I</em>pi), 0)
exp_polar(2<em>I</em>pi).extract_branch_factor()
(1, 1)
exp_polar(-pi<em>I).extract_branch_factor()
(exp_polar(I</em>pi), -1)
exp_polar(3<em>pi</em>I + x).extract_branch_factor()
(exp_polar(x + I<em>pi), 1)
(y</em>exp_polar(-5<em>pi</em>I)<em>exp_polar(3</em>pi<em>I + 2</em>pi<em>x)).extract_branch_factor()
(y</em>exp_polar(2<em>pi</em>x), -1)
exp_polar(-I<em>pi/2).extract_branch_factor()
(exp_polar(-I</em>pi/2), 0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If allow_half is True, also extract exp_polar(I*pi):</p>
<blockquote>
<blockquote>
<blockquote>
<p>exp_polar(I<em>pi).extract_branch_factor(allow_half=True)
(1, 1/2)
exp_polar(2</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 1)
exp_polar(3</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 3/2)
exp_polar(-I</em>pi).extract_branch_factor(allow_half=True)
(1, -1/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="extract_multiplicatively">extract_multiplicatively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_multiplicatively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Return None if it's not possible to make self in the form</p>
<p>c * something in a nice way, i.e. preserving the properties
of arguments of self.</p>
<h1 id="examples_21">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Rational</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em><em>2 * y)
x</em>y**2</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em>*4 * y)</p>
<p>(2*x).extract_multiplicatively(2)
x</p>
<p>(2*x).extract_multiplicatively(3)</p>
<p>(Rational(1, 2)*x).extract_multiplicatively(3)
x/6</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="factor">factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the factor() function in sympy.polys.polytools</p>
<h4 id="find">find</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Find all subexpressions matching a query.</p>
<h4 id="find_field_1">find_field</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_field</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s1">&#39;FieldableProtocol&#39;</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;str | int&#39;</span><span class="p">,</span>
    <span class="n">fallback_type</span><span class="p">:</span> <span class="s1">&#39;type | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">init_kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Reference[Any]&#39;</span>
</code></pre></div>
<p>Field within the reference, if possible.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>field</td>
<td>None</td>
<td>the field to search for.</td>
<td>None</td>
</tr>
<tr>
<td>fallback_type</td>
<td>None</td>
<td>the type to use if we do not know a more specific one.</td>
<td>None</td>
</tr>
<tr>
<td>**init_kwargs</td>
<td>None</td>
<td>arguments to use for constructing a new reference (via <code>__make_reference__</code>).</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A field-specific version of this reference.</td>
</tr>
</tbody>
</table>
<h4 id="fourier_series">fourier_series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fourier_series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">limits</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute fourier sine/cosine series of self.</p>
<p>See the docstring of the :func:<code>fourier_series</code> in sympy.series.fourier
for more information.</p>
<h4 id="fps">fps</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fps</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">hyper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute formal power power series of self.</p>
<p>See the docstring of the :func:<code>fps</code> function in sympy.series.formal for
more information.</p>
<h4 id="gammasimp">gammasimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gammasimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the gammasimp function in sympy.simplify</p>
<h4 id="geto">getO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Returns the additive O(..) symbol if there is one, else None.</p>
<h4 id="getn">getn</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getn</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the order of the expression.</p>
<h1 id="explanation_4">Explanation</h1>
<p>The order is determined either from the O(...) term. If there
is no O(...) term, it returns None.</p>
<h1 id="examples_22">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import O
from sympy.abc import x
(1 + x + O(x**2)).getn()
2
(1 + x).getn()</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has">has</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether any subexpression matches any of the patterns.</p>
<h1 id="examples_23">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y, z
(x<strong>2 + sin(x*y)).has(z)
False
(x</strong>2 + sin(x*y)).has(x, y, z)
True
x.has(x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note <code>has</code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Interval
i = Interval.Lopen(0, 5); i
Interval.Lopen(0, 5)
i.args
(0, 5, True, False)
i.has(4)  # there is no "4" in the arguments
False
i.has(0)  # there <em>is</em> a "0" in the arguments
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Instead, use <code>contains</code> to determine whether a number is in the
interval or not:</p>
<blockquote>
<blockquote>
<blockquote>
<p>i.contains(4)
True
i.contains(0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that <code>expr.has(*patterns)</code> is exactly equivalent to
<code>any(expr.has(p) for p in patterns)</code>. In particular, <code>False</code> is
returned when the list of patterns is empty.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x.has()
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_free">has_free</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_free</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has object(s) <code>x</code> as a free expression</p>
<p>else False.</p>
<h1 id="examples_24">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Function
from sympy.abc import x, y
f = Function('f')
g = Function('g')
expr = Integral(f(x), (f(x), 1, g(y)))
expr.free_symbols
{y}
expr.has_free(g(y))
True
expr.has_free(*(x, f(x)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This works for subexpressions and types, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.has_free(g)
True
(x + y + 1).has_free(y + 1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_xfree">has_xfree</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_xfree</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;set[Basic]&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has any of the patterns in s as a</p>
<p>free argument, else False. This is like <code>Basic.has_free</code>
but this will only report exact argument matches.</p>
<h1 id="examples_25">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
from sympy.abc import x, y
f = Function('f')
f(x).has_xfree({f})
False
f(x).has_xfree({f(x)})
True
f(x + 1).has_xfree({x})
True
f(x + 1).has_xfree({x + 1})
True
f(x + y + 1).has_xfree({x + 1})
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="integrate">integrate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">integrate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the integrate function in sympy.integrals</p>
<h4 id="invert">invert</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">g</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the multiplicative inverse of <code>self</code> mod <code>g</code></p>
<p>where <code>self</code> (and <code>g</code>) may be symbolic expressions).</p>
<h1 id="see-also_7">See Also</h1>
<p>sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert</p>
<h4 id="is_algebraic_expr">is_algebraic_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_algebraic_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether a given expression is algebraic or not, in the</p>
<p>given symbols, syms. When syms is not given, all free symbols
will be used. The rational function does not have to be in expanded
or in any kind of canonical form.</p>
<p>This function returns False for expressions that are "algebraic
expressions" with symbolic exponents. This is a simple extension to the
is_rational_function, including rational exponentiation.</p>
<h1 id="examples_26">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sqrt
x = Symbol('x', real=True)
sqrt(1 + x).is_rational_function()
False
sqrt(1 + x).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be an algebraic
expression to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp, factor
a = sqrt(exp(x)*<em>2 + 2</em>exp(x) + 1)/(exp(x) + 1)
a.is_algebraic_expr(x)
False
factor(a).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_8">See Also</h1>
<p>is_rational_function</p>
<h1 id="references_1">References</h1>
<p>.. [1] https://en.wikipedia.org/wiki/Algebraic_expression</p>
<h4 id="is_constant">is_constant</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">wrt</span><span class="p">,</span>
    <span class="o">**</span><span class="n">flags</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is constant, False if not, or None if</p>
<p>the constancy could not be determined conclusively.</p>
<h1 id="explanation_5">Explanation</h1>
<p>If an expression has no free symbols then it is a constant. If
there are free symbols it is possible that the expression is a
constant, perhaps (but not necessarily) zero. To test such
expressions, a few strategies are tried:</p>
<p>1) numerical evaluation at two random points. If two such evaluations
give two different values and the values have a precision greater than
1 then self is not constant. If the evaluations agree or could not be
obtained with any precision, no decision is made. The numerical testing
is done only if <code>wrt</code> is different than the free symbols.</p>
<p>2) differentiation with respect to variables in 'wrt' (or all free
symbols if omitted) to see if the expression is constant or not. This
will not always lead to an expression that is zero even though an
expression is constant (see added test in test_expr.py). If
all derivatives are zero then self is constant with respect to the
given symbols.</p>
<p>3) finding out zeros of denominator expression with free_symbols.
It will not be constant if there are zeros. It gives more negative
answers for expression that are not constant.</p>
<p>If neither evaluation nor differentiation can prove the expression is
constant, None is returned unless two numerical values happened to be
the same and the flag <code>failing_number</code> is True -- in that case the
numerical value will be returned.</p>
<p>If flag simplify=False is passed, self will not be simplified;
the default is True since self should be simplified before testing.</p>
<h1 id="examples_27">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, Sum, S, pi
from sympy.abc import a, n, x, y
x.is_constant()
False
S(2).is_constant()
True
Sum(x, (x, 1, 10)).is_constant()
True
Sum(x, (x, 1, n)).is_constant()
False
Sum(x, (x, 1, n)).is_constant(y)
True
Sum(x, (x, 1, n)).is_constant(n)
False
Sum(x, (x, 1, n)).is_constant(x)
True
eq = a<em>cos(x)</em><em>2 + a</em>sin(x)**2 - a
eq.is_constant()
True
eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
True</p>
<p>(0<strong>x).is_constant()
False
x.is_constant()
False
(x</strong>x).is_constant()
False
one = cos(x)<strong>2 + sin(x)</strong>2
one.is_constant()
True
((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_hypergeometric">is_hypergeometric</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_hypergeometric</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">k</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="is_meromorphic">is_meromorphic</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_meromorphic</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">a</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether an expression is meromorphic as</p>
<p>a function of the given symbol <code>x</code> at the point <code>a</code>.</p>
<p>This method is intended as a quick test that will return
None if no decision can be made without simplification or
more detailed analysis.</p>
<h1 id="examples_28">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import zoo, log, sin, sqrt
from sympy.abc import x</p>
<p>f = 1/x<strong>2 + 1 - 2*x</strong>3
f.is_meromorphic(x, 0)
True
f.is_meromorphic(x, 1)
True
f.is_meromorphic(x, zoo)
True</p>
<p>g = x**log(3)
g.is_meromorphic(x, 0)
False
g.is_meromorphic(x, 1)
True
g.is_meromorphic(x, zoo)
False</p>
<p>h = sin(1/x)<em>x</em>*2
h.is_meromorphic(x, 0)
False
h.is_meromorphic(x, 1)
True
h.is_meromorphic(x, zoo)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multivalued functions are considered meromorphic when their
branches are meromorphic. Thus most functions are meromorphic
everywhere except at essential singularities and branch points.
In particular, they will be meromorphic also on branch cuts
except at their endpoints.</p>
<blockquote>
<blockquote>
<blockquote>
<p>log(x).is_meromorphic(x, -1)
True
log(x).is_meromorphic(x, 0)
False
sqrt(x).is_meromorphic(x, -1)
True
sqrt(x).is_meromorphic(x, 0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_polynomial">is_polynomial</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_polynomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is a polynomial in syms and False otherwise.</p>
<p>This checks if self is an exact polynomial in syms.  This function
returns False for expressions that are "polynomials" with symbolic
exponents.  Thus, you should be able to apply polynomial algorithms to
expressions for which this returns True, and Poly(expr, *syms) should
work if and only if expr.is_polynomial(*syms) returns True. The
polynomial does not have to be in expanded form.  If no symbols are
given, all free symbols in the expression will be used.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', polynomial=True).</p>
<h1 id="examples_29">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Function
x = Symbol('x')
((x<strong>2 + 1)</strong>4).is_polynomial(x)
True
((x<strong>2 + 1)</strong>4).is_polynomial()
True
(2<strong>x + 1).is_polynomial(x)
False
(2</strong>x + 1).is_polynomial(2**x)
True
f = Function('f')
(f(x) + 1).is_polynomial(x)
False
(f(x) + 1).is_polynomial(f(x))
True
(1/f(x) + 1).is_polynomial(f(x))
False</p>
<p>n = Symbol('n', nonnegative=True, integer=True)
(x**n + 1).is_polynomial(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a polynomial to
become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor, cancel
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)
a.is_polynomial(y)
False
factor(a)
y + 1
factor(a).is_polynomial(y)
True</p>
<p>b = (y*<em>2 + 2</em>y + 1)/(y + 1)
b.is_polynomial(y)
False
cancel(b)
y + 1
cancel(b).is_polynomial(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also .is_rational_function()</p>
<h4 id="is_rational_function">is_rational_function</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_rational_function</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether function is a ratio of two polynomials in the given</p>
<p>symbols, syms. When syms is not given, all free symbols will be used.
The rational function does not have to be in expanded or in any kind of
canonical form.</p>
<p>This function returns False for expressions that are "rational
functions" with symbolic exponents.  Thus, you should be able to call
.as_numer_denom() and apply polynomial algorithms to the result for
expressions for which this returns True.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', rational_function=True).</p>
<h1 id="examples_30">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sin
from sympy.abc import x, y</p>
<p>(x/y).is_rational_function()
True</p>
<p>(x**2).is_rational_function()
True</p>
<p>(x/sin(y)).is_rational_function(y)
False</p>
<p>n = Symbol('n', integer=True)
(x**n + 1).is_rational_function(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a rational function
to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)/y
a.is_rational_function(y)
False
factor(a)
(y + 1)/y
factor(a).is_rational_function(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also is_algebraic_expr().</p>
<h4 id="is_same">is_same</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_same</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span>
    <span class="n">b</span><span class="p">,</span>
    <span class="n">approx</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if a and b are structurally the same, else False.</p>
<p>If <code>approx</code> is supplied, it will be used to test whether two
numbers are the same or not. By default, only numbers of the
same type will compare equal, so S.Half != Float(0.5).</p>
<h1 id="examples_31">Examples</h1>
<p>In SymPy (unlike Python) two numbers do not compare the same if they are
not of the same type:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
2.0 == S(2)
False
0.5 == S.Half
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>By supplying a function with which to compare two numbers, such
differences can be ignored. e.g. <code>equal_valued</code> will return True
for decimal numbers having a denominator that is a power of 2,
regardless of precision.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Float
from sympy.core.numbers import equal_valued
(S.Half/4).is_same(Float(0.125, 1), equal_valued)
True
Float(1, 2).is_same(Float(1, 10), equal_valued)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>But decimals without a power of 2 denominator will compare
as not being the same.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Float(0.1, 9).is_same(Float(0.1, 10), equal_valued)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>But arbitrary differences can be ignored by supplying a function
to test the equivalence of two numbers:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import math
Float(0.1, 9).is_same(Float(0.1, 10), math.isclose)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Other objects might compare the same even though types are not the
same. This routine will only return True if two expressions are
identical in terms of class types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import eye, Basic
eye(1) == S(eye(1))  # mutable vs immutable
True
Basic.is_same(eye(1), S(eye(1)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="leadterm">leadterm</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">leadterm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading term a<em>x</em>*b as a tuple (a, b).</p>
<h1 id="examples_32">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1+x+x<strong>2).leadterm(x)
(1, 0)
(1/x</strong>2+x+x**2).leadterm(x)
(1, -2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="limit">limit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">limit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">xlim</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute limit x-&gt;xlim.</p>
<h4 id="lseries">lseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for series yielding an iterator of the terms of the series.</p>
<p>Note: an infinite series will yield an infinite iterator. The following,
for exaxmple, will never terminate. It will just keep printing terms
of the sin(x) series::</p>
<p>for term in sin(x).lseries(x):
      print term</p>
<p>The advantage of lseries() over nseries() is that many times you are
just interested in the next term in the series (i.e. the first term for
example), but you do not know how many you should ask for in nseries()
using the "n" parameter.</p>
<p>See also nseries().</p>
<h4 id="match">match</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code>None</code> when expression (self) does not match with pattern.
Otherwise return a dictionary such that::</p>
<p>pattern.xreplace(self.match(pattern)) == self</p>
<h1 id="examples_33">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Wild, Sum
from sympy.abc import x, y
p = Wild("p")
q = Wild("q")
r = Wild("r")
e = (x+y)<strong>(x+y)
e.match(p</strong>p)
{p_: x + y}
e.match(p<strong>q)
{p_: x + y, q_: x + y}
e = (2*x)</strong>2
e.match(p<em>q</em><em>r)
{p_: 4, q_: x, r_: 2}
(p</em>q<strong>r).xreplace(e.match(p*q</strong>r))
4<em>x</em>*2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since match is purely structural expressions that are equivalent up to
bound symbols will not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p))))
None</p>
</blockquote>
</blockquote>
</blockquote>
<p>An expression with bound symbols can be matched if the pattern uses
a distinct <code>Wild</code> for each bound symbol:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))
{p_: 2, q_: x}</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>old</code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the match. Both
of the following give None unless <code>old=True</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x - 2).match(p - x, old=True)
{p_: 2<em>x - 2}
(2/x).match(p</em>x, old=True)
{p_: 2/x**2}</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_9">See Also</h1>
<p>matches: pattern.matches(expr) is the same as expr.match(pattern)
xreplace: exact structural replacement
replace: structural replacement with pattern matching
Wild: symbolic placeholders for expressions in pattern matching</p>
<h4 id="matches">matches</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">matches</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">,</span>
    <span class="n">repl_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Helper method for match() that looks for a match between Wild symbols</p>
<p>in self and expressions in expr.</p>
<h1 id="examples_34">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Wild, Basic
a, b, c = symbols('a b c')
x = Wild('x')
Basic(a + x, x).matches(Basic(a + b, c)) is None
True
Basic(a + x, x).matches(Basic(a + b + c, b + c))
{x_: b + c}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="n">n</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_2">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_4">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="normal">normal</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">normal</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression as a fraction.</p>
<p>expression -&gt; a/b</p>
<h1 id="see-also_10">See Also</h1>
<p>as_numer_denom: return <code>(a, b)</code> instead of <code>a/b</code></p>
<h4 id="nseries">nseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>
<p>If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
called. This calculates "n" terms in the innermost expressions and
then builds up the final series just by "cross-multiplying" everything
out.</p>
<p>The optional <code>logx</code> parameter can be used to replace any log(x) in the
returned series with a symbolic value to avoid evaluating log(x) at 0. A
symbol to use in place of log(x) should be provided.</p>
<p>Advantage -- it's fast, because we do not have to determine how many
terms we need to calculate in advance.</p>
<p>Disadvantage -- you may end up with less terms than you may have
expected, but the O(x**n) term appended will always be correct and
so the result, though perhaps shorter, will also be correct.</p>
<p>If any of those assumptions is not met, this is treated like a
wrapper to series which will try harder to return the correct
number of terms.</p>
<p>See also lseries().</p>
<h1 id="examples_35">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, log, Symbol
from sympy.abc import x, y
sin(x).nseries(x, 0, 6)
x - x<strong>3/6 + x</strong>5/120 + O(x<strong>6)
log(x+1).nseries(x, 0, 5)
x - x</strong>2/2 + x<strong>3/3 - x</strong>4/4 + O(x**5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Handling of the <code>logx</code> parameter --- in the following example the
expansion fails since <code>sin</code> does not have an asymptotic expansion
at -oo (the limit of log(x) as x approaches 0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = sin(log(x))
e.nseries(x, 0, 6)
Traceback (most recent call last):
...
PoleError: ...
...
logx = Symbol('logx')
e.nseries(x, 0, 6, logx=logx)
sin(logx)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the following example, the expansion works but only returns self
unless the <code>logx</code> parameter is used:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>y
e.nseries(x, 0, 2)
x</strong>y
e.nseries(x, 0, 2, logx=logx)
exp(logx*y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="nsimplify">nsimplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nsimplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">constants</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the nsimplify function in sympy.simplify</p>
<h4 id="powsimp">powsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">powsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the powsimp function in sympy.simplify</p>
<h4 id="primitive">primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">primitive</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Number, Expr]&#39;</span>
</code></pre></div>
<p>Return the positive Rational that can be extracted non-recursively</p>
<p>from every term of self (i.e., self is treated like an Add). This is
like the as_coeff_Mul() method but primitive always extracts a positive
Rational (never a negative or a Float).</p>
<h1 id="examples_36">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(3<em>(x + 1)</em><em>2).primitive()
(3, (x + 1)</em><em>2)
a = (6</em>x + 2); a.primitive()
(2, 3<em>x + 1)
b = (x/2 + 3); b.primitive()
(1/2, x + 6)
(a</em>b).primitive() == (1, a*b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="radsimp">radsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">radsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the radsimp function in sympy.simplify</p>
<h4 id="ratsimp">ratsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">ratsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the ratsimp function in sympy.simplify</p>
<h4 id="rcall">rcall</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rcall</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance, in SymPy the following will not work:</p>
<p><code>(x+Lambda(y, 2*y))(z) == x+2*z</code>,</p>
<p>however, you can use:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x, y, z
(x + Lambda(y, 2<em>y)).rcall(z)
x + 2</em>z</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="refine">refine</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">refine</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">assumption</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the refine function in sympy.assumptions</p>
<h4 id="removeo">removeO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">removeO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr&#39;</span>
</code></pre></div>
<p>Removes the additive O(..) symbol if there is one</p>
<h4 id="replace">replace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="nb">map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Replace matching subexpressions of <code>self</code> with <code>value</code>.</p>
<p>If <code>map = True</code> then also return the mapping {old: new} where <code>old</code>
was a sub-expression found with query and <code>new</code> is the replacement
value for it. If the expression itself does not match the query, then
the returned value will be <code>self.xreplace(map)</code> otherwise it should
be <code>self.subs(ordered(map.items()))</code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code>simultaneous</code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code>exact</code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<h1 id="examples_37">Examples</h1>
<p>Initial setup</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import log, sin, cos, tan, Wild, Mul, Add
from sympy.abc import x, y
f = log(sin(x)) + tan(sin(x**2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>1.1. type -&gt; type
    obj.replace(type, newtype)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, replace it with the
result of passing its argument(s) to ``newtype``.

&gt;&gt;&gt; f.replace(sin, cos)
log(cos(x)) + tan(cos(x**2))
&gt;&gt;&gt; sin(x).replace(sin, cos, map=True)
(cos(x), {sin(x): cos(x)})
&gt;&gt;&gt; (x*y).replace(Mul, Add)
x + y
</code></pre></div>
<p>1.2. type -&gt; func
    obj.replace(type, func)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, apply ``func`` to its
argument(s). ``func`` must be written to handle the number
of arguments of ``type``.

&gt;&gt;&gt; f.replace(sin, lambda arg: sin(2*arg))
log(sin(2*x)) + tan(sin(2*x**2))
&gt;&gt;&gt; (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))
sin(2*x*y)
</code></pre></div>
<p>2.1. pattern -&gt; expr
    obj.replace(pattern(wild), expr(wild))</p>
<div class="highlight"><pre><span></span><code>Replace subexpressions matching ``pattern`` with the expression
written in terms of the Wild symbols in ``pattern``.

&gt;&gt;&gt; a, b = map(Wild, &#39;ab&#39;)
&gt;&gt;&gt; f.replace(sin(a), tan(a))
log(tan(x)) + tan(tan(x**2))
&gt;&gt;&gt; f.replace(sin(a), tan(a/2))
log(tan(x/2)) + tan(tan(x**2/2))
&gt;&gt;&gt; f.replace(sin(a), a)
log(x) + tan(x**2)
&gt;&gt;&gt; (x*y).replace(a*x, a)
y

Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:

&gt;&gt;&gt; (2*x + y).replace(a*x + b, b - a)
y - 2
&gt;&gt;&gt; (2*x).replace(a*x + b, b - a)
2*x

When set to False, the results may be non-intuitive:

&gt;&gt;&gt; (2*x).replace(a*x + b, b - a, exact=False)
2/x
</code></pre></div>
<p>2.2. pattern -&gt; func
    obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<div class="highlight"><pre><span></span><code>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:

&gt;&gt;&gt; f.replace(sin(a), lambda a: sin(2*a))
log(sin(2*x)) + tan(sin(2*x**2))
</code></pre></div>
<p>3.1. func -&gt; func
    obj.replace(filter, func)</p>
<div class="highlight"><pre><span></span><code>Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``
is True.

&gt;&gt;&gt; g = 2*sin(x**3)
&gt;&gt;&gt; g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)
4*sin(x**9)
</code></pre></div>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; e = x*(x*y + 1)
&gt;&gt;&gt; e.replace(lambda x: x.is_Mul, lambda x: 2*x)
2*x*(2*x*y + 1)
</code></pre></div>
<p>When matching a single symbol, <code>exact</code> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <code>exact=False</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
f = Function('f')
e = f(1) + f(0)
q = f(a), lambda a: f(a + 1)
e.replace(<em>q, exact=False)
f(1) + f(2)
e.replace(</em>q, exact=True)
f(0) + f(2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>(1 + y)
(x</strong>(1 + y)).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=False)
x
(x<strong>(1 + y)).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=True)
x</strong>(-x - y + 1)
(x<strong>y).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=False)
x
(x</strong>y).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=True)
x**(1 - y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x<strong>(1 + y)).replace(
... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,
... lambda x: x.base</strong>(1 - (x.exp - 1)))
...
x**(1 - y) + 1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_11">See Also</h1>
<p>subs: substitution of subexpressions as defined by the objects
      themselves.
xreplace: exact node replacement in expr tree; also capable of
          using matching rules</p>
<h4 id="rewrite">rewrite</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rewrite</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrite <em>self</em> using a defined rule.</p>
<p>Rewriting transforms an expression to another, which is mathematically
equivalent but structurally different. For example you can rewrite
trigonometric functions as complex exponentials or combinatorial
functions as gamma function.</p>
<p>This method takes a <em>pattern</em> and a <em>rule</em> as positional arguments.
<em>pattern</em> is optional parameter which defines the types of expressions
that will be transformed. If it is not passed, all possible expressions
will be rewritten. <em>rule</em> defines how the expression will be rewritten.</p>
<h1 id="parameters_3">Parameters</h1>
<p>args : Expr
    A <em>rule</em>, or <em>pattern</em> and <em>rule</em>.
    - <em>pattern</em> is a type or an iterable of types.
    - <em>rule</em> can be any object.</p>
<p>deep : bool, optional
    If <code>True</code>, subexpressions are recursively transformed. Default is
    <code>True</code>.</p>
<h1 id="examples_38">Examples</h1>
<p>If <em>pattern</em> is unspecified, all possible expressions are transformed.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, exp, I
from sympy.abc import x
expr = cos(x) + I<em>sin(x)
expr.rewrite(exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Pattern can be a type or an iterable of types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.rewrite(sin, exp)
exp(I<em>x)/2 + cos(x) - exp(-I</em>x)/2
expr.rewrite([cos,], exp)
exp(I<em>x)/2 + I</em>sin(x) + exp(-I<em>x)/2
expr.rewrite([cos, sin], exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Rewriting behavior can be implemented by defining <code>_eval_rewrite()</code>
method.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Expr, sqrt, pi
class MySin(Expr):
...     def _eval_rewrite(self, rule, args, <strong>hints):
...         x, = args
...         if rule == cos:
...             return cos(pi/2 - x, evaluate=False)
...         if rule == sqrt:
...             return sqrt(1 - cos(x)</strong>2)
MySin(MySin(x)).rewrite(cos)
cos(-cos(-x + pi/2) + pi/2)
MySin(x).rewrite(sqrt)
sqrt(1 - cos(x)**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Defining <code>_eval_rewrite_as_[...]()</code> method is supported for backwards
compatibility reason. This may be removed in the future and using it is
discouraged.</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MySin(Expr):
...     def _eval_rewrite_as_cos(self, <em>args, </em>*hints):
...         x, = args
...         return cos(pi/2 - x, evaluate=False)
MySin(x).rewrite(cos)
cos(-x + pi/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="round">round</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return x rounded to the given decimal place.</p>
<p>If a complex number would results, apply round to the real
and imaginary components of the number.</p>
<h1 id="examples_39">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, E, I, S, Number
pi.round()
3
pi.round(2)
3.14
(2<em>pi + E</em>I).round()
6 + 3*I</p>
</blockquote>
</blockquote>
</blockquote>
<p>The round method has a chopping effect:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>pi + I/10).round()
6
(pi/10 + 2</em>I).round()
2<em>I
(pi/10 + E</em>I).round(2)
0.31 + 2.72*I</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_5">Notes</h1>
<p>The Python <code>round</code> function uses the SymPy <code>round</code> method so it
will always return a SymPy number (not a Python float or int):</p>
<blockquote>
<blockquote>
<blockquote>
<p>isinstance(round(S(123), -2), Number)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="separate">separate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">separate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">force</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the separate function in sympy.simplify</p>
<h4 id="series">series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Series expansion of "self" around <code>x = x0</code> yielding either terms of</p>
<p>the series one by one (the lazy series given when n=None), else
all the terms at once when n != None.</p>
<p>Returns the series expansion of "self" around the point <code>x = x0</code>
with respect to <code>x</code> up to <code>O((x - x0)**n, x, x0)</code> (default n is 6).</p>
<p>If <code>x=None</code> and <code>self</code> is univariate, the univariate symbol will
be supplied, otherwise an error will be raised.</p>
<h1 id="parameters_4">Parameters</h1>
<p>expr : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>x0 : Value
     The value around which <code>x</code> is calculated. Can be any value
     from <code>-oo</code> to <code>oo</code>.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>dir : String, optional
      The series-expansion can be bi-directional. If <code>dir="+"</code>,
      then (x-&gt;x0+). If <code>dir="-", then (x-&gt;x0-). For infinite</code>x0<code>(</code>oo<code>or</code>-oo<code>), the</code>dir<code>argument is determined
      from the direction of the infinity (i.e.,</code>dir="-"<code>for</code>oo``).</p>
<p>logx : optional
       It is used to replace any log(x) in the returned series with a
       symbolic value rather than evaluating the actual value.</p>
<p>cdir : optional
       It stands for complex direction, and indicates the direction
       from which the expansion needs to be evaluated.</p>
<h1 id="examples_40">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, exp, tan
from sympy.abc import x, y
cos(x).series()
1 - x<strong>2/2 + x</strong>4/24 + O(x<strong>6)
cos(x).series(n=4)
1 - x</strong>2/2 + O(x<strong>4)
cos(x).series(x, x0=1, n=2)
cos(1) - (x - 1)*sin(1) + O((x - 1)</strong>2, (x, 1))
e = cos(x + exp(y))
e.series(y, n=2)
cos(x + 1) - y<em>sin(x + 1) + O(y</em><em>2)
e.series(x, n=2)
cos(exp(y)) - x</em>sin(exp(y)) + O(x**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>n=None</code> then a generator of the series terms will be returned.</p>
<blockquote>
<blockquote>
<blockquote>
<p>term=cos(x).series(n=None)
[next(term) for i in range(2)]
[1, -x**2/2]</p>
</blockquote>
</blockquote>
</blockquote>
<p>For <code>dir=+</code> (default) the series is calculated from the right and
for <code>dir=-</code> the series from the left. For smooth functions this
flag will not alter the results.</p>
<blockquote>
<blockquote>
<blockquote>
<p>abs(x).series(dir="+")
x
abs(x).series(dir="-")
-x
f = tan(x)
f.series(x, 2, 6, "+")
tan(2) + (1 + tan(2)<strong>2)*(x - 2) + (x - 2)</strong>2<em>(tan(2)</em><em>3 + tan(2)) +
(x - 2)</em><em>3</em>(1/3 + 4<em>tan(2)</em><em>2/3 + tan(2)</em><em>4) + (x - 2)</em><em>4</em>(tan(2)<strong>5 +
5*tan(2)</strong>3/3 + 2<em>tan(2)/3) + (x - 2)</em><em>5</em>(2/15 + 17<em>tan(2)</em><em>2/15 +
2</em>tan(2)<strong>4 + tan(2)</strong>6) + O((x - 2)**6, (x, 2))</p>
<p>f.series(x, 2, 3, "-")
tan(2) + (2 - x)<em>(-tan(2)</em><em>2 - 1) + (2 - x)</em><em>2</em>(tan(2)<strong>3 + tan(2))
+ O((x - 2)</strong>3, (x, 2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).series(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_1">Returns</h1>
<p>Expr : Expression
    Series expansion of the expression about x0</p>
<h1 id="raises">Raises</h1>
<p>TypeError
    If "n" and "x0" are infinity objects</p>
<p>PoleError
    If "x0" is an infinity object</p>
<h4 id="simplify">simplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>See the simplify function in sympy.simplify</p>
<h4 id="sort_key">sort_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sort_key</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a sort key.</p>
<h1 id="examples_41">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S, I</p>
<p>sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())
[1/2, -I, I]</p>
<p>S("[x, 1/x, 1/x<strong>2, x</strong>2, x<strong>(1/2), x</strong>(1/4), x<strong>(3/2)]")
[x, 1/x, x</strong>(-2), x<strong>2, sqrt(x), x</strong>(1/4), x<strong>(3/2)]
sorted(_, key=lambda x: x.sort_key())
[x</strong>(-2), 1/x, x<strong>(1/4), sqrt(x), x, x</strong>(3/2), x**2]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="subs">subs</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">subs</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">arg1</span><span class="p">:</span> <span class="s1">&#39;Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex&#39;</span><span class="p">,</span>
    <span class="n">arg2</span><span class="p">:</span> <span class="s1">&#39;Basic | complex | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Substitutes old for new in an expression after sympifying args.</p>
<p><code>args</code> is either:
  - two arguments, e.g. foo.subs(old, new)
  - one iterable argument, e.g. foo.subs(iterable). The iterable may be
     o an iterable container with (old, new) pairs. In this case the
       replacements are processed in the order given with successive
       patterns possibly affecting replacements already made.
     o a dict or set whose key/value items correspond to old/new pairs.
       In this case the old/new pairs will be sorted by op count and in
       case of a tie, by number of args and the default_sort_key. The
       resulting sorted list is then processed as an iterable container
       (see previous).</p>
<p>If the keyword <code>simultaneous</code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<h1 id="examples_42">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, exp, limit, oo
from sympy.abc import x, y
(1 + x<em>y).subs(x, pi)
pi</em>y + 1
(1 + x<em>y).subs({x:pi, y:2})
1 + 2</em>pi
(1 + x<em>y).subs([(x, pi), (y, 2)])
1 + 2</em>pi
reps = [(y, x<strong>2), (x, 2)]
(x + y).subs(reps)
6
(x + y).subs(reversed(reps))
x</strong>2 + 2</p>
<p>(x<strong>2 + x</strong>4).subs(x<strong>2, y)
y</strong>2 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To replace only the x<strong>2 but not the x</strong>4, use xreplace:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<strong>2 + x</strong>4).xreplace({x<strong>2: y})
x</strong>4 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code>simultaneous</code> to True:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/y).subs([(x, 0), (y, 0)])
0
(x/y).subs([(x, 0), (y, 0)], simultaneous=True)
nan</p>
</blockquote>
</blockquote>
</blockquote>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((x + y)/y).subs({x + y: y, y: x + y})
1
((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
y/(x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, sin, cos
from sympy.abc import a, b, c, d, e</p>
<p>A = (sqrt(sin(2<em>x)), a)
B = (sin(2</em>x), b)
C = (cos(2*x), c)
D = (x, d)
E = (exp(x), e)</p>
<p>expr = sqrt(sin(2<em>x))</em>sin(exp(x)<em>x)</em>cos(2<em>x) + sin(2</em>x)</p>
<p>expr.subs(dict([A, B, C, D, E]))
a<em>c</em>sin(d*e) + b</p>
</blockquote>
</blockquote>
</blockquote>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*<em>3 - 3</em>x).subs({x: oo})
nan</p>
<p>limit(x*<em>3 - 3</em>x, x, oo)
oo</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).evalf(subs={x: 3.0}, n=21)
0.333333333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<p>rather than</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).subs({x: 3.0}).evalf(21)
0.333333333333333314830</p>
</blockquote>
</blockquote>
</blockquote>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
<h1 id="see-also_12">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
xreplace: exact node replacement in expr tree; also capable of
          using matching rules
sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision</p>
<h4 id="taylor_term">taylor_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">taylor_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="o">*</span><span class="n">previous_terms</span>
<span class="p">)</span>
</code></pre></div>
<p>General method for the taylor term.</p>
<p>This method is slow, because it differentiates n-times. Subclasses can
redefine it to make it faster by using the "previous_terms".</p>
<h4 id="to_nnf">to_nnf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_nnf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="together">together</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">together</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the together function in sympy.polys</p>
<h4 id="transpose">transpose</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="trigsimp">trigsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">trigsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the trigsimp function in sympy.simplify</p>
<h4 id="xreplace">xreplace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">xreplace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rule</span><span class="p">,</span>
    <span class="n">hack2</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Replace occurrences of objects within the expression.</p>
<h1 id="parameters_5">Parameters</h1>
<p>rule : dict-like
    Expresses a replacement rule</p>
<h1 id="returns_2">Returns</h1>
<p>xreplace : the result of the replacement</p>
<h1 id="examples_43">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, pi, exp
x, y, z = symbols('x y z')
(1 + x<em>y).xreplace({x: pi})
pi</em>y + 1
(1 + x<em>y).xreplace({x: pi, y: 2})
1 + 2</em>pi</p>
</blockquote>
</blockquote>
</blockquote>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>y + z).xreplace({x</em>y: pi})
z + pi
(x<em>y</em>z).xreplace({x<em>y: pi})
x</em>y<em>z
(2</em>x).xreplace({2<em>x: y, x: z})
y
(2</em>2<em>x).xreplace({2</em>x: y, x: z})
4*z
(x + y + 2).xreplace({x + y: 2})
x + y + 2
(x + 2 + exp(x + 2)).xreplace({x + 2: y})
x + exp(y) + 2</p>
</blockquote>
</blockquote>
</blockquote>
<p>xreplace does not differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
Integral(x, (x, 1, 2<em>x)).xreplace({x: y})
Integral(y, (y, 1, 2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Trying to replace x with an expression raises an error:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Integral(x, (x, 1, 2<em>x)).xreplace({x: 2</em>y}) # doctest: +SKIP
ValueError: Invalid limits given: ((2<em>y, 1, 4</em>y),)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_13">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
subs: substitution of subexpressions as defined by the objects
      themselves.</p>
<h3 id="iterablestepreference">IterableStepReference</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">IterableStepReference</span><span class="p">(</span>
    <span class="n">typ</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="o">~</span><span class="n">U</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
<span class="p">)</span>
</code></pre></div>
<p>Iterable form of a step reference.</p>
<h4 id="ancestors-in-mro_4">Ancestors (in MRO)</h4>
<ul>
<li>dewret.core.IterableMixin</li>
<li>dewret.workflow.StepReference</li>
<li>dewret.workflow.FieldableMixin</li>
<li>dewret.core.Reference</li>
<li>typing.Generic</li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.printing.defaults.Printable</li>
<li>sympy.core.evalf.EvalfMixin</li>
<li>dewret.core.WorkflowComponent</li>
</ul>
<h4 id="class-variables_3">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">StepReferenceMetadata</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">default_assumptions</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Add</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_AlgebraicNumber</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Atom</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Boolean</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Derivative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Dummy</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Equality</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Float</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Function</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Indexed</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatAdd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatMul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Matrix</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Mul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Not</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_NumberSymbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Order</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Piecewise</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Point</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Poly</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Pow</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Relational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Symbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Vector</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Wild</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_comparable</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_scalar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_symbol</span>
</code></pre></div>
<h4 id="static-methods_1">Static methods</h4>
<h4 id="class_key_1">class_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">class_key</span><span class="p">(</span>
    
<span class="p">)</span>
</code></pre></div>
<p>Nice order of classes.</p>
<h4 id="fromiter_1">fromiter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fromiter</span><span class="p">(</span>
    <span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<h1 id="examples_44">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Tuple
Tuple.fromiter(i for i in range(5))
(0, 1, 2, 3, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="instance-variables_4">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">args</span>
</code></pre></div>
<p>Returns a tuple of arguments of 'self'.</p>
<h1 id="examples_45">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cot
from sympy.abc import x, y</p>
<p>cot(x).args
(x,)</p>
<p>cot(x).args[0]
x</p>
<p>(x*y).args
(x, y)</p>
<p>(x*y).args[1]
y</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_6">Notes</h1>
<p>Never use self._args, always use self.args.
Only use _args in <strong>new</strong> when creating a new function.
Do not override .args() from Basic (so that it is easy to
change the interface in the future if needed).</p>
<div class="highlight"><pre><span></span><code><span class="n">assumptions0</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">binary_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">canonical_variables</span>
</code></pre></div>
<p>Return a dictionary mapping any variable defined in</p>
<p><code>self.bound_symbols</code> to Symbols that do not clash
with any free symbols in the expression.</p>
<h1 id="examples_46">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x
Lambda(x, 2*x).canonical_variables
{x: _0}</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">expr_free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">func</span>
</code></pre></div>
<p>The top-level function in an expression.</p>
<p>The following should hold for all objects::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt; x == x.func(*x.args)
</code></pre></div>
<h1 id="examples_47">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
a = 2<em>x
a.func
<class 'sympy.core.mul.Mul'>
a.args
(2, x)
a.func(</em>a.args)
2<em>x
a == a.func(</em>a.args)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">is_algebraic</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_antihermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_commutative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_complex</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_composite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_even</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_finite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_hermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_imaginary</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_infinite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_irrational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_noninteger</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_odd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_polar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_prime</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_transcendental</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_zero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">kind</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Printable name of the reference.</p>
<h4 id="methods_4">Methods</h4>
<h4 id="adjoint_1">adjoint</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">adjoint</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="apart_1">apart</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apart</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the apart function in sympy.polys</p>
<h4 id="args_cnc_1">args_cnc</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">args_cnc</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">split_1</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Return [commutative factors, non-commutative factors] of self.</p>
<h1 id="explanation_6">Explanation</h1>
<p>self is treated as a Mul and the ordering of the factors is maintained.
If <code>cset</code> is True the commutative factors will be returned in a set.
If there were repeated factors (as may happen with an unevaluated Mul)
then an error will be raised unless it is explicitly suppressed by
setting <code>warn</code> to False.</p>
<p>Note: -1 is always separated from a Number unless split_1 is False.</p>
<h1 id="examples_48">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, oo
A, B = symbols('A B', commutative=0)
x, y = symbols('x y')
(-2<em>x</em>y).args_cnc()
[[-1, 2, x, y], []]
(-2.5<em>x).args_cnc()
[[-1, 2.5, x], []]
(-2</em>x<em>A</em>B<em>y).args_cnc()
[[-1, 2, x, y], [A, B]]
(-2</em>x<em>A</em>B<em>y).args_cnc(split_1=False)
[[-2, x, y], [A, B]]
(-2</em>x*y).args_cnc(cset=True)
[{-1, 2, x, y}, []]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The arg is always treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-2 + x + A).args_cnc()
[[], [x - 2 + A]]
(-oo).args_cnc() # -oo is a singleton
[[-1, oo], []]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_base_exp_1">as_base_exp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_base_exp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<h4 id="as_coeff_add_2">as_coeff_Add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a summation.</p>
<h4 id="as_coeff_mul_2">as_coeff_Mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a product.</p>
<h4 id="as_coeff_add_3">as_coeff_add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as an Add, <code>a</code>.</p>
<p>c should be a Rational added to any terms of the Add that are
independent of deps.</p>
<p>args should be a tuple of all other terms of <code>a</code>; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is an Add or not but
you want to treat self as an Add or if you want to process the
individual arguments of the tail of self as an Add.</p>
<ul>
<li>if you know self is an Add and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail.</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_add()
(3, ())
(3 + x).as_coeff_add()
(3, (x,))
(3 + x + y).as_coeff_add(x)
(y + 3, (x,))
(3 + y).as_coeff_add(x)
(y + 3, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coeff_exponent_1">as_coeff_exponent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_exponent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p><code>c*x**e -&gt; c,e</code> where x can be any symbolic expression.</p>
<h4 id="as_coeff_mul_3">as_coeff_mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as a Mul, <code>m</code>.</p>
<p>c should be a Rational multiplied by any factors of the Mul that are
independent of deps.</p>
<p>args should be a tuple of all other factors of m; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is a Mul or not but
you want to treat self as a Mul or if you want to process the
individual arguments of the tail of self as a Mul.</p>
<ul>
<li>if you know self is a Mul and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail;</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_mul()
(3, ())
(3<em>x</em>y).as_coeff_mul()
(3, (x, y))
(3<em>x</em>y).as_coeff_mul(x)
(3<em>y, (x,))
(3</em>y).as_coeff_mul(x)
(3*y, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coefficient_1">as_coefficient</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Extracts symbolic coefficient at the given expression. In</p>
<p>other words, this functions separates 'self' into the product
of 'expr' and 'expr'-free coefficient. If such separation
is not possible it will return None.</p>
<h1 id="examples_49">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import E, pi, sin, I, Poly
from sympy.abc import x</p>
<p>E.as_coefficient(E)
1
(2<em>E).as_coefficient(E)
2
(2</em>sin(E)*E).as_coefficient(E)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two terms have E in them so a sum is returned. (If one were
desiring the coefficient of the term exactly matching E then
the constant from the returned expression could be selected.
Or, for greater precision, a method of Poly can be used to
indicate the desired term from which the coefficient is
desired.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E + x</em>E).as_coefficient(E)
x + 2
_.args[0]  # just want the exact match
2
p = Poly(2<em>E + x</em>E); p
Poly(x<em>E + 2</em>E, x, E, domain='ZZ')
p.coeff_monomial(E)
2
p.nth(0, 1)
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since the following cannot be written as a product containing
E as a factor, None is returned. (If the coefficient <code>2*x</code> is
desired then the <code>coeff</code> method should be used.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E</em>x + x).as_coefficient(E)
(2<em>E</em>x + x).coeff(E)
2*x</p>
<p>(E*(x + 1) + x).as_coefficient(E)</p>
<p>(2<em>pi</em>I).as_coefficient(pi<em>I)
2
(2</em>I).as_coefficient(pi*I)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_14">See Also</h1>
<p>coeff: return sum of terms have a given factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="as_coefficients_dict_1">as_coefficients_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficients_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a dictionary mapping terms to their Rational coefficient.</p>
<p>Since the dictionary is a defaultdict, inquiries about terms which
were not present will return a coefficient of 0.</p>
<p>If symbols <code>syms</code> are provided, any multiplicative terms
independent of them will be considered a coefficient and a
regular dictionary of syms-dependent generators as keys and
their corresponding coefficients as values will be returned.</p>
<h1 id="examples_50">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import a, x, y
(3<em>x + a</em>x + 4).as_coefficients_dict()
{1: 4, x: 3, a<em>x: 1}
_[a]
0
(3</em>a<em>x).as_coefficients_dict()
{a</em>x: 3}
(3<em>a</em>x).as_coefficients_dict(x)
{x: 3<em>a}
(3</em>a<em>x).as_coefficients_dict(y)
{1: 3</em>a*x}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_content_primitive_1">as_content_primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_content_primitive</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">radical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">clear</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>This method should recursively remove a Rational from all arguments</p>
<p>and return that (content) and the new self (primitive). The content
should always be positive and <code>Mul(*foo.as_content_primitive()) == foo</code>.
The primitive need not be in canonical form and should try to preserve
the underlying structure if possible (i.e. expand_mul should not be
applied to self).</p>
<h1 id="examples_51">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt
from sympy.abc import x, y, z</p>
<p>eq = 2 + 2<em>x + 2</em>y<em>(3 + 3</em>y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The as_content_primitive function is recursive and retains structure:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eq.as_content_primitive()
(2, x + 3<em>y</em>(y + 1) + 1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Integer powers will have Rationals extracted from the base:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((2 + 6<em>x)</em><em>2).as_content_primitive()
(4, (3</em>x + 1)<strong>2)
((2 + 6*x)</strong>(2<em>y)).as_content_primitive()
(1, (2</em>(3<em>x + 1))</em><em>(2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Terms may end up joining once their as_content_primitives are added:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((5<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(11, x</em>(y + 1))
((3<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(9, x</em>(y + 1))
((3<em>(z</em>(1 + y)) + 2.0<em>x</em>(3 + 3<em>y))).as_content_primitive()
(1, 6.0</em>x<em>(y + 1) + 3</em>z<em>(y + 1))
((5</em>(x<em>(1 + y)) + 2</em>x<em>(3 + 3</em>y))<strong>2).as_content_primitive()
(121, x</strong>2<em>(y + 1)</em><em>2)
((x</em>(1 + y) + 0.4<em>x</em>(3 + 3<em>y))</em><em>2).as_content_primitive()
(1, 4.84</em>x<strong>2*(y + 1)</strong>2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Radical content can also be factored out of the primitive:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>sqrt(2) + 4</em>sqrt(10)).as_content_primitive(radical=True)
(2, sqrt(2)<em>(1 + 2</em>sqrt(5)))</p>
</blockquote>
</blockquote>
</blockquote>
<p>If clear=False (default is True) then content will not be removed
from an Add if it can be distributed to leave one or more
terms with integer coefficients.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/2 + y).as_content_primitive()
(1/2, x + 2*y)
(x/2 + y).as_content_primitive(clear=False)
(1, x/2 + y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_dummy_1">as_dummy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_dummy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression with any objects having structurally</p>
<p>bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<h1 id="examples_52">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Symbol
from sympy.abc import x
r = Symbol('r', real=True)
Integral(r, (r, x)).as_dummy()
Integral(<em>0, (_0, x))
</em>.variables[0].is_real is None
True
r.as_dummy()
_r</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_7">Notes</h1>
<p>Any object that has structurally bound variables should have
a property, <code>bound_symbols</code> that returns those symbols
appearing in the object.</p>
<h4 id="as_expr_1">as_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span>
<span class="p">)</span>
</code></pre></div>
<p>Convert a polynomial to a SymPy expression.</p>
<h1 id="examples_53">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>f = (x<strong>2 + x*y).as_poly(x, y)
f.as_expr()
x</strong>2 + x*y</p>
<p>sin(x).as_expr()
sin(x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_independent_1">as_independent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_independent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hint</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>A mostly naive separation of a Mul or Add into arguments that are not</p>
<p>are dependent on deps. To obtain as complete a separation of variables
as possible, use a separation method first, e.g.:</p>
<ul>
<li>separatevars() to change Mul, Add and Pow (including exp) into Mul</li>
<li>.expand(mul=True) to change Add or Mul into Add</li>
<li>.expand(log=True) to change log expr into an Add</li>
</ul>
<p>The only non-naive thing that is done here is to respect noncommutative
ordering of variables and to always return (0, 0) for <code>self</code> of zero
regardless of hints.</p>
<p>For nonzero <code>self</code>, the returned tuple (i, d) has the
following interpretation:</p>
<ul>
<li>i will has no variable that appears in deps</li>
<li>d will either have terms that contain variables that are in deps, or
  be equal to 0 (when self is an Add) or 1 (when self is a Mul)</li>
<li>if self is an Add then self = i + d</li>
<li>if self is a Mul then self = i*d</li>
<li>otherwise (self, S.One) or (S.One, self) is returned.</li>
</ul>
<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>
<h1 id="examples_54">Examples</h1>
<p>-- self is an Add</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos, exp
from sympy.abc import x, y, z</p>
<p>(x + x<em>y).as_independent(x)
(0, x</em>y + x)
(x + x<em>y).as_independent(y)
(x, x</em>y)
(2<em>x</em>sin(x) + y + x + z).as_independent(x)
(y + z, 2<em>x</em>sin(x) + x)
(2<em>x</em>sin(x) + y + x + z).as_independent(x, y)
(z, 2<em>x</em>sin(x) + x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>sin(x)</em>cos(y)).as_independent(x)
(cos(y), x*sin(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>non-commutative terms cannot always be separated out when self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
(n1 + n1<em>n2).as_independent(n2)
(n1, n1</em>n2)
(n2<em>n1 + n1</em>n2).as_independent(n2)
(0, n1<em>n2 + n2</em>n1)
(n1<em>n2</em>n3).as_independent(n1)
(1, n1<em>n2</em>n3)
(n1<em>n2</em>n3).as_independent(n2)
(n1, n2<em>n3)
((x-n1)</em>(x-y)).as_independent(x)
(1, (x - y)*(x - n1))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is anything else:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(sin(x)).as_independent(x)
(1, sin(x))
(sin(x)).as_independent(y)
(sin(x), 1)
exp(x+y).as_independent(x)
(1, exp(x + y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as an Add:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3<em>x).as_independent(x, as_Add=True)
(0, 3</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3+x).as_independent(x, as_Add=False)
(1, x + 3)
(-3+x).as_independent(x, as_Add=False)
(1, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note how the below differs from the above in making the
constant on the dep term positive.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(y*(-3+x)).as_independent(x)
(y, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- use .as_independent() for true independence testing instead
   of .has(). The former considers only symbols in the free
   symbols while the latter considers all symbols</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
I = Integral(x, (x, 1, 2))
I.has(x)
True
x in I.free_symbols
False
I.as_independent(x) == (I, 1)
True
(I + x).as_independent(x) == (I, x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note: when trying to get independent terms, a separation method
might need to be used first. In this case, it is important to keep
track of what you send to this routine so you know how to interpret
the returned values</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import separatevars, log
separatevars(exp(x+y)).as_independent(x)
(exp(y), exp(x))
(x + x<em>y).as_independent(y)
(x, x</em>y)
separatevars(x + x<em>y).as_independent(y)
(x, y + 1)
(x</em>(1 + y)).as_independent(y)
(x, y + 1)
(x<em>(1 + y)).expand(mul=True).as_independent(y)
(x, x</em>y)
a, b=symbols('a b', positive=True)
(log(a*b).expand(log=True)).as_independent(b)
(log(a), log(b))</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_15">See Also</h1>
<p>separatevars
expand_log
sympy.core.add.Add.as_two_terms
sympy.core.mul.Mul.as_two_terms
as_coeff_mul</p>
<h4 id="as_leading_term_1">as_leading_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_leading_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading (nonzero) term of the series expansion of self.</p>
<p>The _eval_as_leading_term routines are used to do this, and they must
always return a non-zero value.</p>
<h1 id="examples_55">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1 + x + x<strong>2).as_leading_term(x)
1
(1/x</strong>2 + x + x<strong>2).as_leading_term(x)
x</strong>(-2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_numer_denom_1">as_numer_denom</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_numer_denom</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>Return the numerator and the denominator of an expression.</p>
<p>expression -&gt; a/b -&gt; a, b</p>
<p>This is just a stub that should be defined by
an object's class methods to get anything else.</p>
<h1 id="see-also_16">See Also</h1>
<p>normal: return <code>a/b</code> instead of <code>(a, b)</code></p>
<h4 id="as_ordered_factors_1">as_ordered_factors</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_factors</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return list of ordered factors (if Mul) else [self].</p>
<h4 id="as_ordered_terms_1">as_ordered_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_terms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to an ordered list of terms.</p>
<h1 id="examples_56">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos
from sympy.abc import x</p>
<p>(sin(x)<strong>2*cos(x) + sin(x)</strong>2 + 1).as_ordered_terms()
[sin(x)<strong>2*cos(x), sin(x)</strong>2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_poly_1">as_poly</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_poly</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Converts <code>self</code> to a polynomial or returns <code>None</code>.</p>
<h1 id="explanation_7">Explanation</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>print((x<strong>2 + x*y).as_poly())
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x<strong>2 + x*y).as_poly(x, y))
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x**2 + sin(y)).as_poly(x, y))
None</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_powers_dict_1">as_powers_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_powers_dict</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self as a dictionary of factors with each factor being</p>
<p>treated as a power. The keys are the bases of the factors and the
values, the corresponding exponents. The resulting dictionary should
be used with caution if the expression is a Mul and contains non-
commutative factors since the order that they appeared will be lost in
the dictionary.</p>
<h1 id="see-also_17">See Also</h1>
<p>as_ordered_factors: An alternative for noncommutative applications,
                    returning an ordered list of factors.
args_cnc: Similar to as_ordered_factors, but guarantees separation
          of commutative and noncommutative factors.</p>
<h4 id="as_real_imag_1">as_real_imag</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_real_imag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Performs complex expansion on 'self' and returns a tuple</p>
<p>containing collected both real and imaginary parts. This
method cannot be confused with re() and im() functions,
which does not perform complex expansion at evaluation.</p>
<p>However it is possible to expand both re() and im()
functions and get exactly the same results as with
a single call to this function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, I</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>(x + y*I).as_real_imag()
(x, y)</p>
<p>from sympy.abc import z, w</p>
<p>(z + w*I).as_real_imag()
(re(z) - im(w), re(w) + im(z))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_set_1">as_set</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_set</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrites Boolean expression in terms of real sets.</p>
<h1 id="examples_57">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Eq, Or, And
x = Symbol('x', real=True)
Eq(x, 0).as_set()
{0}
(x &gt; 0).as_set()
Interval.open(0, oo)
And(-2 &lt; x, x &lt; 2).as_set()
Interval.open(-2, 2)
Or(x &lt; -2, 2 &lt; x).as_set()
Union(Interval.open(-oo, -2), Interval.open(2, oo))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_terms_1">as_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_terms</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to a list of terms. </p>
<h4 id="aseries_1">aseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">aseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">hir</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Asymptotic Series expansion of self.</p>
<p>This is equivalent to <code>self.series(x, oo, n)</code>.</p>
<h1 id="parameters_6">Parameters</h1>
<p>self : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>hir : Boolean
      Set this parameter to be True to produce hierarchical series.
      It stops the recursion at an early level and may provide nicer
      and more useful results.</p>
<p>bound : Value, Integer
        Use the <code>bound</code> parameter to give limit on rewriting
        coefficients in its normalised form.</p>
<h1 id="examples_58">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, exp
from sympy.abc import x</p>
<p>e = sin(1/x + exp(-x)) - sin(1/x)</p>
<p>e.aseries(x)
(1/(24<em>x</em><em>4) - 1/(2</em>x<strong>2) + 1 + O(x</strong>(-6), (x, oo)))*exp(-x)</p>
<p>e.aseries(x, n=3, hir=True)
-exp(-2<em>x)</em>sin(1/x)/2 + exp(-x)<em>cos(1/x) + O(exp(-3</em>x), (x, oo))</p>
<p>e = exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x)
exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x, bound=3) # doctest: +SKIP
exp(exp(x)/x<strong>2)<em>exp(exp(x)/x)</em>exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x</strong>2)*exp(exp(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).aseries(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_3">Returns</h1>
<p>Expr
    Asymptotic series expansion of the expression.</p>
<h1 id="notes_8">Notes</h1>
<p>This algorithm is directly induced from the limit computational algorithm provided by Gruntz.
It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first
to look for the most rapidly varying subexpression w of a given expression f and then expands f
in a series in w. Then same thing is recursively done on the leading coefficient
till we get constant coefficients.</p>
<p>If the most rapidly varying subexpression of a given expression f is f itself,
the algorithm tries to find a normalised representation of the mrv set and rewrites f
using this normalised representation.</p>
<p>If the expansion contains an order term, it will be either <code>O(x ** (-n))</code> or <code>O(w ** (-n))</code>
where <code>w</code> belongs to the most rapidly varying expression of <code>self</code>.</p>
<h1 id="references_2">References</h1>
<p>.. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series.
       In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993.
       pp. 239-244.
.. [2] Gruntz thesis - p90
.. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion</p>
<h1 id="see-also_18">See Also</h1>
<p>Expr.aseries: See the docstring of this function for complete details of this wrapper.</p>
<h4 id="atoms_1">atoms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">atoms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">types</span><span class="p">:</span> <span class="s1">&#39;Tbasic | type[Tbasic]&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;set[Basic] | set[Tbasic]&#39;</span>
</code></pre></div>
<p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and cannot
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<h1 id="examples_59">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import I, pi, sin
from sympy.abc import x, y
(1 + x + 2<em>sin(y + I</em>pi)).atoms()
{1, 2, I, pi, x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Number, NumberSymbol, Symbol
(1 + x + 2<em>sin(y + I</em>pi)).atoms(Symbol)
{x, y}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number)
{1, 2}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol)
{1, 2, pi}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol, I)
{1, 2, I, pi}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(x) # x is a Symbol
{x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Be careful to check your assumptions when using the implicit option
since <code>S(1).is_Integer = True</code> but <code>type(S(1))</code> is <code>One</code>, a special type
of SymPy atom, while <code>type(S(2))</code> is type <code>Integer</code> and will find all
integers in an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(1))
{1}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(2))
{1, 2}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
SymPy type (loaded in core/<strong>init</strong>.py) can be listed as an argument
and those types of "atoms" as found in scanning the arguments of the
expression recursively:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function, Mul
from sympy.core.function import AppliedUndef
f = Function('f')
(1 + f(x) + 2<em>sin(y + I</em>pi)).atoms(Function)
{f(x), sin(y + I<em>pi)}
(1 + f(x) + 2</em>sin(y + I*pi)).atoms(AppliedUndef)
{f(x)}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Mul)
{I<em>pi, 2</em>sin(y + I*pi)}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="cancel_1">cancel</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cancel</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the cancel function in sympy.polys</p>
<h4 id="coeff_1">coeff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">coeff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">_first</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the coefficient from the term(s) containing <code>x**n</code>. If <code>n</code></p>
<p>is zero then all terms independent of <code>x</code> will be returned.</p>
<h1 id="explanation_8">Explanation</h1>
<p>When <code>x</code> is noncommutative, the coefficient to the left (default) or
right of <code>x</code> can be returned. The keyword 'right' is ignored when
<code>x</code> is commutative.</p>
<h1 id="examples_60">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
from sympy.abc import x, y, z</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have an explicit negative in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x + 2<em>y).coeff(-1)
x
(x - 2</em>y).coeff(-1)
2*y</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms with no Rational coefficient:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + 2<em>y).coeff(1)
x
(3 + 2</em>x + 4<em>x</em>*2).coeff(1)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms independent of x by making n=0; in this case
expr.as_independent(x)[0] is returned (and 0 will be returned instead
of None):</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x, 0)
3
eq = ((x + 1)</strong>3).expand() + 1
eq
x<strong>3 + 3*x</strong>2 + 3*x + 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 2]
eq -= 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 0]</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have a numerical term in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x - 2<em>y).coeff(2)
-y
from sympy import sqrt
(x + sqrt(2)</em>x).coeff(sqrt(2))
x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The matching is exact:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x)
2
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>2)
4
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>3)
0
(z*(x + y)</strong>2).coeff((x + y)<strong>2)
z
(z*(x + y)</strong>2).coeff(x + y)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
from the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + z<em>(x + x</em>y)).coeff(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<p>If such factoring is desired, factor_terms can be used first:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import factor_terms
factor_terms(x + z<em>(x + x</em>y)).coeff(x)
z*(y + 1) + 1</p>
<p>n, m, o = symbols('n m o', commutative=False)
n.coeff(n)
1
(3<em>n).coeff(n)
3
(n</em>m + m<em>n</em>m).coeff(n) # = (1 + m)<em>n</em>m
1 + m
(n<em>m + m</em>n<em>m).coeff(n, right=True) # = (1 + m)</em>n*m
m</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is more than one possible coefficient 0 is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + m</em>n).coeff(n)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is only one possible coefficient, it is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + x</em>m<em>n).coeff(m</em>n)
x
(n<em>m + x</em>m<em>n).coeff(m</em>n, right=1)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_19">See Also</h1>
<p>as_coefficient: separate the expression into a coefficient and factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="collect_1">collect</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">syms</span><span class="p">,</span>
    <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">distribute_order_term</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the collect function in sympy.simplify</p>
<h4 id="combsimp_1">combsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">combsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the combsimp function in sympy.simplify</p>
<h4 id="compare_1">compare</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compare</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span>
<span class="p">)</span>
</code></pre></div>
<p>Return -1, 0, 1 if the object is less than, equal,</p>
<p>or greater than other in a canonical sense.
Non-Basic are always greater than Basic.
If both names of the classes being compared appear
in the <code>ordering_of_classes</code> then the ordering will
depend on the appearance of the names there.
If either does not appear in that list, then the
comparison is based on the class name.
If the names are the same then a comparison is made
on the length of the hashable content.
Items of the equal-lengthed contents are then
successively compared using the same rules. If there
is never a difference then 0 is returned.</p>
<h1 id="examples_61">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
x.compare(y)
-1
x.compare(x)
0
y.compare(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="conjugate_1">conjugate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">conjugate</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the complex conjugate of 'self'.</p>
<h4 id="copy_1">copy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="could_extract_minus_sign_1">could_extract_minus_sign</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">could_extract_minus_sign</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;bool&#39;</span>
</code></pre></div>
<p>Return True if self has -1 as a leading factor or has</p>
<p>more literal negative signs than positive signs in a sum,
otherwise False.</p>
<h1 id="examples_62">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = x - y
{i.could_extract_minus_sign() for i in (e, -e)}
{False, True}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Though the <code>y - x</code> is considered like <code>-(x - y)</code>, since it
is in a product without a leading factor of -1, the result is
false below:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*(y - x)).could_extract_minus_sign()
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>To put something in canonical form wrt to sign, use <code>signsimp</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import signsimp
signsimp(x<em>(y - x))
-x</em>(x - y)
_.could_extract_minus_sign()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="count_1">count</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span>
<span class="p">)</span>
</code></pre></div>
<p>Count the number of matching subexpressions.</p>
<h4 id="count_ops_1">count_ops</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_ops</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">visual</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for count_ops that returns the operation count.</p>
<h4 id="diff_1">diff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">diff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="dir_1">dir</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dir</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">cdir</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="doit_1">doit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">doit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate objects that are not evaluated by default like limits,</p>
<p>integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via 'hints'
or unless the 'deep' hint was set to 'False'.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
from sympy.abc import x</p>
<p>2<em>Integral(x, x)
2</em>Integral(x, x)</p>
<p>(2<em>Integral(x, x)).doit()
x</em>*2</p>
<p>(2<em>Integral(x, x)).doit(deep=False)
2</em>Integral(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="dummy_eq_1">dummy_eq</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dummy_eq</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">symbol</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compare two expressions and handle dummy symbols.</p>
<h1 id="examples_63">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Dummy
from sympy.abc import x, y</p>
<p>u = Dummy('u')</p>
<p>(u<strong>2 + 1).dummy_eq(x</strong>2 + 1)
True
(u<strong>2 + 1) == (x</strong>2 + 1)
False</p>
<p>(u<strong>2 + y).dummy_eq(x</strong>2 + y, x)
True
(u<strong>2 + y).dummy_eq(x</strong>2 + y, y)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="equals_1">equals</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">failing_expression</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self == other, False if it does not, or None. If</p>
<p>failing_expression is True then the expression which did not simplify
to a 0 will be returned instead of None.</p>
<h1 id="explanation_9">Explanation</h1>
<p>If <code>self</code> is a Number (or complex number) that is not zero, then
the result is False.</p>
<p>If <code>self</code> is a number and has not evaluated to zero, evalf will be
used to test whether the expression evaluates to zero. If it does so
and the result has significance (i.e. the precision is either -1, for
a Rational result, or is greater than 1) then the evalf value will be
used to return True or False.</p>
<h4 id="evalf_1">evalf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">evalf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_7">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_9">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="expand_1">expand</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">modulus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">power_base</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">power_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">multinomial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Expand an expression using hints.</p>
<p>See the docstring of the expand() function in sympy.core.function for
more information.</p>
<h4 id="extract_additively_1">extract_additively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_additively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self - c if it's possible to subtract c from self and</p>
<p>make all matching coefficients move towards zero, else return None.</p>
<h1 id="examples_64">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = 2<em>x + 3
e.extract_additively(x + 1)
x + 2
e.extract_additively(3</em>x)
e.extract_additively(4)
(y<em>(x + 1)).extract_additively(x + 1)
((x + 1)</em>(x + 2<em>y + 1) + 3).extract_additively(x + 1)
(x + 1)</em>(x + 2*y) + 3</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_20">See Also</h1>
<p>extract_multiplicatively
coeff
as_coefficient</p>
<h4 id="extract_branch_factor_1">extract_branch_factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_branch_factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">allow_half</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Try to write self as <code>exp_polar(2*pi*I*n)*z</code> in a nice way.</p>
<p>Return (z, n).</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp_polar, I, pi
from sympy.abc import x, y
exp_polar(I<em>pi).extract_branch_factor()
(exp_polar(I</em>pi), 0)
exp_polar(2<em>I</em>pi).extract_branch_factor()
(1, 1)
exp_polar(-pi<em>I).extract_branch_factor()
(exp_polar(I</em>pi), -1)
exp_polar(3<em>pi</em>I + x).extract_branch_factor()
(exp_polar(x + I<em>pi), 1)
(y</em>exp_polar(-5<em>pi</em>I)<em>exp_polar(3</em>pi<em>I + 2</em>pi<em>x)).extract_branch_factor()
(y</em>exp_polar(2<em>pi</em>x), -1)
exp_polar(-I<em>pi/2).extract_branch_factor()
(exp_polar(-I</em>pi/2), 0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If allow_half is True, also extract exp_polar(I*pi):</p>
<blockquote>
<blockquote>
<blockquote>
<p>exp_polar(I<em>pi).extract_branch_factor(allow_half=True)
(1, 1/2)
exp_polar(2</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 1)
exp_polar(3</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 3/2)
exp_polar(-I</em>pi).extract_branch_factor(allow_half=True)
(1, -1/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="extract_multiplicatively_1">extract_multiplicatively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_multiplicatively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Return None if it's not possible to make self in the form</p>
<p>c * something in a nice way, i.e. preserving the properties
of arguments of self.</p>
<h1 id="examples_65">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Rational</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em><em>2 * y)
x</em>y**2</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em>*4 * y)</p>
<p>(2*x).extract_multiplicatively(2)
x</p>
<p>(2*x).extract_multiplicatively(3)</p>
<p>(Rational(1, 2)*x).extract_multiplicatively(3)
x/6</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="factor_1">factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the factor() function in sympy.polys.polytools</p>
<h4 id="find_1">find</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Find all subexpressions matching a query.</p>
<h4 id="find_field_2">find_field</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_field</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s1">&#39;FieldableProtocol&#39;</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;str | int&#39;</span><span class="p">,</span>
    <span class="n">fallback_type</span><span class="p">:</span> <span class="s1">&#39;type | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">init_kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Reference[Any]&#39;</span>
</code></pre></div>
<p>Field within the reference, if possible.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>field</td>
<td>None</td>
<td>the field to search for.</td>
<td>None</td>
</tr>
<tr>
<td>fallback_type</td>
<td>None</td>
<td>the type to use if we do not know a more specific one.</td>
<td>None</td>
</tr>
<tr>
<td>**init_kwargs</td>
<td>None</td>
<td>arguments to use for constructing a new reference (via <code>__make_reference__</code>).</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A field-specific version of this reference.</td>
</tr>
</tbody>
</table>
<h4 id="fourier_series_1">fourier_series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fourier_series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">limits</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute fourier sine/cosine series of self.</p>
<p>See the docstring of the :func:<code>fourier_series</code> in sympy.series.fourier
for more information.</p>
<h4 id="fps_1">fps</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fps</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">hyper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute formal power power series of self.</p>
<p>See the docstring of the :func:<code>fps</code> function in sympy.series.formal for
more information.</p>
<h4 id="gammasimp_1">gammasimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gammasimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the gammasimp function in sympy.simplify</p>
<h4 id="geto_1">getO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Returns the additive O(..) symbol if there is one, else None.</p>
<h4 id="getn_1">getn</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getn</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the order of the expression.</p>
<h1 id="explanation_10">Explanation</h1>
<p>The order is determined either from the O(...) term. If there
is no O(...) term, it returns None.</p>
<h1 id="examples_66">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import O
from sympy.abc import x
(1 + x + O(x**2)).getn()
2
(1 + x).getn()</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_1">has</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether any subexpression matches any of the patterns.</p>
<h1 id="examples_67">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y, z
(x<strong>2 + sin(x*y)).has(z)
False
(x</strong>2 + sin(x*y)).has(x, y, z)
True
x.has(x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note <code>has</code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Interval
i = Interval.Lopen(0, 5); i
Interval.Lopen(0, 5)
i.args
(0, 5, True, False)
i.has(4)  # there is no "4" in the arguments
False
i.has(0)  # there <em>is</em> a "0" in the arguments
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Instead, use <code>contains</code> to determine whether a number is in the
interval or not:</p>
<blockquote>
<blockquote>
<blockquote>
<p>i.contains(4)
True
i.contains(0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that <code>expr.has(*patterns)</code> is exactly equivalent to
<code>any(expr.has(p) for p in patterns)</code>. In particular, <code>False</code> is
returned when the list of patterns is empty.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x.has()
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_free_1">has_free</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_free</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has object(s) <code>x</code> as a free expression</p>
<p>else False.</p>
<h1 id="examples_68">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Function
from sympy.abc import x, y
f = Function('f')
g = Function('g')
expr = Integral(f(x), (f(x), 1, g(y)))
expr.free_symbols
{y}
expr.has_free(g(y))
True
expr.has_free(*(x, f(x)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This works for subexpressions and types, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.has_free(g)
True
(x + y + 1).has_free(y + 1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_xfree_1">has_xfree</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_xfree</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;set[Basic]&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has any of the patterns in s as a</p>
<p>free argument, else False. This is like <code>Basic.has_free</code>
but this will only report exact argument matches.</p>
<h1 id="examples_69">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
from sympy.abc import x, y
f = Function('f')
f(x).has_xfree({f})
False
f(x).has_xfree({f(x)})
True
f(x + 1).has_xfree({x})
True
f(x + 1).has_xfree({x + 1})
True
f(x + y + 1).has_xfree({x + 1})
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="integrate_1">integrate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">integrate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the integrate function in sympy.integrals</p>
<h4 id="invert_1">invert</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">g</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the multiplicative inverse of <code>self</code> mod <code>g</code></p>
<p>where <code>self</code> (and <code>g</code>) may be symbolic expressions).</p>
<h1 id="see-also_21">See Also</h1>
<p>sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert</p>
<h4 id="is_algebraic_expr_1">is_algebraic_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_algebraic_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether a given expression is algebraic or not, in the</p>
<p>given symbols, syms. When syms is not given, all free symbols
will be used. The rational function does not have to be in expanded
or in any kind of canonical form.</p>
<p>This function returns False for expressions that are "algebraic
expressions" with symbolic exponents. This is a simple extension to the
is_rational_function, including rational exponentiation.</p>
<h1 id="examples_70">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sqrt
x = Symbol('x', real=True)
sqrt(1 + x).is_rational_function()
False
sqrt(1 + x).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be an algebraic
expression to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp, factor
a = sqrt(exp(x)*<em>2 + 2</em>exp(x) + 1)/(exp(x) + 1)
a.is_algebraic_expr(x)
False
factor(a).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_22">See Also</h1>
<p>is_rational_function</p>
<h1 id="references_3">References</h1>
<p>.. [1] https://en.wikipedia.org/wiki/Algebraic_expression</p>
<h4 id="is_constant_1">is_constant</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">wrt</span><span class="p">,</span>
    <span class="o">**</span><span class="n">flags</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is constant, False if not, or None if</p>
<p>the constancy could not be determined conclusively.</p>
<h1 id="explanation_11">Explanation</h1>
<p>If an expression has no free symbols then it is a constant. If
there are free symbols it is possible that the expression is a
constant, perhaps (but not necessarily) zero. To test such
expressions, a few strategies are tried:</p>
<p>1) numerical evaluation at two random points. If two such evaluations
give two different values and the values have a precision greater than
1 then self is not constant. If the evaluations agree or could not be
obtained with any precision, no decision is made. The numerical testing
is done only if <code>wrt</code> is different than the free symbols.</p>
<p>2) differentiation with respect to variables in 'wrt' (or all free
symbols if omitted) to see if the expression is constant or not. This
will not always lead to an expression that is zero even though an
expression is constant (see added test in test_expr.py). If
all derivatives are zero then self is constant with respect to the
given symbols.</p>
<p>3) finding out zeros of denominator expression with free_symbols.
It will not be constant if there are zeros. It gives more negative
answers for expression that are not constant.</p>
<p>If neither evaluation nor differentiation can prove the expression is
constant, None is returned unless two numerical values happened to be
the same and the flag <code>failing_number</code> is True -- in that case the
numerical value will be returned.</p>
<p>If flag simplify=False is passed, self will not be simplified;
the default is True since self should be simplified before testing.</p>
<h1 id="examples_71">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, Sum, S, pi
from sympy.abc import a, n, x, y
x.is_constant()
False
S(2).is_constant()
True
Sum(x, (x, 1, 10)).is_constant()
True
Sum(x, (x, 1, n)).is_constant()
False
Sum(x, (x, 1, n)).is_constant(y)
True
Sum(x, (x, 1, n)).is_constant(n)
False
Sum(x, (x, 1, n)).is_constant(x)
True
eq = a<em>cos(x)</em><em>2 + a</em>sin(x)**2 - a
eq.is_constant()
True
eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
True</p>
<p>(0<strong>x).is_constant()
False
x.is_constant()
False
(x</strong>x).is_constant()
False
one = cos(x)<strong>2 + sin(x)</strong>2
one.is_constant()
True
((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_hypergeometric_1">is_hypergeometric</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_hypergeometric</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">k</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="is_meromorphic_1">is_meromorphic</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_meromorphic</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">a</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether an expression is meromorphic as</p>
<p>a function of the given symbol <code>x</code> at the point <code>a</code>.</p>
<p>This method is intended as a quick test that will return
None if no decision can be made without simplification or
more detailed analysis.</p>
<h1 id="examples_72">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import zoo, log, sin, sqrt
from sympy.abc import x</p>
<p>f = 1/x<strong>2 + 1 - 2*x</strong>3
f.is_meromorphic(x, 0)
True
f.is_meromorphic(x, 1)
True
f.is_meromorphic(x, zoo)
True</p>
<p>g = x**log(3)
g.is_meromorphic(x, 0)
False
g.is_meromorphic(x, 1)
True
g.is_meromorphic(x, zoo)
False</p>
<p>h = sin(1/x)<em>x</em>*2
h.is_meromorphic(x, 0)
False
h.is_meromorphic(x, 1)
True
h.is_meromorphic(x, zoo)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multivalued functions are considered meromorphic when their
branches are meromorphic. Thus most functions are meromorphic
everywhere except at essential singularities and branch points.
In particular, they will be meromorphic also on branch cuts
except at their endpoints.</p>
<blockquote>
<blockquote>
<blockquote>
<p>log(x).is_meromorphic(x, -1)
True
log(x).is_meromorphic(x, 0)
False
sqrt(x).is_meromorphic(x, -1)
True
sqrt(x).is_meromorphic(x, 0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_polynomial_1">is_polynomial</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_polynomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is a polynomial in syms and False otherwise.</p>
<p>This checks if self is an exact polynomial in syms.  This function
returns False for expressions that are "polynomials" with symbolic
exponents.  Thus, you should be able to apply polynomial algorithms to
expressions for which this returns True, and Poly(expr, *syms) should
work if and only if expr.is_polynomial(*syms) returns True. The
polynomial does not have to be in expanded form.  If no symbols are
given, all free symbols in the expression will be used.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', polynomial=True).</p>
<h1 id="examples_73">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Function
x = Symbol('x')
((x<strong>2 + 1)</strong>4).is_polynomial(x)
True
((x<strong>2 + 1)</strong>4).is_polynomial()
True
(2<strong>x + 1).is_polynomial(x)
False
(2</strong>x + 1).is_polynomial(2**x)
True
f = Function('f')
(f(x) + 1).is_polynomial(x)
False
(f(x) + 1).is_polynomial(f(x))
True
(1/f(x) + 1).is_polynomial(f(x))
False</p>
<p>n = Symbol('n', nonnegative=True, integer=True)
(x**n + 1).is_polynomial(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a polynomial to
become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor, cancel
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)
a.is_polynomial(y)
False
factor(a)
y + 1
factor(a).is_polynomial(y)
True</p>
<p>b = (y*<em>2 + 2</em>y + 1)/(y + 1)
b.is_polynomial(y)
False
cancel(b)
y + 1
cancel(b).is_polynomial(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also .is_rational_function()</p>
<h4 id="is_rational_function_1">is_rational_function</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_rational_function</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether function is a ratio of two polynomials in the given</p>
<p>symbols, syms. When syms is not given, all free symbols will be used.
The rational function does not have to be in expanded or in any kind of
canonical form.</p>
<p>This function returns False for expressions that are "rational
functions" with symbolic exponents.  Thus, you should be able to call
.as_numer_denom() and apply polynomial algorithms to the result for
expressions for which this returns True.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', rational_function=True).</p>
<h1 id="examples_74">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sin
from sympy.abc import x, y</p>
<p>(x/y).is_rational_function()
True</p>
<p>(x**2).is_rational_function()
True</p>
<p>(x/sin(y)).is_rational_function(y)
False</p>
<p>n = Symbol('n', integer=True)
(x**n + 1).is_rational_function(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a rational function
to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)/y
a.is_rational_function(y)
False
factor(a)
(y + 1)/y
factor(a).is_rational_function(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also is_algebraic_expr().</p>
<h4 id="is_same_1">is_same</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_same</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span>
    <span class="n">b</span><span class="p">,</span>
    <span class="n">approx</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if a and b are structurally the same, else False.</p>
<p>If <code>approx</code> is supplied, it will be used to test whether two
numbers are the same or not. By default, only numbers of the
same type will compare equal, so S.Half != Float(0.5).</p>
<h1 id="examples_75">Examples</h1>
<p>In SymPy (unlike Python) two numbers do not compare the same if they are
not of the same type:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
2.0 == S(2)
False
0.5 == S.Half
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>By supplying a function with which to compare two numbers, such
differences can be ignored. e.g. <code>equal_valued</code> will return True
for decimal numbers having a denominator that is a power of 2,
regardless of precision.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Float
from sympy.core.numbers import equal_valued
(S.Half/4).is_same(Float(0.125, 1), equal_valued)
True
Float(1, 2).is_same(Float(1, 10), equal_valued)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>But decimals without a power of 2 denominator will compare
as not being the same.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Float(0.1, 9).is_same(Float(0.1, 10), equal_valued)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>But arbitrary differences can be ignored by supplying a function
to test the equivalence of two numbers:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import math
Float(0.1, 9).is_same(Float(0.1, 10), math.isclose)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Other objects might compare the same even though types are not the
same. This routine will only return True if two expressions are
identical in terms of class types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import eye, Basic
eye(1) == S(eye(1))  # mutable vs immutable
True
Basic.is_same(eye(1), S(eye(1)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="leadterm_1">leadterm</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">leadterm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading term a<em>x</em>*b as a tuple (a, b).</p>
<h1 id="examples_76">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1+x+x<strong>2).leadterm(x)
(1, 0)
(1/x</strong>2+x+x**2).leadterm(x)
(1, -2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="limit_1">limit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">limit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">xlim</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute limit x-&gt;xlim.</p>
<h4 id="lseries_1">lseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for series yielding an iterator of the terms of the series.</p>
<p>Note: an infinite series will yield an infinite iterator. The following,
for exaxmple, will never terminate. It will just keep printing terms
of the sin(x) series::</p>
<p>for term in sin(x).lseries(x):
      print term</p>
<p>The advantage of lseries() over nseries() is that many times you are
just interested in the next term in the series (i.e. the first term for
example), but you do not know how many you should ask for in nseries()
using the "n" parameter.</p>
<p>See also nseries().</p>
<h4 id="match_1">match</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code>None</code> when expression (self) does not match with pattern.
Otherwise return a dictionary such that::</p>
<p>pattern.xreplace(self.match(pattern)) == self</p>
<h1 id="examples_77">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Wild, Sum
from sympy.abc import x, y
p = Wild("p")
q = Wild("q")
r = Wild("r")
e = (x+y)<strong>(x+y)
e.match(p</strong>p)
{p_: x + y}
e.match(p<strong>q)
{p_: x + y, q_: x + y}
e = (2*x)</strong>2
e.match(p<em>q</em><em>r)
{p_: 4, q_: x, r_: 2}
(p</em>q<strong>r).xreplace(e.match(p*q</strong>r))
4<em>x</em>*2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since match is purely structural expressions that are equivalent up to
bound symbols will not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p))))
None</p>
</blockquote>
</blockquote>
</blockquote>
<p>An expression with bound symbols can be matched if the pattern uses
a distinct <code>Wild</code> for each bound symbol:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))
{p_: 2, q_: x}</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>old</code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the match. Both
of the following give None unless <code>old=True</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x - 2).match(p - x, old=True)
{p_: 2<em>x - 2}
(2/x).match(p</em>x, old=True)
{p_: 2/x**2}</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_23">See Also</h1>
<p>matches: pattern.matches(expr) is the same as expr.match(pattern)
xreplace: exact structural replacement
replace: structural replacement with pattern matching
Wild: symbolic placeholders for expressions in pattern matching</p>
<h4 id="matches_1">matches</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">matches</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">,</span>
    <span class="n">repl_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Helper method for match() that looks for a match between Wild symbols</p>
<p>in self and expressions in expr.</p>
<h1 id="examples_78">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Wild, Basic
a, b, c = symbols('a b c')
x = Wild('x')
Basic(a + x, x).matches(Basic(a + b, c)) is None
True
Basic(a + x, x).matches(Basic(a + b + c, b + c))
{x_: b + c}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="n_1">n</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_8">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_10">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="normal_1">normal</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">normal</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression as a fraction.</p>
<p>expression -&gt; a/b</p>
<h1 id="see-also_24">See Also</h1>
<p>as_numer_denom: return <code>(a, b)</code> instead of <code>a/b</code></p>
<h4 id="nseries_1">nseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>
<p>If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
called. This calculates "n" terms in the innermost expressions and
then builds up the final series just by "cross-multiplying" everything
out.</p>
<p>The optional <code>logx</code> parameter can be used to replace any log(x) in the
returned series with a symbolic value to avoid evaluating log(x) at 0. A
symbol to use in place of log(x) should be provided.</p>
<p>Advantage -- it's fast, because we do not have to determine how many
terms we need to calculate in advance.</p>
<p>Disadvantage -- you may end up with less terms than you may have
expected, but the O(x**n) term appended will always be correct and
so the result, though perhaps shorter, will also be correct.</p>
<p>If any of those assumptions is not met, this is treated like a
wrapper to series which will try harder to return the correct
number of terms.</p>
<p>See also lseries().</p>
<h1 id="examples_79">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, log, Symbol
from sympy.abc import x, y
sin(x).nseries(x, 0, 6)
x - x<strong>3/6 + x</strong>5/120 + O(x<strong>6)
log(x+1).nseries(x, 0, 5)
x - x</strong>2/2 + x<strong>3/3 - x</strong>4/4 + O(x**5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Handling of the <code>logx</code> parameter --- in the following example the
expansion fails since <code>sin</code> does not have an asymptotic expansion
at -oo (the limit of log(x) as x approaches 0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = sin(log(x))
e.nseries(x, 0, 6)
Traceback (most recent call last):
...
PoleError: ...
...
logx = Symbol('logx')
e.nseries(x, 0, 6, logx=logx)
sin(logx)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the following example, the expansion works but only returns self
unless the <code>logx</code> parameter is used:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>y
e.nseries(x, 0, 2)
x</strong>y
e.nseries(x, 0, 2, logx=logx)
exp(logx*y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="nsimplify_1">nsimplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nsimplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">constants</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the nsimplify function in sympy.simplify</p>
<h4 id="powsimp_1">powsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">powsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the powsimp function in sympy.simplify</p>
<h4 id="primitive_1">primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">primitive</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Number, Expr]&#39;</span>
</code></pre></div>
<p>Return the positive Rational that can be extracted non-recursively</p>
<p>from every term of self (i.e., self is treated like an Add). This is
like the as_coeff_Mul() method but primitive always extracts a positive
Rational (never a negative or a Float).</p>
<h1 id="examples_80">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(3<em>(x + 1)</em><em>2).primitive()
(3, (x + 1)</em><em>2)
a = (6</em>x + 2); a.primitive()
(2, 3<em>x + 1)
b = (x/2 + 3); b.primitive()
(1/2, x + 6)
(a</em>b).primitive() == (1, a*b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="radsimp_1">radsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">radsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the radsimp function in sympy.simplify</p>
<h4 id="ratsimp_1">ratsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">ratsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the ratsimp function in sympy.simplify</p>
<h4 id="rcall_1">rcall</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rcall</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance, in SymPy the following will not work:</p>
<p><code>(x+Lambda(y, 2*y))(z) == x+2*z</code>,</p>
<p>however, you can use:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x, y, z
(x + Lambda(y, 2<em>y)).rcall(z)
x + 2</em>z</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="refine_1">refine</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">refine</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">assumption</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the refine function in sympy.assumptions</p>
<h4 id="removeo_1">removeO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">removeO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr&#39;</span>
</code></pre></div>
<p>Removes the additive O(..) symbol if there is one</p>
<h4 id="replace_1">replace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="nb">map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Replace matching subexpressions of <code>self</code> with <code>value</code>.</p>
<p>If <code>map = True</code> then also return the mapping {old: new} where <code>old</code>
was a sub-expression found with query and <code>new</code> is the replacement
value for it. If the expression itself does not match the query, then
the returned value will be <code>self.xreplace(map)</code> otherwise it should
be <code>self.subs(ordered(map.items()))</code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code>simultaneous</code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code>exact</code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<h1 id="examples_81">Examples</h1>
<p>Initial setup</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import log, sin, cos, tan, Wild, Mul, Add
from sympy.abc import x, y
f = log(sin(x)) + tan(sin(x**2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>1.1. type -&gt; type
    obj.replace(type, newtype)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, replace it with the
result of passing its argument(s) to ``newtype``.

&gt;&gt;&gt; f.replace(sin, cos)
log(cos(x)) + tan(cos(x**2))
&gt;&gt;&gt; sin(x).replace(sin, cos, map=True)
(cos(x), {sin(x): cos(x)})
&gt;&gt;&gt; (x*y).replace(Mul, Add)
x + y
</code></pre></div>
<p>1.2. type -&gt; func
    obj.replace(type, func)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, apply ``func`` to its
argument(s). ``func`` must be written to handle the number
of arguments of ``type``.

&gt;&gt;&gt; f.replace(sin, lambda arg: sin(2*arg))
log(sin(2*x)) + tan(sin(2*x**2))
&gt;&gt;&gt; (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))
sin(2*x*y)
</code></pre></div>
<p>2.1. pattern -&gt; expr
    obj.replace(pattern(wild), expr(wild))</p>
<div class="highlight"><pre><span></span><code>Replace subexpressions matching ``pattern`` with the expression
written in terms of the Wild symbols in ``pattern``.

&gt;&gt;&gt; a, b = map(Wild, &#39;ab&#39;)
&gt;&gt;&gt; f.replace(sin(a), tan(a))
log(tan(x)) + tan(tan(x**2))
&gt;&gt;&gt; f.replace(sin(a), tan(a/2))
log(tan(x/2)) + tan(tan(x**2/2))
&gt;&gt;&gt; f.replace(sin(a), a)
log(x) + tan(x**2)
&gt;&gt;&gt; (x*y).replace(a*x, a)
y

Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:

&gt;&gt;&gt; (2*x + y).replace(a*x + b, b - a)
y - 2
&gt;&gt;&gt; (2*x).replace(a*x + b, b - a)
2*x

When set to False, the results may be non-intuitive:

&gt;&gt;&gt; (2*x).replace(a*x + b, b - a, exact=False)
2/x
</code></pre></div>
<p>2.2. pattern -&gt; func
    obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<div class="highlight"><pre><span></span><code>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:

&gt;&gt;&gt; f.replace(sin(a), lambda a: sin(2*a))
log(sin(2*x)) + tan(sin(2*x**2))
</code></pre></div>
<p>3.1. func -&gt; func
    obj.replace(filter, func)</p>
<div class="highlight"><pre><span></span><code>Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``
is True.

&gt;&gt;&gt; g = 2*sin(x**3)
&gt;&gt;&gt; g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)
4*sin(x**9)
</code></pre></div>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; e = x*(x*y + 1)
&gt;&gt;&gt; e.replace(lambda x: x.is_Mul, lambda x: 2*x)
2*x*(2*x*y + 1)
</code></pre></div>
<p>When matching a single symbol, <code>exact</code> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <code>exact=False</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
f = Function('f')
e = f(1) + f(0)
q = f(a), lambda a: f(a + 1)
e.replace(<em>q, exact=False)
f(1) + f(2)
e.replace(</em>q, exact=True)
f(0) + f(2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>(1 + y)
(x</strong>(1 + y)).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=False)
x
(x<strong>(1 + y)).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=True)
x</strong>(-x - y + 1)
(x<strong>y).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=False)
x
(x</strong>y).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=True)
x**(1 - y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x<strong>(1 + y)).replace(
... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,
... lambda x: x.base</strong>(1 - (x.exp - 1)))
...
x**(1 - y) + 1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_25">See Also</h1>
<p>subs: substitution of subexpressions as defined by the objects
      themselves.
xreplace: exact node replacement in expr tree; also capable of
          using matching rules</p>
<h4 id="rewrite_1">rewrite</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rewrite</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrite <em>self</em> using a defined rule.</p>
<p>Rewriting transforms an expression to another, which is mathematically
equivalent but structurally different. For example you can rewrite
trigonometric functions as complex exponentials or combinatorial
functions as gamma function.</p>
<p>This method takes a <em>pattern</em> and a <em>rule</em> as positional arguments.
<em>pattern</em> is optional parameter which defines the types of expressions
that will be transformed. If it is not passed, all possible expressions
will be rewritten. <em>rule</em> defines how the expression will be rewritten.</p>
<h1 id="parameters_9">Parameters</h1>
<p>args : Expr
    A <em>rule</em>, or <em>pattern</em> and <em>rule</em>.
    - <em>pattern</em> is a type or an iterable of types.
    - <em>rule</em> can be any object.</p>
<p>deep : bool, optional
    If <code>True</code>, subexpressions are recursively transformed. Default is
    <code>True</code>.</p>
<h1 id="examples_82">Examples</h1>
<p>If <em>pattern</em> is unspecified, all possible expressions are transformed.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, exp, I
from sympy.abc import x
expr = cos(x) + I<em>sin(x)
expr.rewrite(exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Pattern can be a type or an iterable of types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.rewrite(sin, exp)
exp(I<em>x)/2 + cos(x) - exp(-I</em>x)/2
expr.rewrite([cos,], exp)
exp(I<em>x)/2 + I</em>sin(x) + exp(-I<em>x)/2
expr.rewrite([cos, sin], exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Rewriting behavior can be implemented by defining <code>_eval_rewrite()</code>
method.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Expr, sqrt, pi
class MySin(Expr):
...     def _eval_rewrite(self, rule, args, <strong>hints):
...         x, = args
...         if rule == cos:
...             return cos(pi/2 - x, evaluate=False)
...         if rule == sqrt:
...             return sqrt(1 - cos(x)</strong>2)
MySin(MySin(x)).rewrite(cos)
cos(-cos(-x + pi/2) + pi/2)
MySin(x).rewrite(sqrt)
sqrt(1 - cos(x)**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Defining <code>_eval_rewrite_as_[...]()</code> method is supported for backwards
compatibility reason. This may be removed in the future and using it is
discouraged.</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MySin(Expr):
...     def _eval_rewrite_as_cos(self, <em>args, </em>*hints):
...         x, = args
...         return cos(pi/2 - x, evaluate=False)
MySin(x).rewrite(cos)
cos(-x + pi/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="round_1">round</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return x rounded to the given decimal place.</p>
<p>If a complex number would results, apply round to the real
and imaginary components of the number.</p>
<h1 id="examples_83">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, E, I, S, Number
pi.round()
3
pi.round(2)
3.14
(2<em>pi + E</em>I).round()
6 + 3*I</p>
</blockquote>
</blockquote>
</blockquote>
<p>The round method has a chopping effect:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>pi + I/10).round()
6
(pi/10 + 2</em>I).round()
2<em>I
(pi/10 + E</em>I).round(2)
0.31 + 2.72*I</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_11">Notes</h1>
<p>The Python <code>round</code> function uses the SymPy <code>round</code> method so it
will always return a SymPy number (not a Python float or int):</p>
<blockquote>
<blockquote>
<blockquote>
<p>isinstance(round(S(123), -2), Number)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="separate_1">separate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">separate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">force</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the separate function in sympy.simplify</p>
<h4 id="series_1">series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Series expansion of "self" around <code>x = x0</code> yielding either terms of</p>
<p>the series one by one (the lazy series given when n=None), else
all the terms at once when n != None.</p>
<p>Returns the series expansion of "self" around the point <code>x = x0</code>
with respect to <code>x</code> up to <code>O((x - x0)**n, x, x0)</code> (default n is 6).</p>
<p>If <code>x=None</code> and <code>self</code> is univariate, the univariate symbol will
be supplied, otherwise an error will be raised.</p>
<h1 id="parameters_10">Parameters</h1>
<p>expr : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>x0 : Value
     The value around which <code>x</code> is calculated. Can be any value
     from <code>-oo</code> to <code>oo</code>.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>dir : String, optional
      The series-expansion can be bi-directional. If <code>dir="+"</code>,
      then (x-&gt;x0+). If <code>dir="-", then (x-&gt;x0-). For infinite</code>x0<code>(</code>oo<code>or</code>-oo<code>), the</code>dir<code>argument is determined
      from the direction of the infinity (i.e.,</code>dir="-"<code>for</code>oo``).</p>
<p>logx : optional
       It is used to replace any log(x) in the returned series with a
       symbolic value rather than evaluating the actual value.</p>
<p>cdir : optional
       It stands for complex direction, and indicates the direction
       from which the expansion needs to be evaluated.</p>
<h1 id="examples_84">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, exp, tan
from sympy.abc import x, y
cos(x).series()
1 - x<strong>2/2 + x</strong>4/24 + O(x<strong>6)
cos(x).series(n=4)
1 - x</strong>2/2 + O(x<strong>4)
cos(x).series(x, x0=1, n=2)
cos(1) - (x - 1)*sin(1) + O((x - 1)</strong>2, (x, 1))
e = cos(x + exp(y))
e.series(y, n=2)
cos(x + 1) - y<em>sin(x + 1) + O(y</em><em>2)
e.series(x, n=2)
cos(exp(y)) - x</em>sin(exp(y)) + O(x**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>n=None</code> then a generator of the series terms will be returned.</p>
<blockquote>
<blockquote>
<blockquote>
<p>term=cos(x).series(n=None)
[next(term) for i in range(2)]
[1, -x**2/2]</p>
</blockquote>
</blockquote>
</blockquote>
<p>For <code>dir=+</code> (default) the series is calculated from the right and
for <code>dir=-</code> the series from the left. For smooth functions this
flag will not alter the results.</p>
<blockquote>
<blockquote>
<blockquote>
<p>abs(x).series(dir="+")
x
abs(x).series(dir="-")
-x
f = tan(x)
f.series(x, 2, 6, "+")
tan(2) + (1 + tan(2)<strong>2)*(x - 2) + (x - 2)</strong>2<em>(tan(2)</em><em>3 + tan(2)) +
(x - 2)</em><em>3</em>(1/3 + 4<em>tan(2)</em><em>2/3 + tan(2)</em><em>4) + (x - 2)</em><em>4</em>(tan(2)<strong>5 +
5*tan(2)</strong>3/3 + 2<em>tan(2)/3) + (x - 2)</em><em>5</em>(2/15 + 17<em>tan(2)</em><em>2/15 +
2</em>tan(2)<strong>4 + tan(2)</strong>6) + O((x - 2)**6, (x, 2))</p>
<p>f.series(x, 2, 3, "-")
tan(2) + (2 - x)<em>(-tan(2)</em><em>2 - 1) + (2 - x)</em><em>2</em>(tan(2)<strong>3 + tan(2))
+ O((x - 2)</strong>3, (x, 2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).series(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_4">Returns</h1>
<p>Expr : Expression
    Series expansion of the expression about x0</p>
<h1 id="raises_1">Raises</h1>
<p>TypeError
    If "n" and "x0" are infinity objects</p>
<p>PoleError
    If "x0" is an infinity object</p>
<h4 id="simplify_1">simplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>See the simplify function in sympy.simplify</p>
<h4 id="sort_key_1">sort_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sort_key</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a sort key.</p>
<h1 id="examples_85">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S, I</p>
<p>sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())
[1/2, -I, I]</p>
<p>S("[x, 1/x, 1/x<strong>2, x</strong>2, x<strong>(1/2), x</strong>(1/4), x<strong>(3/2)]")
[x, 1/x, x</strong>(-2), x<strong>2, sqrt(x), x</strong>(1/4), x<strong>(3/2)]
sorted(_, key=lambda x: x.sort_key())
[x</strong>(-2), 1/x, x<strong>(1/4), sqrt(x), x, x</strong>(3/2), x**2]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="subs_1">subs</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">subs</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">arg1</span><span class="p">:</span> <span class="s1">&#39;Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex&#39;</span><span class="p">,</span>
    <span class="n">arg2</span><span class="p">:</span> <span class="s1">&#39;Basic | complex | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Substitutes old for new in an expression after sympifying args.</p>
<p><code>args</code> is either:
  - two arguments, e.g. foo.subs(old, new)
  - one iterable argument, e.g. foo.subs(iterable). The iterable may be
     o an iterable container with (old, new) pairs. In this case the
       replacements are processed in the order given with successive
       patterns possibly affecting replacements already made.
     o a dict or set whose key/value items correspond to old/new pairs.
       In this case the old/new pairs will be sorted by op count and in
       case of a tie, by number of args and the default_sort_key. The
       resulting sorted list is then processed as an iterable container
       (see previous).</p>
<p>If the keyword <code>simultaneous</code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<h1 id="examples_86">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, exp, limit, oo
from sympy.abc import x, y
(1 + x<em>y).subs(x, pi)
pi</em>y + 1
(1 + x<em>y).subs({x:pi, y:2})
1 + 2</em>pi
(1 + x<em>y).subs([(x, pi), (y, 2)])
1 + 2</em>pi
reps = [(y, x<strong>2), (x, 2)]
(x + y).subs(reps)
6
(x + y).subs(reversed(reps))
x</strong>2 + 2</p>
<p>(x<strong>2 + x</strong>4).subs(x<strong>2, y)
y</strong>2 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To replace only the x<strong>2 but not the x</strong>4, use xreplace:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<strong>2 + x</strong>4).xreplace({x<strong>2: y})
x</strong>4 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code>simultaneous</code> to True:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/y).subs([(x, 0), (y, 0)])
0
(x/y).subs([(x, 0), (y, 0)], simultaneous=True)
nan</p>
</blockquote>
</blockquote>
</blockquote>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((x + y)/y).subs({x + y: y, y: x + y})
1
((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
y/(x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, sin, cos
from sympy.abc import a, b, c, d, e</p>
<p>A = (sqrt(sin(2<em>x)), a)
B = (sin(2</em>x), b)
C = (cos(2*x), c)
D = (x, d)
E = (exp(x), e)</p>
<p>expr = sqrt(sin(2<em>x))</em>sin(exp(x)<em>x)</em>cos(2<em>x) + sin(2</em>x)</p>
<p>expr.subs(dict([A, B, C, D, E]))
a<em>c</em>sin(d*e) + b</p>
</blockquote>
</blockquote>
</blockquote>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*<em>3 - 3</em>x).subs({x: oo})
nan</p>
<p>limit(x*<em>3 - 3</em>x, x, oo)
oo</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).evalf(subs={x: 3.0}, n=21)
0.333333333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<p>rather than</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).subs({x: 3.0}).evalf(21)
0.333333333333333314830</p>
</blockquote>
</blockquote>
</blockquote>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
<h1 id="see-also_26">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
xreplace: exact node replacement in expr tree; also capable of
          using matching rules
sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision</p>
<h4 id="taylor_term_1">taylor_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">taylor_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="o">*</span><span class="n">previous_terms</span>
<span class="p">)</span>
</code></pre></div>
<p>General method for the taylor term.</p>
<p>This method is slow, because it differentiates n-times. Subclasses can
redefine it to make it faster by using the "previous_terms".</p>
<h4 id="to_nnf_1">to_nnf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_nnf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="together_1">together</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">together</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the together function in sympy.polys</p>
<h4 id="transpose_1">transpose</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="trigsimp_1">trigsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">trigsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the trigsimp function in sympy.simplify</p>
<h4 id="xreplace_1">xreplace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">xreplace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rule</span><span class="p">,</span>
    <span class="n">hack2</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Replace occurrences of objects within the expression.</p>
<h1 id="parameters_11">Parameters</h1>
<p>rule : dict-like
    Expresses a replacement rule</p>
<h1 id="returns_5">Returns</h1>
<p>xreplace : the result of the replacement</p>
<h1 id="examples_87">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, pi, exp
x, y, z = symbols('x y z')
(1 + x<em>y).xreplace({x: pi})
pi</em>y + 1
(1 + x<em>y).xreplace({x: pi, y: 2})
1 + 2</em>pi</p>
</blockquote>
</blockquote>
</blockquote>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>y + z).xreplace({x</em>y: pi})
z + pi
(x<em>y</em>z).xreplace({x<em>y: pi})
x</em>y<em>z
(2</em>x).xreplace({2<em>x: y, x: z})
y
(2</em>2<em>x).xreplace({2</em>x: y, x: z})
4*z
(x + y + 2).xreplace({x + y: 2})
x + y + 2
(x + 2 + exp(x + 2)).xreplace({x + 2: y})
x + exp(y) + 2</p>
</blockquote>
</blockquote>
</blockquote>
<p>xreplace does not differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
Integral(x, (x, 1, 2<em>x)).xreplace({x: y})
Integral(y, (y, 1, 2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Trying to replace x with an expression raises an error:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Integral(x, (x, 1, 2<em>x)).xreplace({x: 2</em>y}) # doctest: +SKIP
ValueError: Invalid limits given: ((2<em>y, 1, 4</em>y),)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_27">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
subs: substitution of subexpressions as defined by the objects
      themselves.</p>
<h3 id="lazy">Lazy</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Lazy</span><span class="p">(</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>Requirements for a lazy-evaluatable function.</p>
<h4 id="ancestors-in-mro_5">Ancestors (in MRO)</h4>
<ul>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h4 id="descendants_2">Descendants</h4>
<ul>
<li>dewret.workflow.LazyEvaluation</li>
</ul>
<h3 id="lazyevaluation">LazyEvaluation</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">LazyEvaluation</span><span class="p">(</span>
    <span class="n">fn</span><span class="p">:</span> <span class="s1">&#39;Callable[Param, RetType]&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Tracks a single evaluation of a lazy function.</p>
<h4 id="ancestors-in-mro_6">Ancestors (in MRO)</h4>
<ul>
<li>dewret.workflow.Lazy</li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3 id="nestedstep">NestedStep</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">NestedStep</span><span class="p">(</span>
    <span class="n">workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;str&#39;</span><span class="p">,</span>
    <span class="n">subworkflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Mapping[str, Basic | Reference[Any] | Raw]&#39;</span><span class="p">,</span>
    <span class="n">raw_as_parameter</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Calling out to a subworkflow.</p>
<p>Type of BaseStep to call a subworkflow, which holds a reference to it.</p>
<h4 id="ancestors-in-mro_7">Ancestors (in MRO)</h4>
<ul>
<li>dewret.workflow.BaseStep</li>
<li>dewret.core.WorkflowComponent</li>
</ul>
<h4 id="class-variables_4">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">positional_args</span>
</code></pre></div>
<h4 id="instance-variables_5">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="nb">id</span>
</code></pre></div>
<p>Consistent ID based on the value.</p>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Name for this step.</p>
<p>May be remapped by the workflow to something nicer
than the ID.</p>
<div class="highlight"><pre><span></span><code><span class="n">return_type</span>
</code></pre></div>
<p>Take the type of the wrapped function from the target.</p>
<p>Unwraps and inspects the signature, meaning that the original
wrapped function <em>must</em> have a typehint for the return value.</p>
<div class="highlight"><pre><span></span><code><span class="n">subworkflow</span>
</code></pre></div>
<p>Subworkflow that is wrapped.</p>
<h4 id="methods_5">Methods</h4>
<h4 id="make_reference_2">make_reference</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_reference</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;&#39;StepReference[T]&#39;&quot;</span>
</code></pre></div>
<p>Create a reference to this step.</p>
<p>Builds a reference to the (result of) this step, which will be iterable if appropriate.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>arguments for reference constructor, which will be supplemented appropriately.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="set_workflow_2">set_workflow</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set_workflow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">with_arguments</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;None&#39;</span>
</code></pre></div>
<p>Move the step reference to another workflow.</p>
<p>This method is primarily intended to be called by a step, allowing it to
switch to a new workflow. It also updates the workflow reference for any
arguments that are steps themselves, if specified.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>workflow</td>
<td>None</td>
<td>The new target workflow to which the step should be moved.</td>
<td>None</td>
</tr>
<tr>
<td>with_arguments</td>
<td>None</td>
<td>If True, also update the workflow reference for the step's arguments.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h3 id="parameter">Parameter</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Parameter</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;str&#39;</span><span class="p">,</span>
    <span class="n">default</span><span class="p">:</span> <span class="s1">&#39;T | UnsetType[T]&#39;</span><span class="p">,</span>
    <span class="n">tethered</span><span class="p">:</span> <span class="s1">&#39;Literal[False] | None | Step | Workflow&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">autoname</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">typ</span><span class="p">:</span> <span class="s1">&#39;type[T] | Unset&#39;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">dewret</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">Unset</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f2d6ea66910</span><span class="o">&gt;</span>
<span class="p">)</span>
</code></pre></div>
<p>Global parameter.</p>
<p>Independent parameter that will be used when a task is spotted
reaching outside its scope. This wraps the variable it uses.</p>
<p>To allow for potential arithmetic operations, etc. it is a Sympy
symbol.</p>
<h4 id="attributes_2">Attributes</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>name</strong></td>
<td>None</td>
<td>name of the parameter.</td>
<td>None</td>
</tr>
<tr>
<td><strong>default</strong></td>
<td>None</td>
<td>captured default value from the original value.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="ancestors-in-mro_8">Ancestors (in MRO)</h4>
<ul>
<li>typing.Generic</li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.printing.defaults.Printable</li>
<li>sympy.core.evalf.EvalfMixin</li>
</ul>
<h4 id="class-variables_5">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">autoname</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">default_assumptions</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Add</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_AlgebraicNumber</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Atom</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Boolean</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Derivative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Dummy</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Equality</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Float</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Function</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Indexed</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatAdd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatMul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Matrix</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Mul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Not</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_NumberSymbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Order</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Piecewise</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Point</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Poly</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Pow</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Relational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Symbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Vector</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Wild</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_comparable</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_scalar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_symbol</span>
</code></pre></div>
<h4 id="static-methods_2">Static methods</h4>
<h4 id="class_key_2">class_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">class_key</span><span class="p">(</span>
    
<span class="p">)</span>
</code></pre></div>
<p>Nice order of classes.</p>
<h4 id="fromiter_2">fromiter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fromiter</span><span class="p">(</span>
    <span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<h1 id="examples_88">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Tuple
Tuple.fromiter(i for i in range(5))
(0, 1, 2, 3, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_loopable">is_loopable</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_loopable</span><span class="p">(</span>
    <span class="n">typ</span><span class="p">:</span> <span class="s1">&#39;type&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;bool&#39;</span>
</code></pre></div>
<p>Checks if this type can be looped over.</p>
<p>In particular, checks if this is an iterable that is NOT a str or bytes, possibly disguised
behind an Annotated.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>typ</td>
<td>None</td>
<td>type to check.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="instance-variables_6">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">args</span>
</code></pre></div>
<p>Returns a tuple of arguments of 'self'.</p>
<h1 id="examples_89">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cot
from sympy.abc import x, y</p>
<p>cot(x).args
(x,)</p>
<p>cot(x).args[0]
x</p>
<p>(x*y).args
(x, y)</p>
<p>(x*y).args[1]
y</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_12">Notes</h1>
<p>Never use self._args, always use self.args.
Only use _args in <strong>new</strong> when creating a new function.
Do not override .args() from Basic (so that it is easy to
change the interface in the future if needed).</p>
<div class="highlight"><pre><span></span><code><span class="n">assumptions0</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">binary_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">canonical_variables</span>
</code></pre></div>
<p>Return a dictionary mapping any variable defined in</p>
<p><code>self.bound_symbols</code> to Symbols that do not clash
with any free symbols in the expression.</p>
<h1 id="examples_90">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x
Lambda(x, 2*x).canonical_variables
{x: _0}</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">default</span>
</code></pre></div>
<p>Retrieve default value for this parameter, or an unset token.</p>
<div class="highlight"><pre><span></span><code><span class="n">expr_free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">func</span>
</code></pre></div>
<p>The top-level function in an expression.</p>
<p>The following should hold for all objects::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt; x == x.func(*x.args)
</code></pre></div>
<h1 id="examples_91">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
a = 2<em>x
a.func
<class 'sympy.core.mul.Mul'>
a.args
(2, x)
a.func(</em>a.args)
2<em>x
a == a.func(</em>a.args)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">is_algebraic</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_antihermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_commutative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_complex</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_composite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_even</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_finite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_hermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_imaginary</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_infinite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_irrational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_noninteger</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_odd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_polar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_prime</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_transcendental</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_zero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">kind</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Extended name, suitable for rendering.</p>
<p>This attempts to create a unique name by tying the parameter to a step
if the user has not explicitly provided a name, ideally the one where
we discovered it.</p>
<h4 id="methods_6">Methods</h4>
<h4 id="adjoint_2">adjoint</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">adjoint</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="apart_2">apart</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apart</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the apart function in sympy.polys</p>
<h4 id="args_cnc_2">args_cnc</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">args_cnc</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">split_1</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Return [commutative factors, non-commutative factors] of self.</p>
<h1 id="explanation_12">Explanation</h1>
<p>self is treated as a Mul and the ordering of the factors is maintained.
If <code>cset</code> is True the commutative factors will be returned in a set.
If there were repeated factors (as may happen with an unevaluated Mul)
then an error will be raised unless it is explicitly suppressed by
setting <code>warn</code> to False.</p>
<p>Note: -1 is always separated from a Number unless split_1 is False.</p>
<h1 id="examples_92">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, oo
A, B = symbols('A B', commutative=0)
x, y = symbols('x y')
(-2<em>x</em>y).args_cnc()
[[-1, 2, x, y], []]
(-2.5<em>x).args_cnc()
[[-1, 2.5, x], []]
(-2</em>x<em>A</em>B<em>y).args_cnc()
[[-1, 2, x, y], [A, B]]
(-2</em>x<em>A</em>B<em>y).args_cnc(split_1=False)
[[-2, x, y], [A, B]]
(-2</em>x*y).args_cnc(cset=True)
[{-1, 2, x, y}, []]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The arg is always treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-2 + x + A).args_cnc()
[[], [x - 2 + A]]
(-oo).args_cnc() # -oo is a singleton
[[-1, oo], []]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_base_exp_2">as_base_exp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_base_exp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<h4 id="as_coeff_add_4">as_coeff_Add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a summation.</p>
<h4 id="as_coeff_mul_4">as_coeff_Mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a product.</p>
<h4 id="as_coeff_add_5">as_coeff_add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as an Add, <code>a</code>.</p>
<p>c should be a Rational added to any terms of the Add that are
independent of deps.</p>
<p>args should be a tuple of all other terms of <code>a</code>; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is an Add or not but
you want to treat self as an Add or if you want to process the
individual arguments of the tail of self as an Add.</p>
<ul>
<li>if you know self is an Add and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail.</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_add()
(3, ())
(3 + x).as_coeff_add()
(3, (x,))
(3 + x + y).as_coeff_add(x)
(y + 3, (x,))
(3 + y).as_coeff_add(x)
(y + 3, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coeff_exponent_2">as_coeff_exponent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_exponent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p><code>c*x**e -&gt; c,e</code> where x can be any symbolic expression.</p>
<h4 id="as_coeff_mul_5">as_coeff_mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as a Mul, <code>m</code>.</p>
<p>c should be a Rational multiplied by any factors of the Mul that are
independent of deps.</p>
<p>args should be a tuple of all other factors of m; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is a Mul or not but
you want to treat self as a Mul or if you want to process the
individual arguments of the tail of self as a Mul.</p>
<ul>
<li>if you know self is a Mul and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail;</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_mul()
(3, ())
(3<em>x</em>y).as_coeff_mul()
(3, (x, y))
(3<em>x</em>y).as_coeff_mul(x)
(3<em>y, (x,))
(3</em>y).as_coeff_mul(x)
(3*y, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coefficient_2">as_coefficient</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Extracts symbolic coefficient at the given expression. In</p>
<p>other words, this functions separates 'self' into the product
of 'expr' and 'expr'-free coefficient. If such separation
is not possible it will return None.</p>
<h1 id="examples_93">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import E, pi, sin, I, Poly
from sympy.abc import x</p>
<p>E.as_coefficient(E)
1
(2<em>E).as_coefficient(E)
2
(2</em>sin(E)*E).as_coefficient(E)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two terms have E in them so a sum is returned. (If one were
desiring the coefficient of the term exactly matching E then
the constant from the returned expression could be selected.
Or, for greater precision, a method of Poly can be used to
indicate the desired term from which the coefficient is
desired.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E + x</em>E).as_coefficient(E)
x + 2
_.args[0]  # just want the exact match
2
p = Poly(2<em>E + x</em>E); p
Poly(x<em>E + 2</em>E, x, E, domain='ZZ')
p.coeff_monomial(E)
2
p.nth(0, 1)
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since the following cannot be written as a product containing
E as a factor, None is returned. (If the coefficient <code>2*x</code> is
desired then the <code>coeff</code> method should be used.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E</em>x + x).as_coefficient(E)
(2<em>E</em>x + x).coeff(E)
2*x</p>
<p>(E*(x + 1) + x).as_coefficient(E)</p>
<p>(2<em>pi</em>I).as_coefficient(pi<em>I)
2
(2</em>I).as_coefficient(pi*I)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_28">See Also</h1>
<p>coeff: return sum of terms have a given factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="as_coefficients_dict_2">as_coefficients_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficients_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a dictionary mapping terms to their Rational coefficient.</p>
<p>Since the dictionary is a defaultdict, inquiries about terms which
were not present will return a coefficient of 0.</p>
<p>If symbols <code>syms</code> are provided, any multiplicative terms
independent of them will be considered a coefficient and a
regular dictionary of syms-dependent generators as keys and
their corresponding coefficients as values will be returned.</p>
<h1 id="examples_94">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import a, x, y
(3<em>x + a</em>x + 4).as_coefficients_dict()
{1: 4, x: 3, a<em>x: 1}
_[a]
0
(3</em>a<em>x).as_coefficients_dict()
{a</em>x: 3}
(3<em>a</em>x).as_coefficients_dict(x)
{x: 3<em>a}
(3</em>a<em>x).as_coefficients_dict(y)
{1: 3</em>a*x}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_content_primitive_2">as_content_primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_content_primitive</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">radical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">clear</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>This method should recursively remove a Rational from all arguments</p>
<p>and return that (content) and the new self (primitive). The content
should always be positive and <code>Mul(*foo.as_content_primitive()) == foo</code>.
The primitive need not be in canonical form and should try to preserve
the underlying structure if possible (i.e. expand_mul should not be
applied to self).</p>
<h1 id="examples_95">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt
from sympy.abc import x, y, z</p>
<p>eq = 2 + 2<em>x + 2</em>y<em>(3 + 3</em>y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The as_content_primitive function is recursive and retains structure:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eq.as_content_primitive()
(2, x + 3<em>y</em>(y + 1) + 1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Integer powers will have Rationals extracted from the base:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((2 + 6<em>x)</em><em>2).as_content_primitive()
(4, (3</em>x + 1)<strong>2)
((2 + 6*x)</strong>(2<em>y)).as_content_primitive()
(1, (2</em>(3<em>x + 1))</em><em>(2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Terms may end up joining once their as_content_primitives are added:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((5<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(11, x</em>(y + 1))
((3<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(9, x</em>(y + 1))
((3<em>(z</em>(1 + y)) + 2.0<em>x</em>(3 + 3<em>y))).as_content_primitive()
(1, 6.0</em>x<em>(y + 1) + 3</em>z<em>(y + 1))
((5</em>(x<em>(1 + y)) + 2</em>x<em>(3 + 3</em>y))<strong>2).as_content_primitive()
(121, x</strong>2<em>(y + 1)</em><em>2)
((x</em>(1 + y) + 0.4<em>x</em>(3 + 3<em>y))</em><em>2).as_content_primitive()
(1, 4.84</em>x<strong>2*(y + 1)</strong>2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Radical content can also be factored out of the primitive:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>sqrt(2) + 4</em>sqrt(10)).as_content_primitive(radical=True)
(2, sqrt(2)<em>(1 + 2</em>sqrt(5)))</p>
</blockquote>
</blockquote>
</blockquote>
<p>If clear=False (default is True) then content will not be removed
from an Add if it can be distributed to leave one or more
terms with integer coefficients.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/2 + y).as_content_primitive()
(1/2, x + 2*y)
(x/2 + y).as_content_primitive(clear=False)
(1, x/2 + y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_dummy_2">as_dummy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_dummy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression with any objects having structurally</p>
<p>bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<h1 id="examples_96">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Symbol
from sympy.abc import x
r = Symbol('r', real=True)
Integral(r, (r, x)).as_dummy()
Integral(<em>0, (_0, x))
</em>.variables[0].is_real is None
True
r.as_dummy()
_r</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_13">Notes</h1>
<p>Any object that has structurally bound variables should have
a property, <code>bound_symbols</code> that returns those symbols
appearing in the object.</p>
<h4 id="as_expr_2">as_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span>
<span class="p">)</span>
</code></pre></div>
<p>Convert a polynomial to a SymPy expression.</p>
<h1 id="examples_97">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>f = (x<strong>2 + x*y).as_poly(x, y)
f.as_expr()
x</strong>2 + x*y</p>
<p>sin(x).as_expr()
sin(x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_independent_2">as_independent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_independent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hint</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>A mostly naive separation of a Mul or Add into arguments that are not</p>
<p>are dependent on deps. To obtain as complete a separation of variables
as possible, use a separation method first, e.g.:</p>
<ul>
<li>separatevars() to change Mul, Add and Pow (including exp) into Mul</li>
<li>.expand(mul=True) to change Add or Mul into Add</li>
<li>.expand(log=True) to change log expr into an Add</li>
</ul>
<p>The only non-naive thing that is done here is to respect noncommutative
ordering of variables and to always return (0, 0) for <code>self</code> of zero
regardless of hints.</p>
<p>For nonzero <code>self</code>, the returned tuple (i, d) has the
following interpretation:</p>
<ul>
<li>i will has no variable that appears in deps</li>
<li>d will either have terms that contain variables that are in deps, or
  be equal to 0 (when self is an Add) or 1 (when self is a Mul)</li>
<li>if self is an Add then self = i + d</li>
<li>if self is a Mul then self = i*d</li>
<li>otherwise (self, S.One) or (S.One, self) is returned.</li>
</ul>
<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>
<h1 id="examples_98">Examples</h1>
<p>-- self is an Add</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos, exp
from sympy.abc import x, y, z</p>
<p>(x + x<em>y).as_independent(x)
(0, x</em>y + x)
(x + x<em>y).as_independent(y)
(x, x</em>y)
(2<em>x</em>sin(x) + y + x + z).as_independent(x)
(y + z, 2<em>x</em>sin(x) + x)
(2<em>x</em>sin(x) + y + x + z).as_independent(x, y)
(z, 2<em>x</em>sin(x) + x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>sin(x)</em>cos(y)).as_independent(x)
(cos(y), x*sin(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>non-commutative terms cannot always be separated out when self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
(n1 + n1<em>n2).as_independent(n2)
(n1, n1</em>n2)
(n2<em>n1 + n1</em>n2).as_independent(n2)
(0, n1<em>n2 + n2</em>n1)
(n1<em>n2</em>n3).as_independent(n1)
(1, n1<em>n2</em>n3)
(n1<em>n2</em>n3).as_independent(n2)
(n1, n2<em>n3)
((x-n1)</em>(x-y)).as_independent(x)
(1, (x - y)*(x - n1))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is anything else:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(sin(x)).as_independent(x)
(1, sin(x))
(sin(x)).as_independent(y)
(sin(x), 1)
exp(x+y).as_independent(x)
(1, exp(x + y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as an Add:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3<em>x).as_independent(x, as_Add=True)
(0, 3</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3+x).as_independent(x, as_Add=False)
(1, x + 3)
(-3+x).as_independent(x, as_Add=False)
(1, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note how the below differs from the above in making the
constant on the dep term positive.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(y*(-3+x)).as_independent(x)
(y, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- use .as_independent() for true independence testing instead
   of .has(). The former considers only symbols in the free
   symbols while the latter considers all symbols</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
I = Integral(x, (x, 1, 2))
I.has(x)
True
x in I.free_symbols
False
I.as_independent(x) == (I, 1)
True
(I + x).as_independent(x) == (I, x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note: when trying to get independent terms, a separation method
might need to be used first. In this case, it is important to keep
track of what you send to this routine so you know how to interpret
the returned values</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import separatevars, log
separatevars(exp(x+y)).as_independent(x)
(exp(y), exp(x))
(x + x<em>y).as_independent(y)
(x, x</em>y)
separatevars(x + x<em>y).as_independent(y)
(x, y + 1)
(x</em>(1 + y)).as_independent(y)
(x, y + 1)
(x<em>(1 + y)).expand(mul=True).as_independent(y)
(x, x</em>y)
a, b=symbols('a b', positive=True)
(log(a*b).expand(log=True)).as_independent(b)
(log(a), log(b))</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_29">See Also</h1>
<p>separatevars
expand_log
sympy.core.add.Add.as_two_terms
sympy.core.mul.Mul.as_two_terms
as_coeff_mul</p>
<h4 id="as_leading_term_2">as_leading_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_leading_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading (nonzero) term of the series expansion of self.</p>
<p>The _eval_as_leading_term routines are used to do this, and they must
always return a non-zero value.</p>
<h1 id="examples_99">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1 + x + x<strong>2).as_leading_term(x)
1
(1/x</strong>2 + x + x<strong>2).as_leading_term(x)
x</strong>(-2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_numer_denom_2">as_numer_denom</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_numer_denom</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>Return the numerator and the denominator of an expression.</p>
<p>expression -&gt; a/b -&gt; a, b</p>
<p>This is just a stub that should be defined by
an object's class methods to get anything else.</p>
<h1 id="see-also_30">See Also</h1>
<p>normal: return <code>a/b</code> instead of <code>(a, b)</code></p>
<h4 id="as_ordered_factors_2">as_ordered_factors</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_factors</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return list of ordered factors (if Mul) else [self].</p>
<h4 id="as_ordered_terms_2">as_ordered_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_terms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to an ordered list of terms.</p>
<h1 id="examples_100">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos
from sympy.abc import x</p>
<p>(sin(x)<strong>2*cos(x) + sin(x)</strong>2 + 1).as_ordered_terms()
[sin(x)<strong>2*cos(x), sin(x)</strong>2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_poly_2">as_poly</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_poly</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Converts <code>self</code> to a polynomial or returns <code>None</code>.</p>
<h1 id="explanation_13">Explanation</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>print((x<strong>2 + x*y).as_poly())
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x<strong>2 + x*y).as_poly(x, y))
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x**2 + sin(y)).as_poly(x, y))
None</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_powers_dict_2">as_powers_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_powers_dict</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self as a dictionary of factors with each factor being</p>
<p>treated as a power. The keys are the bases of the factors and the
values, the corresponding exponents. The resulting dictionary should
be used with caution if the expression is a Mul and contains non-
commutative factors since the order that they appeared will be lost in
the dictionary.</p>
<h1 id="see-also_31">See Also</h1>
<p>as_ordered_factors: An alternative for noncommutative applications,
                    returning an ordered list of factors.
args_cnc: Similar to as_ordered_factors, but guarantees separation
          of commutative and noncommutative factors.</p>
<h4 id="as_real_imag_2">as_real_imag</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_real_imag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Performs complex expansion on 'self' and returns a tuple</p>
<p>containing collected both real and imaginary parts. This
method cannot be confused with re() and im() functions,
which does not perform complex expansion at evaluation.</p>
<p>However it is possible to expand both re() and im()
functions and get exactly the same results as with
a single call to this function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, I</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>(x + y*I).as_real_imag()
(x, y)</p>
<p>from sympy.abc import z, w</p>
<p>(z + w*I).as_real_imag()
(re(z) - im(w), re(w) + im(z))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_set_2">as_set</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_set</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrites Boolean expression in terms of real sets.</p>
<h1 id="examples_101">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Eq, Or, And
x = Symbol('x', real=True)
Eq(x, 0).as_set()
{0}
(x &gt; 0).as_set()
Interval.open(0, oo)
And(-2 &lt; x, x &lt; 2).as_set()
Interval.open(-2, 2)
Or(x &lt; -2, 2 &lt; x).as_set()
Union(Interval.open(-oo, -2), Interval.open(2, oo))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_terms_2">as_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_terms</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to a list of terms. </p>
<h4 id="aseries_2">aseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">aseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">hir</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Asymptotic Series expansion of self.</p>
<p>This is equivalent to <code>self.series(x, oo, n)</code>.</p>
<h1 id="parameters_12">Parameters</h1>
<p>self : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>hir : Boolean
      Set this parameter to be True to produce hierarchical series.
      It stops the recursion at an early level and may provide nicer
      and more useful results.</p>
<p>bound : Value, Integer
        Use the <code>bound</code> parameter to give limit on rewriting
        coefficients in its normalised form.</p>
<h1 id="examples_102">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, exp
from sympy.abc import x</p>
<p>e = sin(1/x + exp(-x)) - sin(1/x)</p>
<p>e.aseries(x)
(1/(24<em>x</em><em>4) - 1/(2</em>x<strong>2) + 1 + O(x</strong>(-6), (x, oo)))*exp(-x)</p>
<p>e.aseries(x, n=3, hir=True)
-exp(-2<em>x)</em>sin(1/x)/2 + exp(-x)<em>cos(1/x) + O(exp(-3</em>x), (x, oo))</p>
<p>e = exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x)
exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x, bound=3) # doctest: +SKIP
exp(exp(x)/x<strong>2)<em>exp(exp(x)/x)</em>exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x</strong>2)*exp(exp(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).aseries(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_6">Returns</h1>
<p>Expr
    Asymptotic series expansion of the expression.</p>
<h1 id="notes_14">Notes</h1>
<p>This algorithm is directly induced from the limit computational algorithm provided by Gruntz.
It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first
to look for the most rapidly varying subexpression w of a given expression f and then expands f
in a series in w. Then same thing is recursively done on the leading coefficient
till we get constant coefficients.</p>
<p>If the most rapidly varying subexpression of a given expression f is f itself,
the algorithm tries to find a normalised representation of the mrv set and rewrites f
using this normalised representation.</p>
<p>If the expansion contains an order term, it will be either <code>O(x ** (-n))</code> or <code>O(w ** (-n))</code>
where <code>w</code> belongs to the most rapidly varying expression of <code>self</code>.</p>
<h1 id="references_4">References</h1>
<p>.. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series.
       In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993.
       pp. 239-244.
.. [2] Gruntz thesis - p90
.. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion</p>
<h1 id="see-also_32">See Also</h1>
<p>Expr.aseries: See the docstring of this function for complete details of this wrapper.</p>
<h4 id="atoms_2">atoms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">atoms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">types</span><span class="p">:</span> <span class="s1">&#39;Tbasic | type[Tbasic]&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;set[Basic] | set[Tbasic]&#39;</span>
</code></pre></div>
<p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and cannot
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<h1 id="examples_103">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import I, pi, sin
from sympy.abc import x, y
(1 + x + 2<em>sin(y + I</em>pi)).atoms()
{1, 2, I, pi, x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Number, NumberSymbol, Symbol
(1 + x + 2<em>sin(y + I</em>pi)).atoms(Symbol)
{x, y}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number)
{1, 2}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol)
{1, 2, pi}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol, I)
{1, 2, I, pi}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(x) # x is a Symbol
{x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Be careful to check your assumptions when using the implicit option
since <code>S(1).is_Integer = True</code> but <code>type(S(1))</code> is <code>One</code>, a special type
of SymPy atom, while <code>type(S(2))</code> is type <code>Integer</code> and will find all
integers in an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(1))
{1}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(2))
{1, 2}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
SymPy type (loaded in core/<strong>init</strong>.py) can be listed as an argument
and those types of "atoms" as found in scanning the arguments of the
expression recursively:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function, Mul
from sympy.core.function import AppliedUndef
f = Function('f')
(1 + f(x) + 2<em>sin(y + I</em>pi)).atoms(Function)
{f(x), sin(y + I<em>pi)}
(1 + f(x) + 2</em>sin(y + I*pi)).atoms(AppliedUndef)
{f(x)}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Mul)
{I<em>pi, 2</em>sin(y + I*pi)}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="cancel_2">cancel</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cancel</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the cancel function in sympy.polys</p>
<h4 id="coeff_2">coeff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">coeff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">_first</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the coefficient from the term(s) containing <code>x**n</code>. If <code>n</code></p>
<p>is zero then all terms independent of <code>x</code> will be returned.</p>
<h1 id="explanation_14">Explanation</h1>
<p>When <code>x</code> is noncommutative, the coefficient to the left (default) or
right of <code>x</code> can be returned. The keyword 'right' is ignored when
<code>x</code> is commutative.</p>
<h1 id="examples_104">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
from sympy.abc import x, y, z</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have an explicit negative in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x + 2<em>y).coeff(-1)
x
(x - 2</em>y).coeff(-1)
2*y</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms with no Rational coefficient:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + 2<em>y).coeff(1)
x
(3 + 2</em>x + 4<em>x</em>*2).coeff(1)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms independent of x by making n=0; in this case
expr.as_independent(x)[0] is returned (and 0 will be returned instead
of None):</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x, 0)
3
eq = ((x + 1)</strong>3).expand() + 1
eq
x<strong>3 + 3*x</strong>2 + 3*x + 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 2]
eq -= 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 0]</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have a numerical term in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x - 2<em>y).coeff(2)
-y
from sympy import sqrt
(x + sqrt(2)</em>x).coeff(sqrt(2))
x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The matching is exact:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x)
2
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>2)
4
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>3)
0
(z*(x + y)</strong>2).coeff((x + y)<strong>2)
z
(z*(x + y)</strong>2).coeff(x + y)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
from the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + z<em>(x + x</em>y)).coeff(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<p>If such factoring is desired, factor_terms can be used first:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import factor_terms
factor_terms(x + z<em>(x + x</em>y)).coeff(x)
z*(y + 1) + 1</p>
<p>n, m, o = symbols('n m o', commutative=False)
n.coeff(n)
1
(3<em>n).coeff(n)
3
(n</em>m + m<em>n</em>m).coeff(n) # = (1 + m)<em>n</em>m
1 + m
(n<em>m + m</em>n<em>m).coeff(n, right=True) # = (1 + m)</em>n*m
m</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is more than one possible coefficient 0 is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + m</em>n).coeff(n)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is only one possible coefficient, it is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + x</em>m<em>n).coeff(m</em>n)
x
(n<em>m + x</em>m<em>n).coeff(m</em>n, right=1)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_33">See Also</h1>
<p>as_coefficient: separate the expression into a coefficient and factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="collect_2">collect</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">syms</span><span class="p">,</span>
    <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">distribute_order_term</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the collect function in sympy.simplify</p>
<h4 id="combsimp_2">combsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">combsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the combsimp function in sympy.simplify</p>
<h4 id="compare_2">compare</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compare</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span>
<span class="p">)</span>
</code></pre></div>
<p>Return -1, 0, 1 if the object is less than, equal,</p>
<p>or greater than other in a canonical sense.
Non-Basic are always greater than Basic.
If both names of the classes being compared appear
in the <code>ordering_of_classes</code> then the ordering will
depend on the appearance of the names there.
If either does not appear in that list, then the
comparison is based on the class name.
If the names are the same then a comparison is made
on the length of the hashable content.
Items of the equal-lengthed contents are then
successively compared using the same rules. If there
is never a difference then 0 is returned.</p>
<h1 id="examples_105">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
x.compare(y)
-1
x.compare(x)
0
y.compare(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="conjugate_2">conjugate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">conjugate</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the complex conjugate of 'self'.</p>
<h4 id="copy_2">copy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="could_extract_minus_sign_2">could_extract_minus_sign</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">could_extract_minus_sign</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;bool&#39;</span>
</code></pre></div>
<p>Return True if self has -1 as a leading factor or has</p>
<p>more literal negative signs than positive signs in a sum,
otherwise False.</p>
<h1 id="examples_106">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = x - y
{i.could_extract_minus_sign() for i in (e, -e)}
{False, True}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Though the <code>y - x</code> is considered like <code>-(x - y)</code>, since it
is in a product without a leading factor of -1, the result is
false below:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*(y - x)).could_extract_minus_sign()
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>To put something in canonical form wrt to sign, use <code>signsimp</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import signsimp
signsimp(x<em>(y - x))
-x</em>(x - y)
_.could_extract_minus_sign()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="count_2">count</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span>
<span class="p">)</span>
</code></pre></div>
<p>Count the number of matching subexpressions.</p>
<h4 id="count_ops_2">count_ops</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_ops</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">visual</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for count_ops that returns the operation count.</p>
<h4 id="diff_2">diff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">diff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="dir_2">dir</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dir</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">cdir</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="doit_2">doit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">doit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate objects that are not evaluated by default like limits,</p>
<p>integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via 'hints'
or unless the 'deep' hint was set to 'False'.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
from sympy.abc import x</p>
<p>2<em>Integral(x, x)
2</em>Integral(x, x)</p>
<p>(2<em>Integral(x, x)).doit()
x</em>*2</p>
<p>(2<em>Integral(x, x)).doit(deep=False)
2</em>Integral(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="dummy_eq_2">dummy_eq</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dummy_eq</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">symbol</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compare two expressions and handle dummy symbols.</p>
<h1 id="examples_107">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Dummy
from sympy.abc import x, y</p>
<p>u = Dummy('u')</p>
<p>(u<strong>2 + 1).dummy_eq(x</strong>2 + 1)
True
(u<strong>2 + 1) == (x</strong>2 + 1)
False</p>
<p>(u<strong>2 + y).dummy_eq(x</strong>2 + y, x)
True
(u<strong>2 + y).dummy_eq(x</strong>2 + y, y)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="equals_2">equals</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">failing_expression</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self == other, False if it does not, or None. If</p>
<p>failing_expression is True then the expression which did not simplify
to a 0 will be returned instead of None.</p>
<h1 id="explanation_15">Explanation</h1>
<p>If <code>self</code> is a Number (or complex number) that is not zero, then
the result is False.</p>
<p>If <code>self</code> is a number and has not evaluated to zero, evalf will be
used to test whether the expression evaluates to zero. If it does so
and the result has significance (i.e. the precision is either -1, for
a Rational result, or is greater than 1) then the evalf value will be
used to return True or False.</p>
<h4 id="evalf_2">evalf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">evalf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_13">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_15">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="expand_2">expand</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">modulus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">power_base</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">power_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">multinomial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Expand an expression using hints.</p>
<p>See the docstring of the expand() function in sympy.core.function for
more information.</p>
<h4 id="extract_additively_2">extract_additively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_additively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self - c if it's possible to subtract c from self and</p>
<p>make all matching coefficients move towards zero, else return None.</p>
<h1 id="examples_108">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = 2<em>x + 3
e.extract_additively(x + 1)
x + 2
e.extract_additively(3</em>x)
e.extract_additively(4)
(y<em>(x + 1)).extract_additively(x + 1)
((x + 1)</em>(x + 2<em>y + 1) + 3).extract_additively(x + 1)
(x + 1)</em>(x + 2*y) + 3</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_34">See Also</h1>
<p>extract_multiplicatively
coeff
as_coefficient</p>
<h4 id="extract_branch_factor_2">extract_branch_factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_branch_factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">allow_half</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Try to write self as <code>exp_polar(2*pi*I*n)*z</code> in a nice way.</p>
<p>Return (z, n).</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp_polar, I, pi
from sympy.abc import x, y
exp_polar(I<em>pi).extract_branch_factor()
(exp_polar(I</em>pi), 0)
exp_polar(2<em>I</em>pi).extract_branch_factor()
(1, 1)
exp_polar(-pi<em>I).extract_branch_factor()
(exp_polar(I</em>pi), -1)
exp_polar(3<em>pi</em>I + x).extract_branch_factor()
(exp_polar(x + I<em>pi), 1)
(y</em>exp_polar(-5<em>pi</em>I)<em>exp_polar(3</em>pi<em>I + 2</em>pi<em>x)).extract_branch_factor()
(y</em>exp_polar(2<em>pi</em>x), -1)
exp_polar(-I<em>pi/2).extract_branch_factor()
(exp_polar(-I</em>pi/2), 0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If allow_half is True, also extract exp_polar(I*pi):</p>
<blockquote>
<blockquote>
<blockquote>
<p>exp_polar(I<em>pi).extract_branch_factor(allow_half=True)
(1, 1/2)
exp_polar(2</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 1)
exp_polar(3</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 3/2)
exp_polar(-I</em>pi).extract_branch_factor(allow_half=True)
(1, -1/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="extract_multiplicatively_2">extract_multiplicatively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_multiplicatively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Return None if it's not possible to make self in the form</p>
<p>c * something in a nice way, i.e. preserving the properties
of arguments of self.</p>
<h1 id="examples_109">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Rational</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em><em>2 * y)
x</em>y**2</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em>*4 * y)</p>
<p>(2*x).extract_multiplicatively(2)
x</p>
<p>(2*x).extract_multiplicatively(3)</p>
<p>(Rational(1, 2)*x).extract_multiplicatively(3)
x/6</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="factor_2">factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the factor() function in sympy.polys.polytools</p>
<h4 id="find_2">find</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Find all subexpressions matching a query.</p>
<h4 id="fourier_series_2">fourier_series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fourier_series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">limits</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute fourier sine/cosine series of self.</p>
<p>See the docstring of the :func:<code>fourier_series</code> in sympy.series.fourier
for more information.</p>
<h4 id="fps_2">fps</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fps</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">hyper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute formal power power series of self.</p>
<p>See the docstring of the :func:<code>fps</code> function in sympy.series.formal for
more information.</p>
<h4 id="gammasimp_2">gammasimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gammasimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the gammasimp function in sympy.simplify</p>
<h4 id="geto_2">getO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Returns the additive O(..) symbol if there is one, else None.</p>
<h4 id="getn_2">getn</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getn</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the order of the expression.</p>
<h1 id="explanation_16">Explanation</h1>
<p>The order is determined either from the O(...) term. If there
is no O(...) term, it returns None.</p>
<h1 id="examples_110">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import O
from sympy.abc import x
(1 + x + O(x**2)).getn()
2
(1 + x).getn()</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_2">has</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether any subexpression matches any of the patterns.</p>
<h1 id="examples_111">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y, z
(x<strong>2 + sin(x*y)).has(z)
False
(x</strong>2 + sin(x*y)).has(x, y, z)
True
x.has(x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note <code>has</code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Interval
i = Interval.Lopen(0, 5); i
Interval.Lopen(0, 5)
i.args
(0, 5, True, False)
i.has(4)  # there is no "4" in the arguments
False
i.has(0)  # there <em>is</em> a "0" in the arguments
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Instead, use <code>contains</code> to determine whether a number is in the
interval or not:</p>
<blockquote>
<blockquote>
<blockquote>
<p>i.contains(4)
True
i.contains(0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that <code>expr.has(*patterns)</code> is exactly equivalent to
<code>any(expr.has(p) for p in patterns)</code>. In particular, <code>False</code> is
returned when the list of patterns is empty.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x.has()
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_free_2">has_free</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_free</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has object(s) <code>x</code> as a free expression</p>
<p>else False.</p>
<h1 id="examples_112">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Function
from sympy.abc import x, y
f = Function('f')
g = Function('g')
expr = Integral(f(x), (f(x), 1, g(y)))
expr.free_symbols
{y}
expr.has_free(g(y))
True
expr.has_free(*(x, f(x)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This works for subexpressions and types, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.has_free(g)
True
(x + y + 1).has_free(y + 1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_xfree_2">has_xfree</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_xfree</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;set[Basic]&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has any of the patterns in s as a</p>
<p>free argument, else False. This is like <code>Basic.has_free</code>
but this will only report exact argument matches.</p>
<h1 id="examples_113">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
from sympy.abc import x, y
f = Function('f')
f(x).has_xfree({f})
False
f(x).has_xfree({f(x)})
True
f(x + 1).has_xfree({x})
True
f(x + 1).has_xfree({x + 1})
True
f(x + y + 1).has_xfree({x + 1})
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="integrate_2">integrate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">integrate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the integrate function in sympy.integrals</p>
<h4 id="invert_2">invert</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">g</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the multiplicative inverse of <code>self</code> mod <code>g</code></p>
<p>where <code>self</code> (and <code>g</code>) may be symbolic expressions).</p>
<h1 id="see-also_35">See Also</h1>
<p>sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert</p>
<h4 id="is_algebraic_expr_2">is_algebraic_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_algebraic_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether a given expression is algebraic or not, in the</p>
<p>given symbols, syms. When syms is not given, all free symbols
will be used. The rational function does not have to be in expanded
or in any kind of canonical form.</p>
<p>This function returns False for expressions that are "algebraic
expressions" with symbolic exponents. This is a simple extension to the
is_rational_function, including rational exponentiation.</p>
<h1 id="examples_114">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sqrt
x = Symbol('x', real=True)
sqrt(1 + x).is_rational_function()
False
sqrt(1 + x).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be an algebraic
expression to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp, factor
a = sqrt(exp(x)*<em>2 + 2</em>exp(x) + 1)/(exp(x) + 1)
a.is_algebraic_expr(x)
False
factor(a).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_36">See Also</h1>
<p>is_rational_function</p>
<h1 id="references_5">References</h1>
<p>.. [1] https://en.wikipedia.org/wiki/Algebraic_expression</p>
<h4 id="is_constant_2">is_constant</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">wrt</span><span class="p">,</span>
    <span class="o">**</span><span class="n">flags</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is constant, False if not, or None if</p>
<p>the constancy could not be determined conclusively.</p>
<h1 id="explanation_17">Explanation</h1>
<p>If an expression has no free symbols then it is a constant. If
there are free symbols it is possible that the expression is a
constant, perhaps (but not necessarily) zero. To test such
expressions, a few strategies are tried:</p>
<p>1) numerical evaluation at two random points. If two such evaluations
give two different values and the values have a precision greater than
1 then self is not constant. If the evaluations agree or could not be
obtained with any precision, no decision is made. The numerical testing
is done only if <code>wrt</code> is different than the free symbols.</p>
<p>2) differentiation with respect to variables in 'wrt' (or all free
symbols if omitted) to see if the expression is constant or not. This
will not always lead to an expression that is zero even though an
expression is constant (see added test in test_expr.py). If
all derivatives are zero then self is constant with respect to the
given symbols.</p>
<p>3) finding out zeros of denominator expression with free_symbols.
It will not be constant if there are zeros. It gives more negative
answers for expression that are not constant.</p>
<p>If neither evaluation nor differentiation can prove the expression is
constant, None is returned unless two numerical values happened to be
the same and the flag <code>failing_number</code> is True -- in that case the
numerical value will be returned.</p>
<p>If flag simplify=False is passed, self will not be simplified;
the default is True since self should be simplified before testing.</p>
<h1 id="examples_115">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, Sum, S, pi
from sympy.abc import a, n, x, y
x.is_constant()
False
S(2).is_constant()
True
Sum(x, (x, 1, 10)).is_constant()
True
Sum(x, (x, 1, n)).is_constant()
False
Sum(x, (x, 1, n)).is_constant(y)
True
Sum(x, (x, 1, n)).is_constant(n)
False
Sum(x, (x, 1, n)).is_constant(x)
True
eq = a<em>cos(x)</em><em>2 + a</em>sin(x)**2 - a
eq.is_constant()
True
eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
True</p>
<p>(0<strong>x).is_constant()
False
x.is_constant()
False
(x</strong>x).is_constant()
False
one = cos(x)<strong>2 + sin(x)</strong>2
one.is_constant()
True
((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_hypergeometric_2">is_hypergeometric</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_hypergeometric</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">k</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="is_meromorphic_2">is_meromorphic</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_meromorphic</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">a</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether an expression is meromorphic as</p>
<p>a function of the given symbol <code>x</code> at the point <code>a</code>.</p>
<p>This method is intended as a quick test that will return
None if no decision can be made without simplification or
more detailed analysis.</p>
<h1 id="examples_116">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import zoo, log, sin, sqrt
from sympy.abc import x</p>
<p>f = 1/x<strong>2 + 1 - 2*x</strong>3
f.is_meromorphic(x, 0)
True
f.is_meromorphic(x, 1)
True
f.is_meromorphic(x, zoo)
True</p>
<p>g = x**log(3)
g.is_meromorphic(x, 0)
False
g.is_meromorphic(x, 1)
True
g.is_meromorphic(x, zoo)
False</p>
<p>h = sin(1/x)<em>x</em>*2
h.is_meromorphic(x, 0)
False
h.is_meromorphic(x, 1)
True
h.is_meromorphic(x, zoo)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multivalued functions are considered meromorphic when their
branches are meromorphic. Thus most functions are meromorphic
everywhere except at essential singularities and branch points.
In particular, they will be meromorphic also on branch cuts
except at their endpoints.</p>
<blockquote>
<blockquote>
<blockquote>
<p>log(x).is_meromorphic(x, -1)
True
log(x).is_meromorphic(x, 0)
False
sqrt(x).is_meromorphic(x, -1)
True
sqrt(x).is_meromorphic(x, 0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_polynomial_2">is_polynomial</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_polynomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is a polynomial in syms and False otherwise.</p>
<p>This checks if self is an exact polynomial in syms.  This function
returns False for expressions that are "polynomials" with symbolic
exponents.  Thus, you should be able to apply polynomial algorithms to
expressions for which this returns True, and Poly(expr, *syms) should
work if and only if expr.is_polynomial(*syms) returns True. The
polynomial does not have to be in expanded form.  If no symbols are
given, all free symbols in the expression will be used.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', polynomial=True).</p>
<h1 id="examples_117">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Function
x = Symbol('x')
((x<strong>2 + 1)</strong>4).is_polynomial(x)
True
((x<strong>2 + 1)</strong>4).is_polynomial()
True
(2<strong>x + 1).is_polynomial(x)
False
(2</strong>x + 1).is_polynomial(2**x)
True
f = Function('f')
(f(x) + 1).is_polynomial(x)
False
(f(x) + 1).is_polynomial(f(x))
True
(1/f(x) + 1).is_polynomial(f(x))
False</p>
<p>n = Symbol('n', nonnegative=True, integer=True)
(x**n + 1).is_polynomial(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a polynomial to
become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor, cancel
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)
a.is_polynomial(y)
False
factor(a)
y + 1
factor(a).is_polynomial(y)
True</p>
<p>b = (y*<em>2 + 2</em>y + 1)/(y + 1)
b.is_polynomial(y)
False
cancel(b)
y + 1
cancel(b).is_polynomial(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also .is_rational_function()</p>
<h4 id="is_rational_function_2">is_rational_function</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_rational_function</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether function is a ratio of two polynomials in the given</p>
<p>symbols, syms. When syms is not given, all free symbols will be used.
The rational function does not have to be in expanded or in any kind of
canonical form.</p>
<p>This function returns False for expressions that are "rational
functions" with symbolic exponents.  Thus, you should be able to call
.as_numer_denom() and apply polynomial algorithms to the result for
expressions for which this returns True.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', rational_function=True).</p>
<h1 id="examples_118">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sin
from sympy.abc import x, y</p>
<p>(x/y).is_rational_function()
True</p>
<p>(x**2).is_rational_function()
True</p>
<p>(x/sin(y)).is_rational_function(y)
False</p>
<p>n = Symbol('n', integer=True)
(x**n + 1).is_rational_function(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a rational function
to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)/y
a.is_rational_function(y)
False
factor(a)
(y + 1)/y
factor(a).is_rational_function(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also is_algebraic_expr().</p>
<h4 id="is_same_2">is_same</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_same</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span>
    <span class="n">b</span><span class="p">,</span>
    <span class="n">approx</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if a and b are structurally the same, else False.</p>
<p>If <code>approx</code> is supplied, it will be used to test whether two
numbers are the same or not. By default, only numbers of the
same type will compare equal, so S.Half != Float(0.5).</p>
<h1 id="examples_119">Examples</h1>
<p>In SymPy (unlike Python) two numbers do not compare the same if they are
not of the same type:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
2.0 == S(2)
False
0.5 == S.Half
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>By supplying a function with which to compare two numbers, such
differences can be ignored. e.g. <code>equal_valued</code> will return True
for decimal numbers having a denominator that is a power of 2,
regardless of precision.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Float
from sympy.core.numbers import equal_valued
(S.Half/4).is_same(Float(0.125, 1), equal_valued)
True
Float(1, 2).is_same(Float(1, 10), equal_valued)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>But decimals without a power of 2 denominator will compare
as not being the same.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Float(0.1, 9).is_same(Float(0.1, 10), equal_valued)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>But arbitrary differences can be ignored by supplying a function
to test the equivalence of two numbers:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import math
Float(0.1, 9).is_same(Float(0.1, 10), math.isclose)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Other objects might compare the same even though types are not the
same. This routine will only return True if two expressions are
identical in terms of class types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import eye, Basic
eye(1) == S(eye(1))  # mutable vs immutable
True
Basic.is_same(eye(1), S(eye(1)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="leadterm_2">leadterm</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">leadterm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading term a<em>x</em>*b as a tuple (a, b).</p>
<h1 id="examples_120">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1+x+x<strong>2).leadterm(x)
(1, 0)
(1/x</strong>2+x+x**2).leadterm(x)
(1, -2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="limit_2">limit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">limit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">xlim</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute limit x-&gt;xlim.</p>
<h4 id="lseries_2">lseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for series yielding an iterator of the terms of the series.</p>
<p>Note: an infinite series will yield an infinite iterator. The following,
for exaxmple, will never terminate. It will just keep printing terms
of the sin(x) series::</p>
<p>for term in sin(x).lseries(x):
      print term</p>
<p>The advantage of lseries() over nseries() is that many times you are
just interested in the next term in the series (i.e. the first term for
example), but you do not know how many you should ask for in nseries()
using the "n" parameter.</p>
<p>See also nseries().</p>
<h4 id="make_reference_3">make_reference</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_reference</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;&#39;ParameterReference[T]&#39;&quot;</span>
</code></pre></div>
<p>Creates a new reference for the parameter.</p>
<p>The kwargs will be passed to the constructor, but the</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>typ</td>
<td>None</td>
<td>type of the new reference's target.</td>
<td>None</td>
</tr>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>arguments to pass to the constructor.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="match_2">match</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code>None</code> when expression (self) does not match with pattern.
Otherwise return a dictionary such that::</p>
<p>pattern.xreplace(self.match(pattern)) == self</p>
<h1 id="examples_121">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Wild, Sum
from sympy.abc import x, y
p = Wild("p")
q = Wild("q")
r = Wild("r")
e = (x+y)<strong>(x+y)
e.match(p</strong>p)
{p_: x + y}
e.match(p<strong>q)
{p_: x + y, q_: x + y}
e = (2*x)</strong>2
e.match(p<em>q</em><em>r)
{p_: 4, q_: x, r_: 2}
(p</em>q<strong>r).xreplace(e.match(p*q</strong>r))
4<em>x</em>*2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since match is purely structural expressions that are equivalent up to
bound symbols will not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p))))
None</p>
</blockquote>
</blockquote>
</blockquote>
<p>An expression with bound symbols can be matched if the pattern uses
a distinct <code>Wild</code> for each bound symbol:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))
{p_: 2, q_: x}</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>old</code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the match. Both
of the following give None unless <code>old=True</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x - 2).match(p - x, old=True)
{p_: 2<em>x - 2}
(2/x).match(p</em>x, old=True)
{p_: 2/x**2}</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_37">See Also</h1>
<p>matches: pattern.matches(expr) is the same as expr.match(pattern)
xreplace: exact structural replacement
replace: structural replacement with pattern matching
Wild: symbolic placeholders for expressions in pattern matching</p>
<h4 id="matches_2">matches</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">matches</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">,</span>
    <span class="n">repl_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Helper method for match() that looks for a match between Wild symbols</p>
<p>in self and expressions in expr.</p>
<h1 id="examples_122">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Wild, Basic
a, b, c = symbols('a b c')
x = Wild('x')
Basic(a + x, x).matches(Basic(a + b, c)) is None
True
Basic(a + x, x).matches(Basic(a + b + c, b + c))
{x_: b + c}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="n_2">n</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_14">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_16">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="normal_2">normal</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">normal</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression as a fraction.</p>
<p>expression -&gt; a/b</p>
<h1 id="see-also_38">See Also</h1>
<p>as_numer_denom: return <code>(a, b)</code> instead of <code>a/b</code></p>
<h4 id="nseries_2">nseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>
<p>If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
called. This calculates "n" terms in the innermost expressions and
then builds up the final series just by "cross-multiplying" everything
out.</p>
<p>The optional <code>logx</code> parameter can be used to replace any log(x) in the
returned series with a symbolic value to avoid evaluating log(x) at 0. A
symbol to use in place of log(x) should be provided.</p>
<p>Advantage -- it's fast, because we do not have to determine how many
terms we need to calculate in advance.</p>
<p>Disadvantage -- you may end up with less terms than you may have
expected, but the O(x**n) term appended will always be correct and
so the result, though perhaps shorter, will also be correct.</p>
<p>If any of those assumptions is not met, this is treated like a
wrapper to series which will try harder to return the correct
number of terms.</p>
<p>See also lseries().</p>
<h1 id="examples_123">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, log, Symbol
from sympy.abc import x, y
sin(x).nseries(x, 0, 6)
x - x<strong>3/6 + x</strong>5/120 + O(x<strong>6)
log(x+1).nseries(x, 0, 5)
x - x</strong>2/2 + x<strong>3/3 - x</strong>4/4 + O(x**5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Handling of the <code>logx</code> parameter --- in the following example the
expansion fails since <code>sin</code> does not have an asymptotic expansion
at -oo (the limit of log(x) as x approaches 0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = sin(log(x))
e.nseries(x, 0, 6)
Traceback (most recent call last):
...
PoleError: ...
...
logx = Symbol('logx')
e.nseries(x, 0, 6, logx=logx)
sin(logx)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the following example, the expansion works but only returns self
unless the <code>logx</code> parameter is used:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>y
e.nseries(x, 0, 2)
x</strong>y
e.nseries(x, 0, 2, logx=logx)
exp(logx*y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="nsimplify_2">nsimplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nsimplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">constants</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the nsimplify function in sympy.simplify</p>
<h4 id="powsimp_2">powsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">powsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the powsimp function in sympy.simplify</p>
<h4 id="primitive_2">primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">primitive</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Number, Expr]&#39;</span>
</code></pre></div>
<p>Return the positive Rational that can be extracted non-recursively</p>
<p>from every term of self (i.e., self is treated like an Add). This is
like the as_coeff_Mul() method but primitive always extracts a positive
Rational (never a negative or a Float).</p>
<h1 id="examples_124">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(3<em>(x + 1)</em><em>2).primitive()
(3, (x + 1)</em><em>2)
a = (6</em>x + 2); a.primitive()
(2, 3<em>x + 1)
b = (x/2 + 3); b.primitive()
(1/2, x + 6)
(a</em>b).primitive() == (1, a*b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="radsimp_2">radsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">radsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the radsimp function in sympy.simplify</p>
<h4 id="ratsimp_2">ratsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">ratsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the ratsimp function in sympy.simplify</p>
<h4 id="rcall_2">rcall</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rcall</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance, in SymPy the following will not work:</p>
<p><code>(x+Lambda(y, 2*y))(z) == x+2*z</code>,</p>
<p>however, you can use:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x, y, z
(x + Lambda(y, 2<em>y)).rcall(z)
x + 2</em>z</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="refine_2">refine</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">refine</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">assumption</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the refine function in sympy.assumptions</p>
<h4 id="register_caller">register_caller</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">register_caller</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">caller</span><span class="p">:</span> <span class="s1">&#39;BaseStep&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;None&#39;</span>
</code></pre></div>
<p>Capture a step that uses this parameter.</p>
<p>Gathers together the steps using this parameter. The first found will
be recorded as the tethered step, and used for forming the name.</p>
<h4 id="removeo_2">removeO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">removeO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr&#39;</span>
</code></pre></div>
<p>Removes the additive O(..) symbol if there is one</p>
<h4 id="replace_2">replace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="nb">map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Replace matching subexpressions of <code>self</code> with <code>value</code>.</p>
<p>If <code>map = True</code> then also return the mapping {old: new} where <code>old</code>
was a sub-expression found with query and <code>new</code> is the replacement
value for it. If the expression itself does not match the query, then
the returned value will be <code>self.xreplace(map)</code> otherwise it should
be <code>self.subs(ordered(map.items()))</code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code>simultaneous</code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code>exact</code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<h1 id="examples_125">Examples</h1>
<p>Initial setup</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import log, sin, cos, tan, Wild, Mul, Add
from sympy.abc import x, y
f = log(sin(x)) + tan(sin(x**2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>1.1. type -&gt; type
    obj.replace(type, newtype)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, replace it with the
result of passing its argument(s) to ``newtype``.

&gt;&gt;&gt; f.replace(sin, cos)
log(cos(x)) + tan(cos(x**2))
&gt;&gt;&gt; sin(x).replace(sin, cos, map=True)
(cos(x), {sin(x): cos(x)})
&gt;&gt;&gt; (x*y).replace(Mul, Add)
x + y
</code></pre></div>
<p>1.2. type -&gt; func
    obj.replace(type, func)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, apply ``func`` to its
argument(s). ``func`` must be written to handle the number
of arguments of ``type``.

&gt;&gt;&gt; f.replace(sin, lambda arg: sin(2*arg))
log(sin(2*x)) + tan(sin(2*x**2))
&gt;&gt;&gt; (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))
sin(2*x*y)
</code></pre></div>
<p>2.1. pattern -&gt; expr
    obj.replace(pattern(wild), expr(wild))</p>
<div class="highlight"><pre><span></span><code>Replace subexpressions matching ``pattern`` with the expression
written in terms of the Wild symbols in ``pattern``.

&gt;&gt;&gt; a, b = map(Wild, &#39;ab&#39;)
&gt;&gt;&gt; f.replace(sin(a), tan(a))
log(tan(x)) + tan(tan(x**2))
&gt;&gt;&gt; f.replace(sin(a), tan(a/2))
log(tan(x/2)) + tan(tan(x**2/2))
&gt;&gt;&gt; f.replace(sin(a), a)
log(x) + tan(x**2)
&gt;&gt;&gt; (x*y).replace(a*x, a)
y

Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:

&gt;&gt;&gt; (2*x + y).replace(a*x + b, b - a)
y - 2
&gt;&gt;&gt; (2*x).replace(a*x + b, b - a)
2*x

When set to False, the results may be non-intuitive:

&gt;&gt;&gt; (2*x).replace(a*x + b, b - a, exact=False)
2/x
</code></pre></div>
<p>2.2. pattern -&gt; func
    obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<div class="highlight"><pre><span></span><code>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:

&gt;&gt;&gt; f.replace(sin(a), lambda a: sin(2*a))
log(sin(2*x)) + tan(sin(2*x**2))
</code></pre></div>
<p>3.1. func -&gt; func
    obj.replace(filter, func)</p>
<div class="highlight"><pre><span></span><code>Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``
is True.

&gt;&gt;&gt; g = 2*sin(x**3)
&gt;&gt;&gt; g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)
4*sin(x**9)
</code></pre></div>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; e = x*(x*y + 1)
&gt;&gt;&gt; e.replace(lambda x: x.is_Mul, lambda x: 2*x)
2*x*(2*x*y + 1)
</code></pre></div>
<p>When matching a single symbol, <code>exact</code> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <code>exact=False</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
f = Function('f')
e = f(1) + f(0)
q = f(a), lambda a: f(a + 1)
e.replace(<em>q, exact=False)
f(1) + f(2)
e.replace(</em>q, exact=True)
f(0) + f(2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>(1 + y)
(x</strong>(1 + y)).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=False)
x
(x<strong>(1 + y)).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=True)
x</strong>(-x - y + 1)
(x<strong>y).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=False)
x
(x</strong>y).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=True)
x**(1 - y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x<strong>(1 + y)).replace(
... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,
... lambda x: x.base</strong>(1 - (x.exp - 1)))
...
x**(1 - y) + 1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_39">See Also</h1>
<p>subs: substitution of subexpressions as defined by the objects
      themselves.
xreplace: exact node replacement in expr tree; also capable of
          using matching rules</p>
<h4 id="rewrite_2">rewrite</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rewrite</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrite <em>self</em> using a defined rule.</p>
<p>Rewriting transforms an expression to another, which is mathematically
equivalent but structurally different. For example you can rewrite
trigonometric functions as complex exponentials or combinatorial
functions as gamma function.</p>
<p>This method takes a <em>pattern</em> and a <em>rule</em> as positional arguments.
<em>pattern</em> is optional parameter which defines the types of expressions
that will be transformed. If it is not passed, all possible expressions
will be rewritten. <em>rule</em> defines how the expression will be rewritten.</p>
<h1 id="parameters_15">Parameters</h1>
<p>args : Expr
    A <em>rule</em>, or <em>pattern</em> and <em>rule</em>.
    - <em>pattern</em> is a type or an iterable of types.
    - <em>rule</em> can be any object.</p>
<p>deep : bool, optional
    If <code>True</code>, subexpressions are recursively transformed. Default is
    <code>True</code>.</p>
<h1 id="examples_126">Examples</h1>
<p>If <em>pattern</em> is unspecified, all possible expressions are transformed.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, exp, I
from sympy.abc import x
expr = cos(x) + I<em>sin(x)
expr.rewrite(exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Pattern can be a type or an iterable of types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.rewrite(sin, exp)
exp(I<em>x)/2 + cos(x) - exp(-I</em>x)/2
expr.rewrite([cos,], exp)
exp(I<em>x)/2 + I</em>sin(x) + exp(-I<em>x)/2
expr.rewrite([cos, sin], exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Rewriting behavior can be implemented by defining <code>_eval_rewrite()</code>
method.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Expr, sqrt, pi
class MySin(Expr):
...     def _eval_rewrite(self, rule, args, <strong>hints):
...         x, = args
...         if rule == cos:
...             return cos(pi/2 - x, evaluate=False)
...         if rule == sqrt:
...             return sqrt(1 - cos(x)</strong>2)
MySin(MySin(x)).rewrite(cos)
cos(-cos(-x + pi/2) + pi/2)
MySin(x).rewrite(sqrt)
sqrt(1 - cos(x)**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Defining <code>_eval_rewrite_as_[...]()</code> method is supported for backwards
compatibility reason. This may be removed in the future and using it is
discouraged.</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MySin(Expr):
...     def _eval_rewrite_as_cos(self, <em>args, </em>*hints):
...         x, = args
...         return cos(pi/2 - x, evaluate=False)
MySin(x).rewrite(cos)
cos(-x + pi/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="round_2">round</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return x rounded to the given decimal place.</p>
<p>If a complex number would results, apply round to the real
and imaginary components of the number.</p>
<h1 id="examples_127">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, E, I, S, Number
pi.round()
3
pi.round(2)
3.14
(2<em>pi + E</em>I).round()
6 + 3*I</p>
</blockquote>
</blockquote>
</blockquote>
<p>The round method has a chopping effect:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>pi + I/10).round()
6
(pi/10 + 2</em>I).round()
2<em>I
(pi/10 + E</em>I).round(2)
0.31 + 2.72*I</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_17">Notes</h1>
<p>The Python <code>round</code> function uses the SymPy <code>round</code> method so it
will always return a SymPy number (not a Python float or int):</p>
<blockquote>
<blockquote>
<blockquote>
<p>isinstance(round(S(123), -2), Number)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="separate_2">separate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">separate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">force</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the separate function in sympy.simplify</p>
<h4 id="series_2">series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Series expansion of "self" around <code>x = x0</code> yielding either terms of</p>
<p>the series one by one (the lazy series given when n=None), else
all the terms at once when n != None.</p>
<p>Returns the series expansion of "self" around the point <code>x = x0</code>
with respect to <code>x</code> up to <code>O((x - x0)**n, x, x0)</code> (default n is 6).</p>
<p>If <code>x=None</code> and <code>self</code> is univariate, the univariate symbol will
be supplied, otherwise an error will be raised.</p>
<h1 id="parameters_16">Parameters</h1>
<p>expr : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>x0 : Value
     The value around which <code>x</code> is calculated. Can be any value
     from <code>-oo</code> to <code>oo</code>.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>dir : String, optional
      The series-expansion can be bi-directional. If <code>dir="+"</code>,
      then (x-&gt;x0+). If <code>dir="-", then (x-&gt;x0-). For infinite</code>x0<code>(</code>oo<code>or</code>-oo<code>), the</code>dir<code>argument is determined
      from the direction of the infinity (i.e.,</code>dir="-"<code>for</code>oo``).</p>
<p>logx : optional
       It is used to replace any log(x) in the returned series with a
       symbolic value rather than evaluating the actual value.</p>
<p>cdir : optional
       It stands for complex direction, and indicates the direction
       from which the expansion needs to be evaluated.</p>
<h1 id="examples_128">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, exp, tan
from sympy.abc import x, y
cos(x).series()
1 - x<strong>2/2 + x</strong>4/24 + O(x<strong>6)
cos(x).series(n=4)
1 - x</strong>2/2 + O(x<strong>4)
cos(x).series(x, x0=1, n=2)
cos(1) - (x - 1)*sin(1) + O((x - 1)</strong>2, (x, 1))
e = cos(x + exp(y))
e.series(y, n=2)
cos(x + 1) - y<em>sin(x + 1) + O(y</em><em>2)
e.series(x, n=2)
cos(exp(y)) - x</em>sin(exp(y)) + O(x**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>n=None</code> then a generator of the series terms will be returned.</p>
<blockquote>
<blockquote>
<blockquote>
<p>term=cos(x).series(n=None)
[next(term) for i in range(2)]
[1, -x**2/2]</p>
</blockquote>
</blockquote>
</blockquote>
<p>For <code>dir=+</code> (default) the series is calculated from the right and
for <code>dir=-</code> the series from the left. For smooth functions this
flag will not alter the results.</p>
<blockquote>
<blockquote>
<blockquote>
<p>abs(x).series(dir="+")
x
abs(x).series(dir="-")
-x
f = tan(x)
f.series(x, 2, 6, "+")
tan(2) + (1 + tan(2)<strong>2)*(x - 2) + (x - 2)</strong>2<em>(tan(2)</em><em>3 + tan(2)) +
(x - 2)</em><em>3</em>(1/3 + 4<em>tan(2)</em><em>2/3 + tan(2)</em><em>4) + (x - 2)</em><em>4</em>(tan(2)<strong>5 +
5*tan(2)</strong>3/3 + 2<em>tan(2)/3) + (x - 2)</em><em>5</em>(2/15 + 17<em>tan(2)</em><em>2/15 +
2</em>tan(2)<strong>4 + tan(2)</strong>6) + O((x - 2)**6, (x, 2))</p>
<p>f.series(x, 2, 3, "-")
tan(2) + (2 - x)<em>(-tan(2)</em><em>2 - 1) + (2 - x)</em><em>2</em>(tan(2)<strong>3 + tan(2))
+ O((x - 2)</strong>3, (x, 2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).series(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_7">Returns</h1>
<p>Expr : Expression
    Series expansion of the expression about x0</p>
<h1 id="raises_2">Raises</h1>
<p>TypeError
    If "n" and "x0" are infinity objects</p>
<p>PoleError
    If "x0" is an infinity object</p>
<h4 id="simplify_2">simplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>See the simplify function in sympy.simplify</p>
<h4 id="sort_key_2">sort_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sort_key</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a sort key.</p>
<h1 id="examples_129">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S, I</p>
<p>sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())
[1/2, -I, I]</p>
<p>S("[x, 1/x, 1/x<strong>2, x</strong>2, x<strong>(1/2), x</strong>(1/4), x<strong>(3/2)]")
[x, 1/x, x</strong>(-2), x<strong>2, sqrt(x), x</strong>(1/4), x<strong>(3/2)]
sorted(_, key=lambda x: x.sort_key())
[x</strong>(-2), 1/x, x<strong>(1/4), sqrt(x), x, x</strong>(3/2), x**2]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="subs_2">subs</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">subs</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">arg1</span><span class="p">:</span> <span class="s1">&#39;Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex&#39;</span><span class="p">,</span>
    <span class="n">arg2</span><span class="p">:</span> <span class="s1">&#39;Basic | complex | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Substitutes old for new in an expression after sympifying args.</p>
<p><code>args</code> is either:
  - two arguments, e.g. foo.subs(old, new)
  - one iterable argument, e.g. foo.subs(iterable). The iterable may be
     o an iterable container with (old, new) pairs. In this case the
       replacements are processed in the order given with successive
       patterns possibly affecting replacements already made.
     o a dict or set whose key/value items correspond to old/new pairs.
       In this case the old/new pairs will be sorted by op count and in
       case of a tie, by number of args and the default_sort_key. The
       resulting sorted list is then processed as an iterable container
       (see previous).</p>
<p>If the keyword <code>simultaneous</code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<h1 id="examples_130">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, exp, limit, oo
from sympy.abc import x, y
(1 + x<em>y).subs(x, pi)
pi</em>y + 1
(1 + x<em>y).subs({x:pi, y:2})
1 + 2</em>pi
(1 + x<em>y).subs([(x, pi), (y, 2)])
1 + 2</em>pi
reps = [(y, x<strong>2), (x, 2)]
(x + y).subs(reps)
6
(x + y).subs(reversed(reps))
x</strong>2 + 2</p>
<p>(x<strong>2 + x</strong>4).subs(x<strong>2, y)
y</strong>2 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To replace only the x<strong>2 but not the x</strong>4, use xreplace:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<strong>2 + x</strong>4).xreplace({x<strong>2: y})
x</strong>4 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code>simultaneous</code> to True:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/y).subs([(x, 0), (y, 0)])
0
(x/y).subs([(x, 0), (y, 0)], simultaneous=True)
nan</p>
</blockquote>
</blockquote>
</blockquote>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((x + y)/y).subs({x + y: y, y: x + y})
1
((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
y/(x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, sin, cos
from sympy.abc import a, b, c, d, e</p>
<p>A = (sqrt(sin(2<em>x)), a)
B = (sin(2</em>x), b)
C = (cos(2*x), c)
D = (x, d)
E = (exp(x), e)</p>
<p>expr = sqrt(sin(2<em>x))</em>sin(exp(x)<em>x)</em>cos(2<em>x) + sin(2</em>x)</p>
<p>expr.subs(dict([A, B, C, D, E]))
a<em>c</em>sin(d*e) + b</p>
</blockquote>
</blockquote>
</blockquote>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*<em>3 - 3</em>x).subs({x: oo})
nan</p>
<p>limit(x*<em>3 - 3</em>x, x, oo)
oo</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).evalf(subs={x: 3.0}, n=21)
0.333333333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<p>rather than</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).subs({x: 3.0}).evalf(21)
0.333333333333333314830</p>
</blockquote>
</blockquote>
</blockquote>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
<h1 id="see-also_40">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
xreplace: exact node replacement in expr tree; also capable of
          using matching rules
sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision</p>
<h4 id="taylor_term_2">taylor_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">taylor_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="o">*</span><span class="n">previous_terms</span>
<span class="p">)</span>
</code></pre></div>
<p>General method for the taylor term.</p>
<p>This method is slow, because it differentiates n-times. Subclasses can
redefine it to make it faster by using the "previous_terms".</p>
<h4 id="to_nnf_2">to_nnf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_nnf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="together_2">together</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">together</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the together function in sympy.polys</p>
<h4 id="transpose_2">transpose</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="trigsimp_2">trigsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">trigsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the trigsimp function in sympy.simplify</p>
<h4 id="xreplace_2">xreplace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">xreplace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rule</span><span class="p">,</span>
    <span class="n">hack2</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Replace occurrences of objects within the expression.</p>
<h1 id="parameters_17">Parameters</h1>
<p>rule : dict-like
    Expresses a replacement rule</p>
<h1 id="returns_8">Returns</h1>
<p>xreplace : the result of the replacement</p>
<h1 id="examples_131">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, pi, exp
x, y, z = symbols('x y z')
(1 + x<em>y).xreplace({x: pi})
pi</em>y + 1
(1 + x<em>y).xreplace({x: pi, y: 2})
1 + 2</em>pi</p>
</blockquote>
</blockquote>
</blockquote>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>y + z).xreplace({x</em>y: pi})
z + pi
(x<em>y</em>z).xreplace({x<em>y: pi})
x</em>y<em>z
(2</em>x).xreplace({2<em>x: y, x: z})
y
(2</em>2<em>x).xreplace({2</em>x: y, x: z})
4*z
(x + y + 2).xreplace({x + y: 2})
x + y + 2
(x + 2 + exp(x + 2)).xreplace({x + 2: y})
x + exp(y) + 2</p>
</blockquote>
</blockquote>
</blockquote>
<p>xreplace does not differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
Integral(x, (x, 1, 2<em>x)).xreplace({x: y})
Integral(y, (y, 1, 2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Trying to replace x with an expression raises an error:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Integral(x, (x, 1, 2<em>x)).xreplace({x: 2</em>y}) # doctest: +SKIP
ValueError: Invalid limits given: ((2<em>y, 1, 4</em>y),)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_41">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
subs: substitution of subexpressions as defined by the objects
      themselves.</p>
<h3 id="parameterreference">ParameterReference</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ParameterReference</span><span class="p">(</span>
    <span class="n">parameter</span><span class="p">:</span> <span class="s1">&#39;Parameter[U]&#39;</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
    <span class="n">typ</span><span class="p">:</span> <span class="s1">&#39;type[U] | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Reference to an individual <code>Parameter</code>.</p>
<p>Allows us to refer to the outputs of a <code>Parameter</code> in subsequent <code>Parameter</code>
arguments.</p>
<h4 id="attributes_3">Attributes</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>parameter</td>
<td>None</td>
<td><code>Parameter</code> referred to.</td>
<td>None</td>
</tr>
<tr>
<td>workflow</td>
<td>None</td>
<td>Related workflow. In this case, as Parameters are generic<br>but ParameterReferences are specific, this carries the actual workflow reference.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="ancestors-in-mro_9">Ancestors (in MRO)</h4>
<ul>
<li>dewret.workflow.FieldableMixin</li>
<li>dewret.core.Reference</li>
<li>typing.Generic</li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.printing.defaults.Printable</li>
<li>sympy.core.evalf.EvalfMixin</li>
<li>dewret.core.WorkflowComponent</li>
</ul>
<h4 id="descendants_3">Descendants</h4>
<ul>
<li>dewret.workflow.IterableParameterReference</li>
</ul>
<h4 id="class-variables_6">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">ParameterReferenceMetadata</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">default_assumptions</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Add</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_AlgebraicNumber</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Atom</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Boolean</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Derivative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Dummy</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Equality</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Float</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Function</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Indexed</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatAdd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatMul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Matrix</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Mul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Not</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_NumberSymbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Order</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Piecewise</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Point</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Poly</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Pow</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Relational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Symbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Vector</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Wild</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_comparable</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_scalar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_symbol</span>
</code></pre></div>
<h4 id="static-methods_3">Static methods</h4>
<h4 id="class_key_3">class_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">class_key</span><span class="p">(</span>
    
<span class="p">)</span>
</code></pre></div>
<p>Nice order of classes.</p>
<h4 id="fromiter_3">fromiter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fromiter</span><span class="p">(</span>
    <span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<h1 id="examples_132">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Tuple
Tuple.fromiter(i for i in range(5))
(0, 1, 2, 3, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="instance-variables_7">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">args</span>
</code></pre></div>
<p>Returns a tuple of arguments of 'self'.</p>
<h1 id="examples_133">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cot
from sympy.abc import x, y</p>
<p>cot(x).args
(x,)</p>
<p>cot(x).args[0]
x</p>
<p>(x*y).args
(x, y)</p>
<p>(x*y).args[1]
y</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_18">Notes</h1>
<p>Never use self._args, always use self.args.
Only use _args in <strong>new</strong> when creating a new function.
Do not override .args() from Basic (so that it is easy to
change the interface in the future if needed).</p>
<div class="highlight"><pre><span></span><code><span class="n">assumptions0</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">binary_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">canonical_variables</span>
</code></pre></div>
<p>Return a dictionary mapping any variable defined in</p>
<p><code>self.bound_symbols</code> to Symbols that do not clash
with any free symbols in the expression.</p>
<h1 id="examples_134">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x
Lambda(x, 2*x).canonical_variables
{x: _0}</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">expr_free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">func</span>
</code></pre></div>
<p>The top-level function in an expression.</p>
<p>The following should hold for all objects::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt; x == x.func(*x.args)
</code></pre></div>
<h1 id="examples_135">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
a = 2<em>x
a.func
<class 'sympy.core.mul.Mul'>
a.args
(2, x)
a.func(</em>a.args)
2<em>x
a == a.func(</em>a.args)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">is_algebraic</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_antihermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_commutative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_complex</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_composite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_even</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_finite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_hermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_imaginary</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_infinite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_irrational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_noninteger</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_odd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_polar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_prime</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_transcendental</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_zero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">kind</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Printable name of the reference.</p>
<h4 id="methods_7">Methods</h4>
<h4 id="adjoint_3">adjoint</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">adjoint</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="apart_3">apart</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apart</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the apart function in sympy.polys</p>
<h4 id="args_cnc_3">args_cnc</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">args_cnc</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">split_1</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Return [commutative factors, non-commutative factors] of self.</p>
<h1 id="explanation_18">Explanation</h1>
<p>self is treated as a Mul and the ordering of the factors is maintained.
If <code>cset</code> is True the commutative factors will be returned in a set.
If there were repeated factors (as may happen with an unevaluated Mul)
then an error will be raised unless it is explicitly suppressed by
setting <code>warn</code> to False.</p>
<p>Note: -1 is always separated from a Number unless split_1 is False.</p>
<h1 id="examples_136">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, oo
A, B = symbols('A B', commutative=0)
x, y = symbols('x y')
(-2<em>x</em>y).args_cnc()
[[-1, 2, x, y], []]
(-2.5<em>x).args_cnc()
[[-1, 2.5, x], []]
(-2</em>x<em>A</em>B<em>y).args_cnc()
[[-1, 2, x, y], [A, B]]
(-2</em>x<em>A</em>B<em>y).args_cnc(split_1=False)
[[-2, x, y], [A, B]]
(-2</em>x*y).args_cnc(cset=True)
[{-1, 2, x, y}, []]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The arg is always treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-2 + x + A).args_cnc()
[[], [x - 2 + A]]
(-oo).args_cnc() # -oo is a singleton
[[-1, oo], []]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_base_exp_3">as_base_exp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_base_exp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<h4 id="as_coeff_add_6">as_coeff_Add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a summation.</p>
<h4 id="as_coeff_mul_6">as_coeff_Mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a product.</p>
<h4 id="as_coeff_add_7">as_coeff_add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as an Add, <code>a</code>.</p>
<p>c should be a Rational added to any terms of the Add that are
independent of deps.</p>
<p>args should be a tuple of all other terms of <code>a</code>; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is an Add or not but
you want to treat self as an Add or if you want to process the
individual arguments of the tail of self as an Add.</p>
<ul>
<li>if you know self is an Add and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail.</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_add()
(3, ())
(3 + x).as_coeff_add()
(3, (x,))
(3 + x + y).as_coeff_add(x)
(y + 3, (x,))
(3 + y).as_coeff_add(x)
(y + 3, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coeff_exponent_3">as_coeff_exponent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_exponent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p><code>c*x**e -&gt; c,e</code> where x can be any symbolic expression.</p>
<h4 id="as_coeff_mul_7">as_coeff_mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as a Mul, <code>m</code>.</p>
<p>c should be a Rational multiplied by any factors of the Mul that are
independent of deps.</p>
<p>args should be a tuple of all other factors of m; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is a Mul or not but
you want to treat self as a Mul or if you want to process the
individual arguments of the tail of self as a Mul.</p>
<ul>
<li>if you know self is a Mul and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail;</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_mul()
(3, ())
(3<em>x</em>y).as_coeff_mul()
(3, (x, y))
(3<em>x</em>y).as_coeff_mul(x)
(3<em>y, (x,))
(3</em>y).as_coeff_mul(x)
(3*y, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coefficient_3">as_coefficient</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Extracts symbolic coefficient at the given expression. In</p>
<p>other words, this functions separates 'self' into the product
of 'expr' and 'expr'-free coefficient. If such separation
is not possible it will return None.</p>
<h1 id="examples_137">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import E, pi, sin, I, Poly
from sympy.abc import x</p>
<p>E.as_coefficient(E)
1
(2<em>E).as_coefficient(E)
2
(2</em>sin(E)*E).as_coefficient(E)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two terms have E in them so a sum is returned. (If one were
desiring the coefficient of the term exactly matching E then
the constant from the returned expression could be selected.
Or, for greater precision, a method of Poly can be used to
indicate the desired term from which the coefficient is
desired.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E + x</em>E).as_coefficient(E)
x + 2
_.args[0]  # just want the exact match
2
p = Poly(2<em>E + x</em>E); p
Poly(x<em>E + 2</em>E, x, E, domain='ZZ')
p.coeff_monomial(E)
2
p.nth(0, 1)
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since the following cannot be written as a product containing
E as a factor, None is returned. (If the coefficient <code>2*x</code> is
desired then the <code>coeff</code> method should be used.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E</em>x + x).as_coefficient(E)
(2<em>E</em>x + x).coeff(E)
2*x</p>
<p>(E*(x + 1) + x).as_coefficient(E)</p>
<p>(2<em>pi</em>I).as_coefficient(pi<em>I)
2
(2</em>I).as_coefficient(pi*I)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_42">See Also</h1>
<p>coeff: return sum of terms have a given factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="as_coefficients_dict_3">as_coefficients_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficients_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a dictionary mapping terms to their Rational coefficient.</p>
<p>Since the dictionary is a defaultdict, inquiries about terms which
were not present will return a coefficient of 0.</p>
<p>If symbols <code>syms</code> are provided, any multiplicative terms
independent of them will be considered a coefficient and a
regular dictionary of syms-dependent generators as keys and
their corresponding coefficients as values will be returned.</p>
<h1 id="examples_138">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import a, x, y
(3<em>x + a</em>x + 4).as_coefficients_dict()
{1: 4, x: 3, a<em>x: 1}
_[a]
0
(3</em>a<em>x).as_coefficients_dict()
{a</em>x: 3}
(3<em>a</em>x).as_coefficients_dict(x)
{x: 3<em>a}
(3</em>a<em>x).as_coefficients_dict(y)
{1: 3</em>a*x}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_content_primitive_3">as_content_primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_content_primitive</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">radical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">clear</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>This method should recursively remove a Rational from all arguments</p>
<p>and return that (content) and the new self (primitive). The content
should always be positive and <code>Mul(*foo.as_content_primitive()) == foo</code>.
The primitive need not be in canonical form and should try to preserve
the underlying structure if possible (i.e. expand_mul should not be
applied to self).</p>
<h1 id="examples_139">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt
from sympy.abc import x, y, z</p>
<p>eq = 2 + 2<em>x + 2</em>y<em>(3 + 3</em>y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The as_content_primitive function is recursive and retains structure:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eq.as_content_primitive()
(2, x + 3<em>y</em>(y + 1) + 1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Integer powers will have Rationals extracted from the base:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((2 + 6<em>x)</em><em>2).as_content_primitive()
(4, (3</em>x + 1)<strong>2)
((2 + 6*x)</strong>(2<em>y)).as_content_primitive()
(1, (2</em>(3<em>x + 1))</em><em>(2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Terms may end up joining once their as_content_primitives are added:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((5<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(11, x</em>(y + 1))
((3<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(9, x</em>(y + 1))
((3<em>(z</em>(1 + y)) + 2.0<em>x</em>(3 + 3<em>y))).as_content_primitive()
(1, 6.0</em>x<em>(y + 1) + 3</em>z<em>(y + 1))
((5</em>(x<em>(1 + y)) + 2</em>x<em>(3 + 3</em>y))<strong>2).as_content_primitive()
(121, x</strong>2<em>(y + 1)</em><em>2)
((x</em>(1 + y) + 0.4<em>x</em>(3 + 3<em>y))</em><em>2).as_content_primitive()
(1, 4.84</em>x<strong>2*(y + 1)</strong>2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Radical content can also be factored out of the primitive:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>sqrt(2) + 4</em>sqrt(10)).as_content_primitive(radical=True)
(2, sqrt(2)<em>(1 + 2</em>sqrt(5)))</p>
</blockquote>
</blockquote>
</blockquote>
<p>If clear=False (default is True) then content will not be removed
from an Add if it can be distributed to leave one or more
terms with integer coefficients.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/2 + y).as_content_primitive()
(1/2, x + 2*y)
(x/2 + y).as_content_primitive(clear=False)
(1, x/2 + y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_dummy_3">as_dummy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_dummy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression with any objects having structurally</p>
<p>bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<h1 id="examples_140">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Symbol
from sympy.abc import x
r = Symbol('r', real=True)
Integral(r, (r, x)).as_dummy()
Integral(<em>0, (_0, x))
</em>.variables[0].is_real is None
True
r.as_dummy()
_r</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_19">Notes</h1>
<p>Any object that has structurally bound variables should have
a property, <code>bound_symbols</code> that returns those symbols
appearing in the object.</p>
<h4 id="as_expr_3">as_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span>
<span class="p">)</span>
</code></pre></div>
<p>Convert a polynomial to a SymPy expression.</p>
<h1 id="examples_141">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>f = (x<strong>2 + x*y).as_poly(x, y)
f.as_expr()
x</strong>2 + x*y</p>
<p>sin(x).as_expr()
sin(x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_independent_3">as_independent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_independent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hint</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>A mostly naive separation of a Mul or Add into arguments that are not</p>
<p>are dependent on deps. To obtain as complete a separation of variables
as possible, use a separation method first, e.g.:</p>
<ul>
<li>separatevars() to change Mul, Add and Pow (including exp) into Mul</li>
<li>.expand(mul=True) to change Add or Mul into Add</li>
<li>.expand(log=True) to change log expr into an Add</li>
</ul>
<p>The only non-naive thing that is done here is to respect noncommutative
ordering of variables and to always return (0, 0) for <code>self</code> of zero
regardless of hints.</p>
<p>For nonzero <code>self</code>, the returned tuple (i, d) has the
following interpretation:</p>
<ul>
<li>i will has no variable that appears in deps</li>
<li>d will either have terms that contain variables that are in deps, or
  be equal to 0 (when self is an Add) or 1 (when self is a Mul)</li>
<li>if self is an Add then self = i + d</li>
<li>if self is a Mul then self = i*d</li>
<li>otherwise (self, S.One) or (S.One, self) is returned.</li>
</ul>
<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>
<h1 id="examples_142">Examples</h1>
<p>-- self is an Add</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos, exp
from sympy.abc import x, y, z</p>
<p>(x + x<em>y).as_independent(x)
(0, x</em>y + x)
(x + x<em>y).as_independent(y)
(x, x</em>y)
(2<em>x</em>sin(x) + y + x + z).as_independent(x)
(y + z, 2<em>x</em>sin(x) + x)
(2<em>x</em>sin(x) + y + x + z).as_independent(x, y)
(z, 2<em>x</em>sin(x) + x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>sin(x)</em>cos(y)).as_independent(x)
(cos(y), x*sin(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>non-commutative terms cannot always be separated out when self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
(n1 + n1<em>n2).as_independent(n2)
(n1, n1</em>n2)
(n2<em>n1 + n1</em>n2).as_independent(n2)
(0, n1<em>n2 + n2</em>n1)
(n1<em>n2</em>n3).as_independent(n1)
(1, n1<em>n2</em>n3)
(n1<em>n2</em>n3).as_independent(n2)
(n1, n2<em>n3)
((x-n1)</em>(x-y)).as_independent(x)
(1, (x - y)*(x - n1))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is anything else:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(sin(x)).as_independent(x)
(1, sin(x))
(sin(x)).as_independent(y)
(sin(x), 1)
exp(x+y).as_independent(x)
(1, exp(x + y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as an Add:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3<em>x).as_independent(x, as_Add=True)
(0, 3</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3+x).as_independent(x, as_Add=False)
(1, x + 3)
(-3+x).as_independent(x, as_Add=False)
(1, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note how the below differs from the above in making the
constant on the dep term positive.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(y*(-3+x)).as_independent(x)
(y, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- use .as_independent() for true independence testing instead
   of .has(). The former considers only symbols in the free
   symbols while the latter considers all symbols</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
I = Integral(x, (x, 1, 2))
I.has(x)
True
x in I.free_symbols
False
I.as_independent(x) == (I, 1)
True
(I + x).as_independent(x) == (I, x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note: when trying to get independent terms, a separation method
might need to be used first. In this case, it is important to keep
track of what you send to this routine so you know how to interpret
the returned values</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import separatevars, log
separatevars(exp(x+y)).as_independent(x)
(exp(y), exp(x))
(x + x<em>y).as_independent(y)
(x, x</em>y)
separatevars(x + x<em>y).as_independent(y)
(x, y + 1)
(x</em>(1 + y)).as_independent(y)
(x, y + 1)
(x<em>(1 + y)).expand(mul=True).as_independent(y)
(x, x</em>y)
a, b=symbols('a b', positive=True)
(log(a*b).expand(log=True)).as_independent(b)
(log(a), log(b))</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_43">See Also</h1>
<p>separatevars
expand_log
sympy.core.add.Add.as_two_terms
sympy.core.mul.Mul.as_two_terms
as_coeff_mul</p>
<h4 id="as_leading_term_3">as_leading_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_leading_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading (nonzero) term of the series expansion of self.</p>
<p>The _eval_as_leading_term routines are used to do this, and they must
always return a non-zero value.</p>
<h1 id="examples_143">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1 + x + x<strong>2).as_leading_term(x)
1
(1/x</strong>2 + x + x<strong>2).as_leading_term(x)
x</strong>(-2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_numer_denom_3">as_numer_denom</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_numer_denom</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>Return the numerator and the denominator of an expression.</p>
<p>expression -&gt; a/b -&gt; a, b</p>
<p>This is just a stub that should be defined by
an object's class methods to get anything else.</p>
<h1 id="see-also_44">See Also</h1>
<p>normal: return <code>a/b</code> instead of <code>(a, b)</code></p>
<h4 id="as_ordered_factors_3">as_ordered_factors</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_factors</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return list of ordered factors (if Mul) else [self].</p>
<h4 id="as_ordered_terms_3">as_ordered_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_terms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to an ordered list of terms.</p>
<h1 id="examples_144">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos
from sympy.abc import x</p>
<p>(sin(x)<strong>2*cos(x) + sin(x)</strong>2 + 1).as_ordered_terms()
[sin(x)<strong>2*cos(x), sin(x)</strong>2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_poly_3">as_poly</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_poly</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Converts <code>self</code> to a polynomial or returns <code>None</code>.</p>
<h1 id="explanation_19">Explanation</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>print((x<strong>2 + x*y).as_poly())
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x<strong>2 + x*y).as_poly(x, y))
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x**2 + sin(y)).as_poly(x, y))
None</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_powers_dict_3">as_powers_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_powers_dict</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self as a dictionary of factors with each factor being</p>
<p>treated as a power. The keys are the bases of the factors and the
values, the corresponding exponents. The resulting dictionary should
be used with caution if the expression is a Mul and contains non-
commutative factors since the order that they appeared will be lost in
the dictionary.</p>
<h1 id="see-also_45">See Also</h1>
<p>as_ordered_factors: An alternative for noncommutative applications,
                    returning an ordered list of factors.
args_cnc: Similar to as_ordered_factors, but guarantees separation
          of commutative and noncommutative factors.</p>
<h4 id="as_real_imag_3">as_real_imag</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_real_imag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Performs complex expansion on 'self' and returns a tuple</p>
<p>containing collected both real and imaginary parts. This
method cannot be confused with re() and im() functions,
which does not perform complex expansion at evaluation.</p>
<p>However it is possible to expand both re() and im()
functions and get exactly the same results as with
a single call to this function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, I</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>(x + y*I).as_real_imag()
(x, y)</p>
<p>from sympy.abc import z, w</p>
<p>(z + w*I).as_real_imag()
(re(z) - im(w), re(w) + im(z))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_set_3">as_set</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_set</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrites Boolean expression in terms of real sets.</p>
<h1 id="examples_145">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Eq, Or, And
x = Symbol('x', real=True)
Eq(x, 0).as_set()
{0}
(x &gt; 0).as_set()
Interval.open(0, oo)
And(-2 &lt; x, x &lt; 2).as_set()
Interval.open(-2, 2)
Or(x &lt; -2, 2 &lt; x).as_set()
Union(Interval.open(-oo, -2), Interval.open(2, oo))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_terms_3">as_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_terms</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to a list of terms. </p>
<h4 id="aseries_3">aseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">aseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">hir</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Asymptotic Series expansion of self.</p>
<p>This is equivalent to <code>self.series(x, oo, n)</code>.</p>
<h1 id="parameters_18">Parameters</h1>
<p>self : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>hir : Boolean
      Set this parameter to be True to produce hierarchical series.
      It stops the recursion at an early level and may provide nicer
      and more useful results.</p>
<p>bound : Value, Integer
        Use the <code>bound</code> parameter to give limit on rewriting
        coefficients in its normalised form.</p>
<h1 id="examples_146">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, exp
from sympy.abc import x</p>
<p>e = sin(1/x + exp(-x)) - sin(1/x)</p>
<p>e.aseries(x)
(1/(24<em>x</em><em>4) - 1/(2</em>x<strong>2) + 1 + O(x</strong>(-6), (x, oo)))*exp(-x)</p>
<p>e.aseries(x, n=3, hir=True)
-exp(-2<em>x)</em>sin(1/x)/2 + exp(-x)<em>cos(1/x) + O(exp(-3</em>x), (x, oo))</p>
<p>e = exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x)
exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x, bound=3) # doctest: +SKIP
exp(exp(x)/x<strong>2)<em>exp(exp(x)/x)</em>exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x</strong>2)*exp(exp(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).aseries(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_9">Returns</h1>
<p>Expr
    Asymptotic series expansion of the expression.</p>
<h1 id="notes_20">Notes</h1>
<p>This algorithm is directly induced from the limit computational algorithm provided by Gruntz.
It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first
to look for the most rapidly varying subexpression w of a given expression f and then expands f
in a series in w. Then same thing is recursively done on the leading coefficient
till we get constant coefficients.</p>
<p>If the most rapidly varying subexpression of a given expression f is f itself,
the algorithm tries to find a normalised representation of the mrv set and rewrites f
using this normalised representation.</p>
<p>If the expansion contains an order term, it will be either <code>O(x ** (-n))</code> or <code>O(w ** (-n))</code>
where <code>w</code> belongs to the most rapidly varying expression of <code>self</code>.</p>
<h1 id="references_6">References</h1>
<p>.. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series.
       In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993.
       pp. 239-244.
.. [2] Gruntz thesis - p90
.. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion</p>
<h1 id="see-also_46">See Also</h1>
<p>Expr.aseries: See the docstring of this function for complete details of this wrapper.</p>
<h4 id="atoms_3">atoms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">atoms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">types</span><span class="p">:</span> <span class="s1">&#39;Tbasic | type[Tbasic]&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;set[Basic] | set[Tbasic]&#39;</span>
</code></pre></div>
<p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and cannot
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<h1 id="examples_147">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import I, pi, sin
from sympy.abc import x, y
(1 + x + 2<em>sin(y + I</em>pi)).atoms()
{1, 2, I, pi, x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Number, NumberSymbol, Symbol
(1 + x + 2<em>sin(y + I</em>pi)).atoms(Symbol)
{x, y}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number)
{1, 2}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol)
{1, 2, pi}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol, I)
{1, 2, I, pi}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(x) # x is a Symbol
{x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Be careful to check your assumptions when using the implicit option
since <code>S(1).is_Integer = True</code> but <code>type(S(1))</code> is <code>One</code>, a special type
of SymPy atom, while <code>type(S(2))</code> is type <code>Integer</code> and will find all
integers in an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(1))
{1}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(2))
{1, 2}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
SymPy type (loaded in core/<strong>init</strong>.py) can be listed as an argument
and those types of "atoms" as found in scanning the arguments of the
expression recursively:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function, Mul
from sympy.core.function import AppliedUndef
f = Function('f')
(1 + f(x) + 2<em>sin(y + I</em>pi)).atoms(Function)
{f(x), sin(y + I<em>pi)}
(1 + f(x) + 2</em>sin(y + I*pi)).atoms(AppliedUndef)
{f(x)}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Mul)
{I<em>pi, 2</em>sin(y + I*pi)}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="cancel_3">cancel</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cancel</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the cancel function in sympy.polys</p>
<h4 id="coeff_3">coeff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">coeff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">_first</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the coefficient from the term(s) containing <code>x**n</code>. If <code>n</code></p>
<p>is zero then all terms independent of <code>x</code> will be returned.</p>
<h1 id="explanation_20">Explanation</h1>
<p>When <code>x</code> is noncommutative, the coefficient to the left (default) or
right of <code>x</code> can be returned. The keyword 'right' is ignored when
<code>x</code> is commutative.</p>
<h1 id="examples_148">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
from sympy.abc import x, y, z</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have an explicit negative in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x + 2<em>y).coeff(-1)
x
(x - 2</em>y).coeff(-1)
2*y</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms with no Rational coefficient:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + 2<em>y).coeff(1)
x
(3 + 2</em>x + 4<em>x</em>*2).coeff(1)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms independent of x by making n=0; in this case
expr.as_independent(x)[0] is returned (and 0 will be returned instead
of None):</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x, 0)
3
eq = ((x + 1)</strong>3).expand() + 1
eq
x<strong>3 + 3*x</strong>2 + 3*x + 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 2]
eq -= 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 0]</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have a numerical term in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x - 2<em>y).coeff(2)
-y
from sympy import sqrt
(x + sqrt(2)</em>x).coeff(sqrt(2))
x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The matching is exact:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x)
2
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>2)
4
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>3)
0
(z*(x + y)</strong>2).coeff((x + y)<strong>2)
z
(z*(x + y)</strong>2).coeff(x + y)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
from the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + z<em>(x + x</em>y)).coeff(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<p>If such factoring is desired, factor_terms can be used first:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import factor_terms
factor_terms(x + z<em>(x + x</em>y)).coeff(x)
z*(y + 1) + 1</p>
<p>n, m, o = symbols('n m o', commutative=False)
n.coeff(n)
1
(3<em>n).coeff(n)
3
(n</em>m + m<em>n</em>m).coeff(n) # = (1 + m)<em>n</em>m
1 + m
(n<em>m + m</em>n<em>m).coeff(n, right=True) # = (1 + m)</em>n*m
m</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is more than one possible coefficient 0 is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + m</em>n).coeff(n)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is only one possible coefficient, it is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + x</em>m<em>n).coeff(m</em>n)
x
(n<em>m + x</em>m<em>n).coeff(m</em>n, right=1)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_47">See Also</h1>
<p>as_coefficient: separate the expression into a coefficient and factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="collect_3">collect</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">syms</span><span class="p">,</span>
    <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">distribute_order_term</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the collect function in sympy.simplify</p>
<h4 id="combsimp_3">combsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">combsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the combsimp function in sympy.simplify</p>
<h4 id="compare_3">compare</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compare</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span>
<span class="p">)</span>
</code></pre></div>
<p>Return -1, 0, 1 if the object is less than, equal,</p>
<p>or greater than other in a canonical sense.
Non-Basic are always greater than Basic.
If both names of the classes being compared appear
in the <code>ordering_of_classes</code> then the ordering will
depend on the appearance of the names there.
If either does not appear in that list, then the
comparison is based on the class name.
If the names are the same then a comparison is made
on the length of the hashable content.
Items of the equal-lengthed contents are then
successively compared using the same rules. If there
is never a difference then 0 is returned.</p>
<h1 id="examples_149">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
x.compare(y)
-1
x.compare(x)
0
y.compare(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="conjugate_3">conjugate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">conjugate</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the complex conjugate of 'self'.</p>
<h4 id="copy_3">copy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="could_extract_minus_sign_3">could_extract_minus_sign</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">could_extract_minus_sign</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;bool&#39;</span>
</code></pre></div>
<p>Return True if self has -1 as a leading factor or has</p>
<p>more literal negative signs than positive signs in a sum,
otherwise False.</p>
<h1 id="examples_150">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = x - y
{i.could_extract_minus_sign() for i in (e, -e)}
{False, True}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Though the <code>y - x</code> is considered like <code>-(x - y)</code>, since it
is in a product without a leading factor of -1, the result is
false below:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*(y - x)).could_extract_minus_sign()
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>To put something in canonical form wrt to sign, use <code>signsimp</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import signsimp
signsimp(x<em>(y - x))
-x</em>(x - y)
_.could_extract_minus_sign()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="count_3">count</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span>
<span class="p">)</span>
</code></pre></div>
<p>Count the number of matching subexpressions.</p>
<h4 id="count_ops_3">count_ops</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_ops</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">visual</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for count_ops that returns the operation count.</p>
<h4 id="diff_3">diff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">diff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="dir_3">dir</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dir</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">cdir</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="doit_3">doit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">doit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate objects that are not evaluated by default like limits,</p>
<p>integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via 'hints'
or unless the 'deep' hint was set to 'False'.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
from sympy.abc import x</p>
<p>2<em>Integral(x, x)
2</em>Integral(x, x)</p>
<p>(2<em>Integral(x, x)).doit()
x</em>*2</p>
<p>(2<em>Integral(x, x)).doit(deep=False)
2</em>Integral(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="dummy_eq_3">dummy_eq</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dummy_eq</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">symbol</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compare two expressions and handle dummy symbols.</p>
<h1 id="examples_151">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Dummy
from sympy.abc import x, y</p>
<p>u = Dummy('u')</p>
<p>(u<strong>2 + 1).dummy_eq(x</strong>2 + 1)
True
(u<strong>2 + 1) == (x</strong>2 + 1)
False</p>
<p>(u<strong>2 + y).dummy_eq(x</strong>2 + y, x)
True
(u<strong>2 + y).dummy_eq(x</strong>2 + y, y)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="equals_3">equals</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">failing_expression</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self == other, False if it does not, or None. If</p>
<p>failing_expression is True then the expression which did not simplify
to a 0 will be returned instead of None.</p>
<h1 id="explanation_21">Explanation</h1>
<p>If <code>self</code> is a Number (or complex number) that is not zero, then
the result is False.</p>
<p>If <code>self</code> is a number and has not evaluated to zero, evalf will be
used to test whether the expression evaluates to zero. If it does so
and the result has significance (i.e. the precision is either -1, for
a Rational result, or is greater than 1) then the evalf value will be
used to return True or False.</p>
<h4 id="evalf_3">evalf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">evalf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_19">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_21">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="expand_3">expand</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">modulus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">power_base</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">power_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">multinomial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Expand an expression using hints.</p>
<p>See the docstring of the expand() function in sympy.core.function for
more information.</p>
<h4 id="extract_additively_3">extract_additively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_additively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self - c if it's possible to subtract c from self and</p>
<p>make all matching coefficients move towards zero, else return None.</p>
<h1 id="examples_152">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = 2<em>x + 3
e.extract_additively(x + 1)
x + 2
e.extract_additively(3</em>x)
e.extract_additively(4)
(y<em>(x + 1)).extract_additively(x + 1)
((x + 1)</em>(x + 2<em>y + 1) + 3).extract_additively(x + 1)
(x + 1)</em>(x + 2*y) + 3</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_48">See Also</h1>
<p>extract_multiplicatively
coeff
as_coefficient</p>
<h4 id="extract_branch_factor_3">extract_branch_factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_branch_factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">allow_half</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Try to write self as <code>exp_polar(2*pi*I*n)*z</code> in a nice way.</p>
<p>Return (z, n).</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp_polar, I, pi
from sympy.abc import x, y
exp_polar(I<em>pi).extract_branch_factor()
(exp_polar(I</em>pi), 0)
exp_polar(2<em>I</em>pi).extract_branch_factor()
(1, 1)
exp_polar(-pi<em>I).extract_branch_factor()
(exp_polar(I</em>pi), -1)
exp_polar(3<em>pi</em>I + x).extract_branch_factor()
(exp_polar(x + I<em>pi), 1)
(y</em>exp_polar(-5<em>pi</em>I)<em>exp_polar(3</em>pi<em>I + 2</em>pi<em>x)).extract_branch_factor()
(y</em>exp_polar(2<em>pi</em>x), -1)
exp_polar(-I<em>pi/2).extract_branch_factor()
(exp_polar(-I</em>pi/2), 0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If allow_half is True, also extract exp_polar(I*pi):</p>
<blockquote>
<blockquote>
<blockquote>
<p>exp_polar(I<em>pi).extract_branch_factor(allow_half=True)
(1, 1/2)
exp_polar(2</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 1)
exp_polar(3</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 3/2)
exp_polar(-I</em>pi).extract_branch_factor(allow_half=True)
(1, -1/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="extract_multiplicatively_3">extract_multiplicatively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_multiplicatively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Return None if it's not possible to make self in the form</p>
<p>c * something in a nice way, i.e. preserving the properties
of arguments of self.</p>
<h1 id="examples_153">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Rational</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em><em>2 * y)
x</em>y**2</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em>*4 * y)</p>
<p>(2*x).extract_multiplicatively(2)
x</p>
<p>(2*x).extract_multiplicatively(3)</p>
<p>(Rational(1, 2)*x).extract_multiplicatively(3)
x/6</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="factor_3">factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the factor() function in sympy.polys.polytools</p>
<h4 id="find_3">find</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Find all subexpressions matching a query.</p>
<h4 id="find_field_3">find_field</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_field</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s1">&#39;FieldableProtocol&#39;</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;str | int&#39;</span><span class="p">,</span>
    <span class="n">fallback_type</span><span class="p">:</span> <span class="s1">&#39;type | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">init_kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Reference[Any]&#39;</span>
</code></pre></div>
<p>Field within the reference, if possible.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>field</td>
<td>None</td>
<td>the field to search for.</td>
<td>None</td>
</tr>
<tr>
<td>fallback_type</td>
<td>None</td>
<td>the type to use if we do not know a more specific one.</td>
<td>None</td>
</tr>
<tr>
<td>**init_kwargs</td>
<td>None</td>
<td>arguments to use for constructing a new reference (via <code>__make_reference__</code>).</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A field-specific version of this reference.</td>
</tr>
</tbody>
</table>
<h4 id="fourier_series_3">fourier_series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fourier_series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">limits</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute fourier sine/cosine series of self.</p>
<p>See the docstring of the :func:<code>fourier_series</code> in sympy.series.fourier
for more information.</p>
<h4 id="fps_3">fps</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fps</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">hyper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute formal power power series of self.</p>
<p>See the docstring of the :func:<code>fps</code> function in sympy.series.formal for
more information.</p>
<h4 id="gammasimp_3">gammasimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gammasimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the gammasimp function in sympy.simplify</p>
<h4 id="geto_3">getO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Returns the additive O(..) symbol if there is one, else None.</p>
<h4 id="getn_3">getn</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getn</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the order of the expression.</p>
<h1 id="explanation_22">Explanation</h1>
<p>The order is determined either from the O(...) term. If there
is no O(...) term, it returns None.</p>
<h1 id="examples_154">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import O
from sympy.abc import x
(1 + x + O(x**2)).getn()
2
(1 + x).getn()</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_3">has</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether any subexpression matches any of the patterns.</p>
<h1 id="examples_155">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y, z
(x<strong>2 + sin(x*y)).has(z)
False
(x</strong>2 + sin(x*y)).has(x, y, z)
True
x.has(x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note <code>has</code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Interval
i = Interval.Lopen(0, 5); i
Interval.Lopen(0, 5)
i.args
(0, 5, True, False)
i.has(4)  # there is no "4" in the arguments
False
i.has(0)  # there <em>is</em> a "0" in the arguments
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Instead, use <code>contains</code> to determine whether a number is in the
interval or not:</p>
<blockquote>
<blockquote>
<blockquote>
<p>i.contains(4)
True
i.contains(0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that <code>expr.has(*patterns)</code> is exactly equivalent to
<code>any(expr.has(p) for p in patterns)</code>. In particular, <code>False</code> is
returned when the list of patterns is empty.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x.has()
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_free_3">has_free</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_free</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has object(s) <code>x</code> as a free expression</p>
<p>else False.</p>
<h1 id="examples_156">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Function
from sympy.abc import x, y
f = Function('f')
g = Function('g')
expr = Integral(f(x), (f(x), 1, g(y)))
expr.free_symbols
{y}
expr.has_free(g(y))
True
expr.has_free(*(x, f(x)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This works for subexpressions and types, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.has_free(g)
True
(x + y + 1).has_free(y + 1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_xfree_3">has_xfree</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_xfree</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;set[Basic]&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has any of the patterns in s as a</p>
<p>free argument, else False. This is like <code>Basic.has_free</code>
but this will only report exact argument matches.</p>
<h1 id="examples_157">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
from sympy.abc import x, y
f = Function('f')
f(x).has_xfree({f})
False
f(x).has_xfree({f(x)})
True
f(x + 1).has_xfree({x})
True
f(x + 1).has_xfree({x + 1})
True
f(x + y + 1).has_xfree({x + 1})
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="integrate_3">integrate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">integrate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the integrate function in sympy.integrals</p>
<h4 id="invert_3">invert</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">g</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the multiplicative inverse of <code>self</code> mod <code>g</code></p>
<p>where <code>self</code> (and <code>g</code>) may be symbolic expressions).</p>
<h1 id="see-also_49">See Also</h1>
<p>sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert</p>
<h4 id="is_algebraic_expr_3">is_algebraic_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_algebraic_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether a given expression is algebraic or not, in the</p>
<p>given symbols, syms. When syms is not given, all free symbols
will be used. The rational function does not have to be in expanded
or in any kind of canonical form.</p>
<p>This function returns False for expressions that are "algebraic
expressions" with symbolic exponents. This is a simple extension to the
is_rational_function, including rational exponentiation.</p>
<h1 id="examples_158">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sqrt
x = Symbol('x', real=True)
sqrt(1 + x).is_rational_function()
False
sqrt(1 + x).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be an algebraic
expression to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp, factor
a = sqrt(exp(x)*<em>2 + 2</em>exp(x) + 1)/(exp(x) + 1)
a.is_algebraic_expr(x)
False
factor(a).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_50">See Also</h1>
<p>is_rational_function</p>
<h1 id="references_7">References</h1>
<p>.. [1] https://en.wikipedia.org/wiki/Algebraic_expression</p>
<h4 id="is_constant_3">is_constant</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">wrt</span><span class="p">,</span>
    <span class="o">**</span><span class="n">flags</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is constant, False if not, or None if</p>
<p>the constancy could not be determined conclusively.</p>
<h1 id="explanation_23">Explanation</h1>
<p>If an expression has no free symbols then it is a constant. If
there are free symbols it is possible that the expression is a
constant, perhaps (but not necessarily) zero. To test such
expressions, a few strategies are tried:</p>
<p>1) numerical evaluation at two random points. If two such evaluations
give two different values and the values have a precision greater than
1 then self is not constant. If the evaluations agree or could not be
obtained with any precision, no decision is made. The numerical testing
is done only if <code>wrt</code> is different than the free symbols.</p>
<p>2) differentiation with respect to variables in 'wrt' (or all free
symbols if omitted) to see if the expression is constant or not. This
will not always lead to an expression that is zero even though an
expression is constant (see added test in test_expr.py). If
all derivatives are zero then self is constant with respect to the
given symbols.</p>
<p>3) finding out zeros of denominator expression with free_symbols.
It will not be constant if there are zeros. It gives more negative
answers for expression that are not constant.</p>
<p>If neither evaluation nor differentiation can prove the expression is
constant, None is returned unless two numerical values happened to be
the same and the flag <code>failing_number</code> is True -- in that case the
numerical value will be returned.</p>
<p>If flag simplify=False is passed, self will not be simplified;
the default is True since self should be simplified before testing.</p>
<h1 id="examples_159">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, Sum, S, pi
from sympy.abc import a, n, x, y
x.is_constant()
False
S(2).is_constant()
True
Sum(x, (x, 1, 10)).is_constant()
True
Sum(x, (x, 1, n)).is_constant()
False
Sum(x, (x, 1, n)).is_constant(y)
True
Sum(x, (x, 1, n)).is_constant(n)
False
Sum(x, (x, 1, n)).is_constant(x)
True
eq = a<em>cos(x)</em><em>2 + a</em>sin(x)**2 - a
eq.is_constant()
True
eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
True</p>
<p>(0<strong>x).is_constant()
False
x.is_constant()
False
(x</strong>x).is_constant()
False
one = cos(x)<strong>2 + sin(x)</strong>2
one.is_constant()
True
((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_hypergeometric_3">is_hypergeometric</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_hypergeometric</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">k</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="is_meromorphic_3">is_meromorphic</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_meromorphic</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">a</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether an expression is meromorphic as</p>
<p>a function of the given symbol <code>x</code> at the point <code>a</code>.</p>
<p>This method is intended as a quick test that will return
None if no decision can be made without simplification or
more detailed analysis.</p>
<h1 id="examples_160">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import zoo, log, sin, sqrt
from sympy.abc import x</p>
<p>f = 1/x<strong>2 + 1 - 2*x</strong>3
f.is_meromorphic(x, 0)
True
f.is_meromorphic(x, 1)
True
f.is_meromorphic(x, zoo)
True</p>
<p>g = x**log(3)
g.is_meromorphic(x, 0)
False
g.is_meromorphic(x, 1)
True
g.is_meromorphic(x, zoo)
False</p>
<p>h = sin(1/x)<em>x</em>*2
h.is_meromorphic(x, 0)
False
h.is_meromorphic(x, 1)
True
h.is_meromorphic(x, zoo)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multivalued functions are considered meromorphic when their
branches are meromorphic. Thus most functions are meromorphic
everywhere except at essential singularities and branch points.
In particular, they will be meromorphic also on branch cuts
except at their endpoints.</p>
<blockquote>
<blockquote>
<blockquote>
<p>log(x).is_meromorphic(x, -1)
True
log(x).is_meromorphic(x, 0)
False
sqrt(x).is_meromorphic(x, -1)
True
sqrt(x).is_meromorphic(x, 0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_polynomial_3">is_polynomial</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_polynomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is a polynomial in syms and False otherwise.</p>
<p>This checks if self is an exact polynomial in syms.  This function
returns False for expressions that are "polynomials" with symbolic
exponents.  Thus, you should be able to apply polynomial algorithms to
expressions for which this returns True, and Poly(expr, *syms) should
work if and only if expr.is_polynomial(*syms) returns True. The
polynomial does not have to be in expanded form.  If no symbols are
given, all free symbols in the expression will be used.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', polynomial=True).</p>
<h1 id="examples_161">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Function
x = Symbol('x')
((x<strong>2 + 1)</strong>4).is_polynomial(x)
True
((x<strong>2 + 1)</strong>4).is_polynomial()
True
(2<strong>x + 1).is_polynomial(x)
False
(2</strong>x + 1).is_polynomial(2**x)
True
f = Function('f')
(f(x) + 1).is_polynomial(x)
False
(f(x) + 1).is_polynomial(f(x))
True
(1/f(x) + 1).is_polynomial(f(x))
False</p>
<p>n = Symbol('n', nonnegative=True, integer=True)
(x**n + 1).is_polynomial(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a polynomial to
become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor, cancel
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)
a.is_polynomial(y)
False
factor(a)
y + 1
factor(a).is_polynomial(y)
True</p>
<p>b = (y*<em>2 + 2</em>y + 1)/(y + 1)
b.is_polynomial(y)
False
cancel(b)
y + 1
cancel(b).is_polynomial(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also .is_rational_function()</p>
<h4 id="is_rational_function_3">is_rational_function</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_rational_function</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether function is a ratio of two polynomials in the given</p>
<p>symbols, syms. When syms is not given, all free symbols will be used.
The rational function does not have to be in expanded or in any kind of
canonical form.</p>
<p>This function returns False for expressions that are "rational
functions" with symbolic exponents.  Thus, you should be able to call
.as_numer_denom() and apply polynomial algorithms to the result for
expressions for which this returns True.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', rational_function=True).</p>
<h1 id="examples_162">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sin
from sympy.abc import x, y</p>
<p>(x/y).is_rational_function()
True</p>
<p>(x**2).is_rational_function()
True</p>
<p>(x/sin(y)).is_rational_function(y)
False</p>
<p>n = Symbol('n', integer=True)
(x**n + 1).is_rational_function(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a rational function
to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)/y
a.is_rational_function(y)
False
factor(a)
(y + 1)/y
factor(a).is_rational_function(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also is_algebraic_expr().</p>
<h4 id="is_same_3">is_same</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_same</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span>
    <span class="n">b</span><span class="p">,</span>
    <span class="n">approx</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if a and b are structurally the same, else False.</p>
<p>If <code>approx</code> is supplied, it will be used to test whether two
numbers are the same or not. By default, only numbers of the
same type will compare equal, so S.Half != Float(0.5).</p>
<h1 id="examples_163">Examples</h1>
<p>In SymPy (unlike Python) two numbers do not compare the same if they are
not of the same type:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
2.0 == S(2)
False
0.5 == S.Half
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>By supplying a function with which to compare two numbers, such
differences can be ignored. e.g. <code>equal_valued</code> will return True
for decimal numbers having a denominator that is a power of 2,
regardless of precision.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Float
from sympy.core.numbers import equal_valued
(S.Half/4).is_same(Float(0.125, 1), equal_valued)
True
Float(1, 2).is_same(Float(1, 10), equal_valued)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>But decimals without a power of 2 denominator will compare
as not being the same.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Float(0.1, 9).is_same(Float(0.1, 10), equal_valued)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>But arbitrary differences can be ignored by supplying a function
to test the equivalence of two numbers:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import math
Float(0.1, 9).is_same(Float(0.1, 10), math.isclose)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Other objects might compare the same even though types are not the
same. This routine will only return True if two expressions are
identical in terms of class types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import eye, Basic
eye(1) == S(eye(1))  # mutable vs immutable
True
Basic.is_same(eye(1), S(eye(1)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="leadterm_3">leadterm</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">leadterm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading term a<em>x</em>*b as a tuple (a, b).</p>
<h1 id="examples_164">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1+x+x<strong>2).leadterm(x)
(1, 0)
(1/x</strong>2+x+x**2).leadterm(x)
(1, -2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="limit_3">limit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">limit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">xlim</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute limit x-&gt;xlim.</p>
<h4 id="lseries_3">lseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for series yielding an iterator of the terms of the series.</p>
<p>Note: an infinite series will yield an infinite iterator. The following,
for exaxmple, will never terminate. It will just keep printing terms
of the sin(x) series::</p>
<p>for term in sin(x).lseries(x):
      print term</p>
<p>The advantage of lseries() over nseries() is that many times you are
just interested in the next term in the series (i.e. the first term for
example), but you do not know how many you should ask for in nseries()
using the "n" parameter.</p>
<p>See also nseries().</p>
<h4 id="match_3">match</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code>None</code> when expression (self) does not match with pattern.
Otherwise return a dictionary such that::</p>
<p>pattern.xreplace(self.match(pattern)) == self</p>
<h1 id="examples_165">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Wild, Sum
from sympy.abc import x, y
p = Wild("p")
q = Wild("q")
r = Wild("r")
e = (x+y)<strong>(x+y)
e.match(p</strong>p)
{p_: x + y}
e.match(p<strong>q)
{p_: x + y, q_: x + y}
e = (2*x)</strong>2
e.match(p<em>q</em><em>r)
{p_: 4, q_: x, r_: 2}
(p</em>q<strong>r).xreplace(e.match(p*q</strong>r))
4<em>x</em>*2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since match is purely structural expressions that are equivalent up to
bound symbols will not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p))))
None</p>
</blockquote>
</blockquote>
</blockquote>
<p>An expression with bound symbols can be matched if the pattern uses
a distinct <code>Wild</code> for each bound symbol:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))
{p_: 2, q_: x}</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>old</code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the match. Both
of the following give None unless <code>old=True</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x - 2).match(p - x, old=True)
{p_: 2<em>x - 2}
(2/x).match(p</em>x, old=True)
{p_: 2/x**2}</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_51">See Also</h1>
<p>matches: pattern.matches(expr) is the same as expr.match(pattern)
xreplace: exact structural replacement
replace: structural replacement with pattern matching
Wild: symbolic placeholders for expressions in pattern matching</p>
<h4 id="matches_3">matches</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">matches</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">,</span>
    <span class="n">repl_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Helper method for match() that looks for a match between Wild symbols</p>
<p>in self and expressions in expr.</p>
<h1 id="examples_166">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Wild, Basic
a, b, c = symbols('a b c')
x = Wild('x')
Basic(a + x, x).matches(Basic(a + b, c)) is None
True
Basic(a + x, x).matches(Basic(a + b + c, b + c))
{x_: b + c}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="n_3">n</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_20">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_22">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="normal_3">normal</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">normal</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression as a fraction.</p>
<p>expression -&gt; a/b</p>
<h1 id="see-also_52">See Also</h1>
<p>as_numer_denom: return <code>(a, b)</code> instead of <code>a/b</code></p>
<h4 id="nseries_3">nseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>
<p>If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
called. This calculates "n" terms in the innermost expressions and
then builds up the final series just by "cross-multiplying" everything
out.</p>
<p>The optional <code>logx</code> parameter can be used to replace any log(x) in the
returned series with a symbolic value to avoid evaluating log(x) at 0. A
symbol to use in place of log(x) should be provided.</p>
<p>Advantage -- it's fast, because we do not have to determine how many
terms we need to calculate in advance.</p>
<p>Disadvantage -- you may end up with less terms than you may have
expected, but the O(x**n) term appended will always be correct and
so the result, though perhaps shorter, will also be correct.</p>
<p>If any of those assumptions is not met, this is treated like a
wrapper to series which will try harder to return the correct
number of terms.</p>
<p>See also lseries().</p>
<h1 id="examples_167">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, log, Symbol
from sympy.abc import x, y
sin(x).nseries(x, 0, 6)
x - x<strong>3/6 + x</strong>5/120 + O(x<strong>6)
log(x+1).nseries(x, 0, 5)
x - x</strong>2/2 + x<strong>3/3 - x</strong>4/4 + O(x**5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Handling of the <code>logx</code> parameter --- in the following example the
expansion fails since <code>sin</code> does not have an asymptotic expansion
at -oo (the limit of log(x) as x approaches 0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = sin(log(x))
e.nseries(x, 0, 6)
Traceback (most recent call last):
...
PoleError: ...
...
logx = Symbol('logx')
e.nseries(x, 0, 6, logx=logx)
sin(logx)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the following example, the expansion works but only returns self
unless the <code>logx</code> parameter is used:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>y
e.nseries(x, 0, 2)
x</strong>y
e.nseries(x, 0, 2, logx=logx)
exp(logx*y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="nsimplify_3">nsimplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nsimplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">constants</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the nsimplify function in sympy.simplify</p>
<h4 id="powsimp_3">powsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">powsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the powsimp function in sympy.simplify</p>
<h4 id="primitive_3">primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">primitive</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Number, Expr]&#39;</span>
</code></pre></div>
<p>Return the positive Rational that can be extracted non-recursively</p>
<p>from every term of self (i.e., self is treated like an Add). This is
like the as_coeff_Mul() method but primitive always extracts a positive
Rational (never a negative or a Float).</p>
<h1 id="examples_168">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(3<em>(x + 1)</em><em>2).primitive()
(3, (x + 1)</em><em>2)
a = (6</em>x + 2); a.primitive()
(2, 3<em>x + 1)
b = (x/2 + 3); b.primitive()
(1/2, x + 6)
(a</em>b).primitive() == (1, a*b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="radsimp_3">radsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">radsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the radsimp function in sympy.simplify</p>
<h4 id="ratsimp_3">ratsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">ratsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the ratsimp function in sympy.simplify</p>
<h4 id="rcall_3">rcall</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rcall</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance, in SymPy the following will not work:</p>
<p><code>(x+Lambda(y, 2*y))(z) == x+2*z</code>,</p>
<p>however, you can use:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x, y, z
(x + Lambda(y, 2<em>y)).rcall(z)
x + 2</em>z</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="refine_3">refine</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">refine</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">assumption</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the refine function in sympy.assumptions</p>
<h4 id="removeo_3">removeO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">removeO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr&#39;</span>
</code></pre></div>
<p>Removes the additive O(..) symbol if there is one</p>
<h4 id="replace_3">replace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="nb">map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Replace matching subexpressions of <code>self</code> with <code>value</code>.</p>
<p>If <code>map = True</code> then also return the mapping {old: new} where <code>old</code>
was a sub-expression found with query and <code>new</code> is the replacement
value for it. If the expression itself does not match the query, then
the returned value will be <code>self.xreplace(map)</code> otherwise it should
be <code>self.subs(ordered(map.items()))</code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code>simultaneous</code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code>exact</code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<h1 id="examples_169">Examples</h1>
<p>Initial setup</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import log, sin, cos, tan, Wild, Mul, Add
from sympy.abc import x, y
f = log(sin(x)) + tan(sin(x**2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>1.1. type -&gt; type
    obj.replace(type, newtype)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, replace it with the
result of passing its argument(s) to ``newtype``.

&gt;&gt;&gt; f.replace(sin, cos)
log(cos(x)) + tan(cos(x**2))
&gt;&gt;&gt; sin(x).replace(sin, cos, map=True)
(cos(x), {sin(x): cos(x)})
&gt;&gt;&gt; (x*y).replace(Mul, Add)
x + y
</code></pre></div>
<p>1.2. type -&gt; func
    obj.replace(type, func)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, apply ``func`` to its
argument(s). ``func`` must be written to handle the number
of arguments of ``type``.

&gt;&gt;&gt; f.replace(sin, lambda arg: sin(2*arg))
log(sin(2*x)) + tan(sin(2*x**2))
&gt;&gt;&gt; (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))
sin(2*x*y)
</code></pre></div>
<p>2.1. pattern -&gt; expr
    obj.replace(pattern(wild), expr(wild))</p>
<div class="highlight"><pre><span></span><code>Replace subexpressions matching ``pattern`` with the expression
written in terms of the Wild symbols in ``pattern``.

&gt;&gt;&gt; a, b = map(Wild, &#39;ab&#39;)
&gt;&gt;&gt; f.replace(sin(a), tan(a))
log(tan(x)) + tan(tan(x**2))
&gt;&gt;&gt; f.replace(sin(a), tan(a/2))
log(tan(x/2)) + tan(tan(x**2/2))
&gt;&gt;&gt; f.replace(sin(a), a)
log(x) + tan(x**2)
&gt;&gt;&gt; (x*y).replace(a*x, a)
y

Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:

&gt;&gt;&gt; (2*x + y).replace(a*x + b, b - a)
y - 2
&gt;&gt;&gt; (2*x).replace(a*x + b, b - a)
2*x

When set to False, the results may be non-intuitive:

&gt;&gt;&gt; (2*x).replace(a*x + b, b - a, exact=False)
2/x
</code></pre></div>
<p>2.2. pattern -&gt; func
    obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<div class="highlight"><pre><span></span><code>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:

&gt;&gt;&gt; f.replace(sin(a), lambda a: sin(2*a))
log(sin(2*x)) + tan(sin(2*x**2))
</code></pre></div>
<p>3.1. func -&gt; func
    obj.replace(filter, func)</p>
<div class="highlight"><pre><span></span><code>Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``
is True.

&gt;&gt;&gt; g = 2*sin(x**3)
&gt;&gt;&gt; g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)
4*sin(x**9)
</code></pre></div>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; e = x*(x*y + 1)
&gt;&gt;&gt; e.replace(lambda x: x.is_Mul, lambda x: 2*x)
2*x*(2*x*y + 1)
</code></pre></div>
<p>When matching a single symbol, <code>exact</code> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <code>exact=False</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
f = Function('f')
e = f(1) + f(0)
q = f(a), lambda a: f(a + 1)
e.replace(<em>q, exact=False)
f(1) + f(2)
e.replace(</em>q, exact=True)
f(0) + f(2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>(1 + y)
(x</strong>(1 + y)).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=False)
x
(x<strong>(1 + y)).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=True)
x</strong>(-x - y + 1)
(x<strong>y).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=False)
x
(x</strong>y).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=True)
x**(1 - y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x<strong>(1 + y)).replace(
... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,
... lambda x: x.base</strong>(1 - (x.exp - 1)))
...
x**(1 - y) + 1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_53">See Also</h1>
<p>subs: substitution of subexpressions as defined by the objects
      themselves.
xreplace: exact node replacement in expr tree; also capable of
          using matching rules</p>
<h4 id="rewrite_3">rewrite</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rewrite</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrite <em>self</em> using a defined rule.</p>
<p>Rewriting transforms an expression to another, which is mathematically
equivalent but structurally different. For example you can rewrite
trigonometric functions as complex exponentials or combinatorial
functions as gamma function.</p>
<p>This method takes a <em>pattern</em> and a <em>rule</em> as positional arguments.
<em>pattern</em> is optional parameter which defines the types of expressions
that will be transformed. If it is not passed, all possible expressions
will be rewritten. <em>rule</em> defines how the expression will be rewritten.</p>
<h1 id="parameters_21">Parameters</h1>
<p>args : Expr
    A <em>rule</em>, or <em>pattern</em> and <em>rule</em>.
    - <em>pattern</em> is a type or an iterable of types.
    - <em>rule</em> can be any object.</p>
<p>deep : bool, optional
    If <code>True</code>, subexpressions are recursively transformed. Default is
    <code>True</code>.</p>
<h1 id="examples_170">Examples</h1>
<p>If <em>pattern</em> is unspecified, all possible expressions are transformed.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, exp, I
from sympy.abc import x
expr = cos(x) + I<em>sin(x)
expr.rewrite(exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Pattern can be a type or an iterable of types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.rewrite(sin, exp)
exp(I<em>x)/2 + cos(x) - exp(-I</em>x)/2
expr.rewrite([cos,], exp)
exp(I<em>x)/2 + I</em>sin(x) + exp(-I<em>x)/2
expr.rewrite([cos, sin], exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Rewriting behavior can be implemented by defining <code>_eval_rewrite()</code>
method.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Expr, sqrt, pi
class MySin(Expr):
...     def _eval_rewrite(self, rule, args, <strong>hints):
...         x, = args
...         if rule == cos:
...             return cos(pi/2 - x, evaluate=False)
...         if rule == sqrt:
...             return sqrt(1 - cos(x)</strong>2)
MySin(MySin(x)).rewrite(cos)
cos(-cos(-x + pi/2) + pi/2)
MySin(x).rewrite(sqrt)
sqrt(1 - cos(x)**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Defining <code>_eval_rewrite_as_[...]()</code> method is supported for backwards
compatibility reason. This may be removed in the future and using it is
discouraged.</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MySin(Expr):
...     def _eval_rewrite_as_cos(self, <em>args, </em>*hints):
...         x, = args
...         return cos(pi/2 - x, evaluate=False)
MySin(x).rewrite(cos)
cos(-x + pi/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="round_3">round</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return x rounded to the given decimal place.</p>
<p>If a complex number would results, apply round to the real
and imaginary components of the number.</p>
<h1 id="examples_171">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, E, I, S, Number
pi.round()
3
pi.round(2)
3.14
(2<em>pi + E</em>I).round()
6 + 3*I</p>
</blockquote>
</blockquote>
</blockquote>
<p>The round method has a chopping effect:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>pi + I/10).round()
6
(pi/10 + 2</em>I).round()
2<em>I
(pi/10 + E</em>I).round(2)
0.31 + 2.72*I</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_23">Notes</h1>
<p>The Python <code>round</code> function uses the SymPy <code>round</code> method so it
will always return a SymPy number (not a Python float or int):</p>
<blockquote>
<blockquote>
<blockquote>
<p>isinstance(round(S(123), -2), Number)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="separate_3">separate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">separate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">force</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the separate function in sympy.simplify</p>
<h4 id="series_3">series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Series expansion of "self" around <code>x = x0</code> yielding either terms of</p>
<p>the series one by one (the lazy series given when n=None), else
all the terms at once when n != None.</p>
<p>Returns the series expansion of "self" around the point <code>x = x0</code>
with respect to <code>x</code> up to <code>O((x - x0)**n, x, x0)</code> (default n is 6).</p>
<p>If <code>x=None</code> and <code>self</code> is univariate, the univariate symbol will
be supplied, otherwise an error will be raised.</p>
<h1 id="parameters_22">Parameters</h1>
<p>expr : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>x0 : Value
     The value around which <code>x</code> is calculated. Can be any value
     from <code>-oo</code> to <code>oo</code>.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>dir : String, optional
      The series-expansion can be bi-directional. If <code>dir="+"</code>,
      then (x-&gt;x0+). If <code>dir="-", then (x-&gt;x0-). For infinite</code>x0<code>(</code>oo<code>or</code>-oo<code>), the</code>dir<code>argument is determined
      from the direction of the infinity (i.e.,</code>dir="-"<code>for</code>oo``).</p>
<p>logx : optional
       It is used to replace any log(x) in the returned series with a
       symbolic value rather than evaluating the actual value.</p>
<p>cdir : optional
       It stands for complex direction, and indicates the direction
       from which the expansion needs to be evaluated.</p>
<h1 id="examples_172">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, exp, tan
from sympy.abc import x, y
cos(x).series()
1 - x<strong>2/2 + x</strong>4/24 + O(x<strong>6)
cos(x).series(n=4)
1 - x</strong>2/2 + O(x<strong>4)
cos(x).series(x, x0=1, n=2)
cos(1) - (x - 1)*sin(1) + O((x - 1)</strong>2, (x, 1))
e = cos(x + exp(y))
e.series(y, n=2)
cos(x + 1) - y<em>sin(x + 1) + O(y</em><em>2)
e.series(x, n=2)
cos(exp(y)) - x</em>sin(exp(y)) + O(x**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>n=None</code> then a generator of the series terms will be returned.</p>
<blockquote>
<blockquote>
<blockquote>
<p>term=cos(x).series(n=None)
[next(term) for i in range(2)]
[1, -x**2/2]</p>
</blockquote>
</blockquote>
</blockquote>
<p>For <code>dir=+</code> (default) the series is calculated from the right and
for <code>dir=-</code> the series from the left. For smooth functions this
flag will not alter the results.</p>
<blockquote>
<blockquote>
<blockquote>
<p>abs(x).series(dir="+")
x
abs(x).series(dir="-")
-x
f = tan(x)
f.series(x, 2, 6, "+")
tan(2) + (1 + tan(2)<strong>2)*(x - 2) + (x - 2)</strong>2<em>(tan(2)</em><em>3 + tan(2)) +
(x - 2)</em><em>3</em>(1/3 + 4<em>tan(2)</em><em>2/3 + tan(2)</em><em>4) + (x - 2)</em><em>4</em>(tan(2)<strong>5 +
5*tan(2)</strong>3/3 + 2<em>tan(2)/3) + (x - 2)</em><em>5</em>(2/15 + 17<em>tan(2)</em><em>2/15 +
2</em>tan(2)<strong>4 + tan(2)</strong>6) + O((x - 2)**6, (x, 2))</p>
<p>f.series(x, 2, 3, "-")
tan(2) + (2 - x)<em>(-tan(2)</em><em>2 - 1) + (2 - x)</em><em>2</em>(tan(2)<strong>3 + tan(2))
+ O((x - 2)</strong>3, (x, 2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).series(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_10">Returns</h1>
<p>Expr : Expression
    Series expansion of the expression about x0</p>
<h1 id="raises_3">Raises</h1>
<p>TypeError
    If "n" and "x0" are infinity objects</p>
<p>PoleError
    If "x0" is an infinity object</p>
<h4 id="simplify_3">simplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>See the simplify function in sympy.simplify</p>
<h4 id="sort_key_3">sort_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sort_key</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a sort key.</p>
<h1 id="examples_173">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S, I</p>
<p>sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())
[1/2, -I, I]</p>
<p>S("[x, 1/x, 1/x<strong>2, x</strong>2, x<strong>(1/2), x</strong>(1/4), x<strong>(3/2)]")
[x, 1/x, x</strong>(-2), x<strong>2, sqrt(x), x</strong>(1/4), x<strong>(3/2)]
sorted(_, key=lambda x: x.sort_key())
[x</strong>(-2), 1/x, x<strong>(1/4), sqrt(x), x, x</strong>(3/2), x**2]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="subs_3">subs</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">subs</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">arg1</span><span class="p">:</span> <span class="s1">&#39;Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex&#39;</span><span class="p">,</span>
    <span class="n">arg2</span><span class="p">:</span> <span class="s1">&#39;Basic | complex | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Substitutes old for new in an expression after sympifying args.</p>
<p><code>args</code> is either:
  - two arguments, e.g. foo.subs(old, new)
  - one iterable argument, e.g. foo.subs(iterable). The iterable may be
     o an iterable container with (old, new) pairs. In this case the
       replacements are processed in the order given with successive
       patterns possibly affecting replacements already made.
     o a dict or set whose key/value items correspond to old/new pairs.
       In this case the old/new pairs will be sorted by op count and in
       case of a tie, by number of args and the default_sort_key. The
       resulting sorted list is then processed as an iterable container
       (see previous).</p>
<p>If the keyword <code>simultaneous</code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<h1 id="examples_174">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, exp, limit, oo
from sympy.abc import x, y
(1 + x<em>y).subs(x, pi)
pi</em>y + 1
(1 + x<em>y).subs({x:pi, y:2})
1 + 2</em>pi
(1 + x<em>y).subs([(x, pi), (y, 2)])
1 + 2</em>pi
reps = [(y, x<strong>2), (x, 2)]
(x + y).subs(reps)
6
(x + y).subs(reversed(reps))
x</strong>2 + 2</p>
<p>(x<strong>2 + x</strong>4).subs(x<strong>2, y)
y</strong>2 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To replace only the x<strong>2 but not the x</strong>4, use xreplace:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<strong>2 + x</strong>4).xreplace({x<strong>2: y})
x</strong>4 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code>simultaneous</code> to True:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/y).subs([(x, 0), (y, 0)])
0
(x/y).subs([(x, 0), (y, 0)], simultaneous=True)
nan</p>
</blockquote>
</blockquote>
</blockquote>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((x + y)/y).subs({x + y: y, y: x + y})
1
((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
y/(x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, sin, cos
from sympy.abc import a, b, c, d, e</p>
<p>A = (sqrt(sin(2<em>x)), a)
B = (sin(2</em>x), b)
C = (cos(2*x), c)
D = (x, d)
E = (exp(x), e)</p>
<p>expr = sqrt(sin(2<em>x))</em>sin(exp(x)<em>x)</em>cos(2<em>x) + sin(2</em>x)</p>
<p>expr.subs(dict([A, B, C, D, E]))
a<em>c</em>sin(d*e) + b</p>
</blockquote>
</blockquote>
</blockquote>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*<em>3 - 3</em>x).subs({x: oo})
nan</p>
<p>limit(x*<em>3 - 3</em>x, x, oo)
oo</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).evalf(subs={x: 3.0}, n=21)
0.333333333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<p>rather than</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).subs({x: 3.0}).evalf(21)
0.333333333333333314830</p>
</blockquote>
</blockquote>
</blockquote>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
<h1 id="see-also_54">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
xreplace: exact node replacement in expr tree; also capable of
          using matching rules
sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision</p>
<h4 id="taylor_term_3">taylor_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">taylor_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="o">*</span><span class="n">previous_terms</span>
<span class="p">)</span>
</code></pre></div>
<p>General method for the taylor term.</p>
<p>This method is slow, because it differentiates n-times. Subclasses can
redefine it to make it faster by using the "previous_terms".</p>
<h4 id="to_nnf_3">to_nnf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_nnf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="together_3">together</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">together</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the together function in sympy.polys</p>
<h4 id="transpose_3">transpose</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="trigsimp_3">trigsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">trigsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the trigsimp function in sympy.simplify</p>
<h4 id="xreplace_3">xreplace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">xreplace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rule</span><span class="p">,</span>
    <span class="n">hack2</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Replace occurrences of objects within the expression.</p>
<h1 id="parameters_23">Parameters</h1>
<p>rule : dict-like
    Expresses a replacement rule</p>
<h1 id="returns_11">Returns</h1>
<p>xreplace : the result of the replacement</p>
<h1 id="examples_175">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, pi, exp
x, y, z = symbols('x y z')
(1 + x<em>y).xreplace({x: pi})
pi</em>y + 1
(1 + x<em>y).xreplace({x: pi, y: 2})
1 + 2</em>pi</p>
</blockquote>
</blockquote>
</blockquote>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>y + z).xreplace({x</em>y: pi})
z + pi
(x<em>y</em>z).xreplace({x<em>y: pi})
x</em>y<em>z
(2</em>x).xreplace({2<em>x: y, x: z})
y
(2</em>2<em>x).xreplace({2</em>x: y, x: z})
4*z
(x + y + 2).xreplace({x + y: 2})
x + y + 2
(x + 2 + exp(x + 2)).xreplace({x + 2: y})
x + exp(y) + 2</p>
</blockquote>
</blockquote>
</blockquote>
<p>xreplace does not differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
Integral(x, (x, 1, 2<em>x)).xreplace({x: y})
Integral(y, (y, 1, 2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Trying to replace x with an expression raises an error:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Integral(x, (x, 1, 2<em>x)).xreplace({x: 2</em>y}) # doctest: +SKIP
ValueError: Invalid limits given: ((2<em>y, 1, 4</em>y),)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_55">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
subs: substitution of subexpressions as defined by the objects
      themselves.</p>
<h3 id="step">Step</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Step</span><span class="p">(</span>
    <span class="n">workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">task</span><span class="p">:</span> <span class="s1">&#39;Task | Workflow&#39;</span><span class="p">,</span>
    <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Mapping[str, Reference[Any] | Raw]&#39;</span><span class="p">,</span>
    <span class="n">raw_as_parameter</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Regular step.</p>
<h4 id="ancestors-in-mro_10">Ancestors (in MRO)</h4>
<ul>
<li>dewret.workflow.BaseStep</li>
<li>dewret.core.WorkflowComponent</li>
</ul>
<h4 id="descendants_4">Descendants</h4>
<ul>
<li>dewret.workflow.FactoryCall</li>
</ul>
<h4 id="class-variables_7">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">positional_args</span>
</code></pre></div>
<h4 id="instance-variables_8">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="nb">id</span>
</code></pre></div>
<p>Consistent ID based on the value.</p>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Name for this step.</p>
<p>May be remapped by the workflow to something nicer
than the ID.</p>
<div class="highlight"><pre><span></span><code><span class="n">return_type</span>
</code></pre></div>
<p>Take the type of the wrapped function from the target.</p>
<p>Unwraps and inspects the signature, meaning that the original
wrapped function <em>must</em> have a typehint for the return value.</p>
<h4 id="methods_8">Methods</h4>
<h4 id="make_reference_4">make_reference</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_reference</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;&#39;StepReference[T]&#39;&quot;</span>
</code></pre></div>
<p>Create a reference to this step.</p>
<p>Builds a reference to the (result of) this step, which will be iterable if appropriate.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>arguments for reference constructor, which will be supplemented appropriately.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="set_workflow_3">set_workflow</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set_workflow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">workflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">with_arguments</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;None&#39;</span>
</code></pre></div>
<p>Move the step reference to another workflow.</p>
<p>This method is primarily intended to be called by a step, allowing it to
switch to a new workflow. It also updates the workflow reference for any
arguments that are steps themselves, if specified.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>workflow</td>
<td>None</td>
<td>The new target workflow to which the step should be moved.</td>
<td>None</td>
</tr>
<tr>
<td>with_arguments</td>
<td>None</td>
<td>If True, also update the workflow reference for the step's arguments.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h3 id="stepreference">StepReference</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">StepReference</span><span class="p">(</span>
    <span class="n">step</span><span class="p">:</span> <span class="s1">&#39;BaseStep&#39;</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
    <span class="n">typ</span><span class="p">:</span> <span class="s1">&#39;type[U] | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Reference to an individual <code>Step</code>.</p>
<p>Allows us to refer to the outputs of a <code>Step</code> in subsequent <code>Step</code>
arguments.</p>
<h4 id="attributes_4">Attributes</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>_</td>
<td>None</td>
<td>metadata wrapping the <code>Step</code> referred to.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="ancestors-in-mro_11">Ancestors (in MRO)</h4>
<ul>
<li>dewret.workflow.FieldableMixin</li>
<li>dewret.core.Reference</li>
<li>typing.Generic</li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.printing.defaults.Printable</li>
<li>sympy.core.evalf.EvalfMixin</li>
<li>dewret.core.WorkflowComponent</li>
</ul>
<h4 id="descendants_5">Descendants</h4>
<ul>
<li>dewret.workflow.IterableStepReference</li>
</ul>
<h4 id="class-variables_8">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">StepReferenceMetadata</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">default_assumptions</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Add</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_AlgebraicNumber</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Atom</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Boolean</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Derivative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Dummy</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Equality</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Float</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Function</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Indexed</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatAdd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_MatMul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Matrix</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Mul</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Not</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_NumberSymbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Order</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Piecewise</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Point</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Poly</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Pow</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Relational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Symbol</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Vector</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_Wild</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_comparable</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_number</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_scalar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_symbol</span>
</code></pre></div>
<h4 id="static-methods_4">Static methods</h4>
<h4 id="class_key_4">class_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">class_key</span><span class="p">(</span>
    
<span class="p">)</span>
</code></pre></div>
<p>Nice order of classes.</p>
<h4 id="fromiter_4">fromiter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fromiter</span><span class="p">(</span>
    <span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<p>Create a new object from an iterable.</p>
<p>This is a convenience function that allows one to create objects from
any iterable, without having to convert to a list or tuple first.</p>
<h1 id="examples_176">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Tuple
Tuple.fromiter(i for i in range(5))
(0, 1, 2, 3, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="instance-variables_9">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">args</span>
</code></pre></div>
<p>Returns a tuple of arguments of 'self'.</p>
<h1 id="examples_177">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cot
from sympy.abc import x, y</p>
<p>cot(x).args
(x,)</p>
<p>cot(x).args[0]
x</p>
<p>(x*y).args
(x, y)</p>
<p>(x*y).args[1]
y</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_24">Notes</h1>
<p>Never use self._args, always use self.args.
Only use _args in <strong>new</strong> when creating a new function.
Do not override .args() from Basic (so that it is easy to
change the interface in the future if needed).</p>
<div class="highlight"><pre><span></span><code><span class="n">assumptions0</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">binary_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">canonical_variables</span>
</code></pre></div>
<p>Return a dictionary mapping any variable defined in</p>
<p><code>self.bound_symbols</code> to Symbols that do not clash
with any free symbols in the expression.</p>
<h1 id="examples_178">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x
Lambda(x, 2*x).canonical_variables
{x: _0}</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">expr_free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">free_symbols</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">func</span>
</code></pre></div>
<p>The top-level function in an expression.</p>
<p>The following should hold for all objects::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt; x == x.func(*x.args)
</code></pre></div>
<h1 id="examples_179">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
a = 2<em>x
a.func
<class 'sympy.core.mul.Mul'>
a.args
(2, x)
a.func(</em>a.args)
2<em>x
a == a.func(</em>a.args)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">is_algebraic</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_antihermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_commutative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_complex</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_composite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_even</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_extended_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_finite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_hermitian</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_imaginary</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_infinite</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_integer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_irrational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_negative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_noninteger</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonnegative</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonpositive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_nonzero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_odd</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_polar</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_positive</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_prime</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_rational</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_real</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_transcendental</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">is_zero</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">kind</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Printable name of the reference.</p>
<h4 id="methods_9">Methods</h4>
<h4 id="adjoint_4">adjoint</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">adjoint</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="apart_4">apart</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apart</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the apart function in sympy.polys</p>
<h4 id="args_cnc_4">args_cnc</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">args_cnc</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">split_1</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Return [commutative factors, non-commutative factors] of self.</p>
<h1 id="explanation_24">Explanation</h1>
<p>self is treated as a Mul and the ordering of the factors is maintained.
If <code>cset</code> is True the commutative factors will be returned in a set.
If there were repeated factors (as may happen with an unevaluated Mul)
then an error will be raised unless it is explicitly suppressed by
setting <code>warn</code> to False.</p>
<p>Note: -1 is always separated from a Number unless split_1 is False.</p>
<h1 id="examples_180">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, oo
A, B = symbols('A B', commutative=0)
x, y = symbols('x y')
(-2<em>x</em>y).args_cnc()
[[-1, 2, x, y], []]
(-2.5<em>x).args_cnc()
[[-1, 2.5, x], []]
(-2</em>x<em>A</em>B<em>y).args_cnc()
[[-1, 2, x, y], [A, B]]
(-2</em>x<em>A</em>B<em>y).args_cnc(split_1=False)
[[-2, x, y], [A, B]]
(-2</em>x*y).args_cnc(cset=True)
[{-1, 2, x, y}, []]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The arg is always treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-2 + x + A).args_cnc()
[[], [x - 2 + A]]
(-oo).args_cnc() # -oo is a singleton
[[-1, oo], []]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_base_exp_4">as_base_exp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_base_exp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<h4 id="as_coeff_add_8">as_coeff_Add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a summation.</p>
<h4 id="as_coeff_mul_8">as_coeff_Mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_Mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rational</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;tuple[&#39;Number&#39;, Expr]&quot;</span>
</code></pre></div>
<p>Efficiently extract the coefficient of a product.</p>
<h4 id="as_coeff_add_9">as_coeff_add</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as an Add, <code>a</code>.</p>
<p>c should be a Rational added to any terms of the Add that are
independent of deps.</p>
<p>args should be a tuple of all other terms of <code>a</code>; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is an Add or not but
you want to treat self as an Add or if you want to process the
individual arguments of the tail of self as an Add.</p>
<ul>
<li>if you know self is an Add and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail.</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_add()
(3, ())
(3 + x).as_coeff_add()
(3, (x,))
(3 + x + y).as_coeff_add(x)
(y + 3, (x,))
(3 + y).as_coeff_add(x)
(y + 3, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coeff_exponent_4">as_coeff_exponent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_exponent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p><code>c*x**e -&gt; c,e</code> where x can be any symbolic expression.</p>
<h4 id="as_coeff_mul_9">as_coeff_mul</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coeff_mul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, tuple[Expr, ...]]&#39;</span>
</code></pre></div>
<p>Return the tuple (c, args) where self is written as a Mul, <code>m</code>.</p>
<p>c should be a Rational multiplied by any factors of the Mul that are
independent of deps.</p>
<p>args should be a tuple of all other factors of m; args is empty
if self is a Number or if self is independent of deps (when given).</p>
<p>This should be used when you do not know if self is a Mul or not but
you want to treat self as a Mul or if you want to process the
individual arguments of the tail of self as a Mul.</p>
<ul>
<li>if you know self is a Mul and want only the head, use self.args[0];</li>
<li>if you do not want to process the arguments of the tail but need the
  tail then use self.as_two_terms() which gives the head and tail;</li>
<li>if you want to split self into an independent and dependent parts
  use <code>self.as_independent(*deps)</code></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
from sympy.abc import x, y
(S(3)).as_coeff_mul()
(3, ())
(3<em>x</em>y).as_coeff_mul()
(3, (x, y))
(3<em>x</em>y).as_coeff_mul(x)
(3<em>y, (x,))
(3</em>y).as_coeff_mul(x)
(3*y, ())</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_coefficient_4">as_coefficient</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Extracts symbolic coefficient at the given expression. In</p>
<p>other words, this functions separates 'self' into the product
of 'expr' and 'expr'-free coefficient. If such separation
is not possible it will return None.</p>
<h1 id="examples_181">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import E, pi, sin, I, Poly
from sympy.abc import x</p>
<p>E.as_coefficient(E)
1
(2<em>E).as_coefficient(E)
2
(2</em>sin(E)*E).as_coefficient(E)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two terms have E in them so a sum is returned. (If one were
desiring the coefficient of the term exactly matching E then
the constant from the returned expression could be selected.
Or, for greater precision, a method of Poly can be used to
indicate the desired term from which the coefficient is
desired.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E + x</em>E).as_coefficient(E)
x + 2
_.args[0]  # just want the exact match
2
p = Poly(2<em>E + x</em>E); p
Poly(x<em>E + 2</em>E, x, E, domain='ZZ')
p.coeff_monomial(E)
2
p.nth(0, 1)
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since the following cannot be written as a product containing
E as a factor, None is returned. (If the coefficient <code>2*x</code> is
desired then the <code>coeff</code> method should be used.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>E</em>x + x).as_coefficient(E)
(2<em>E</em>x + x).coeff(E)
2*x</p>
<p>(E*(x + 1) + x).as_coefficient(E)</p>
<p>(2<em>pi</em>I).as_coefficient(pi<em>I)
2
(2</em>I).as_coefficient(pi*I)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_56">See Also</h1>
<p>coeff: return sum of terms have a given factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="as_coefficients_dict_4">as_coefficients_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_coefficients_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a dictionary mapping terms to their Rational coefficient.</p>
<p>Since the dictionary is a defaultdict, inquiries about terms which
were not present will return a coefficient of 0.</p>
<p>If symbols <code>syms</code> are provided, any multiplicative terms
independent of them will be considered a coefficient and a
regular dictionary of syms-dependent generators as keys and
their corresponding coefficients as values will be returned.</p>
<h1 id="examples_182">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import a, x, y
(3<em>x + a</em>x + 4).as_coefficients_dict()
{1: 4, x: 3, a<em>x: 1}
_[a]
0
(3</em>a<em>x).as_coefficients_dict()
{a</em>x: 3}
(3<em>a</em>x).as_coefficients_dict(x)
{x: 3<em>a}
(3</em>a<em>x).as_coefficients_dict(y)
{1: 3</em>a*x}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_content_primitive_4">as_content_primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_content_primitive</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">radical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">clear</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>This method should recursively remove a Rational from all arguments</p>
<p>and return that (content) and the new self (primitive). The content
should always be positive and <code>Mul(*foo.as_content_primitive()) == foo</code>.
The primitive need not be in canonical form and should try to preserve
the underlying structure if possible (i.e. expand_mul should not be
applied to self).</p>
<h1 id="examples_183">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt
from sympy.abc import x, y, z</p>
<p>eq = 2 + 2<em>x + 2</em>y<em>(3 + 3</em>y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The as_content_primitive function is recursive and retains structure:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eq.as_content_primitive()
(2, x + 3<em>y</em>(y + 1) + 1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Integer powers will have Rationals extracted from the base:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((2 + 6<em>x)</em><em>2).as_content_primitive()
(4, (3</em>x + 1)<strong>2)
((2 + 6*x)</strong>(2<em>y)).as_content_primitive()
(1, (2</em>(3<em>x + 1))</em><em>(2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Terms may end up joining once their as_content_primitives are added:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((5<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(11, x</em>(y + 1))
((3<em>(x</em>(1 + y)) + 2<em>x</em>(3 + 3<em>y))).as_content_primitive()
(9, x</em>(y + 1))
((3<em>(z</em>(1 + y)) + 2.0<em>x</em>(3 + 3<em>y))).as_content_primitive()
(1, 6.0</em>x<em>(y + 1) + 3</em>z<em>(y + 1))
((5</em>(x<em>(1 + y)) + 2</em>x<em>(3 + 3</em>y))<strong>2).as_content_primitive()
(121, x</strong>2<em>(y + 1)</em><em>2)
((x</em>(1 + y) + 0.4<em>x</em>(3 + 3<em>y))</em><em>2).as_content_primitive()
(1, 4.84</em>x<strong>2*(y + 1)</strong>2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Radical content can also be factored out of the primitive:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>sqrt(2) + 4</em>sqrt(10)).as_content_primitive(radical=True)
(2, sqrt(2)<em>(1 + 2</em>sqrt(5)))</p>
</blockquote>
</blockquote>
</blockquote>
<p>If clear=False (default is True) then content will not be removed
from an Add if it can be distributed to leave one or more
terms with integer coefficients.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/2 + y).as_content_primitive()
(1/2, x + 2*y)
(x/2 + y).as_content_primitive(clear=False)
(1, x/2 + y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_dummy_4">as_dummy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_dummy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression with any objects having structurally</p>
<p>bound symbols replaced with unique, canonical symbols within
the object in which they appear and having only the default
assumption for commutativity being True. When applied to a
symbol a new symbol having only the same commutativity will be
returned.</p>
<h1 id="examples_184">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Symbol
from sympy.abc import x
r = Symbol('r', real=True)
Integral(r, (r, x)).as_dummy()
Integral(<em>0, (_0, x))
</em>.variables[0].is_real is None
True
r.as_dummy()
_r</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_25">Notes</h1>
<p>Any object that has structurally bound variables should have
a property, <code>bound_symbols</code> that returns those symbols
appearing in the object.</p>
<h4 id="as_expr_4">as_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span>
<span class="p">)</span>
</code></pre></div>
<p>Convert a polynomial to a SymPy expression.</p>
<h1 id="examples_185">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>f = (x<strong>2 + x*y).as_poly(x, y)
f.as_expr()
x</strong>2 + x*y</p>
<p>sin(x).as_expr()
sin(x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_independent_4">as_independent</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_independent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">deps</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hint</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>A mostly naive separation of a Mul or Add into arguments that are not</p>
<p>are dependent on deps. To obtain as complete a separation of variables
as possible, use a separation method first, e.g.:</p>
<ul>
<li>separatevars() to change Mul, Add and Pow (including exp) into Mul</li>
<li>.expand(mul=True) to change Add or Mul into Add</li>
<li>.expand(log=True) to change log expr into an Add</li>
</ul>
<p>The only non-naive thing that is done here is to respect noncommutative
ordering of variables and to always return (0, 0) for <code>self</code> of zero
regardless of hints.</p>
<p>For nonzero <code>self</code>, the returned tuple (i, d) has the
following interpretation:</p>
<ul>
<li>i will has no variable that appears in deps</li>
<li>d will either have terms that contain variables that are in deps, or
  be equal to 0 (when self is an Add) or 1 (when self is a Mul)</li>
<li>if self is an Add then self = i + d</li>
<li>if self is a Mul then self = i*d</li>
<li>otherwise (self, S.One) or (S.One, self) is returned.</li>
</ul>
<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>
<h1 id="examples_186">Examples</h1>
<p>-- self is an Add</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos, exp
from sympy.abc import x, y, z</p>
<p>(x + x<em>y).as_independent(x)
(0, x</em>y + x)
(x + x<em>y).as_independent(y)
(x, x</em>y)
(2<em>x</em>sin(x) + y + x + z).as_independent(x)
(y + z, 2<em>x</em>sin(x) + x)
(2<em>x</em>sin(x) + y + x + z).as_independent(x, y)
(z, 2<em>x</em>sin(x) + x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>sin(x)</em>cos(y)).as_independent(x)
(cos(y), x*sin(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>non-commutative terms cannot always be separated out when self is a Mul</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
(n1 + n1<em>n2).as_independent(n2)
(n1, n1</em>n2)
(n2<em>n1 + n1</em>n2).as_independent(n2)
(0, n1<em>n2 + n2</em>n1)
(n1<em>n2</em>n3).as_independent(n1)
(1, n1<em>n2</em>n3)
(n1<em>n2</em>n3).as_independent(n2)
(n1, n2<em>n3)
((x-n1)</em>(x-y)).as_independent(x)
(1, (x - y)*(x - n1))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- self is anything else:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(sin(x)).as_independent(x)
(1, sin(x))
(sin(x)).as_independent(y)
(sin(x), 1)
exp(x+y).as_independent(x)
(1, exp(x + y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as an Add:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3<em>x).as_independent(x, as_Add=True)
(0, 3</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- force self to be treated as a Mul:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3+x).as_independent(x, as_Add=False)
(1, x + 3)
(-3+x).as_independent(x, as_Add=False)
(1, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note how the below differs from the above in making the
constant on the dep term positive.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(y*(-3+x)).as_independent(x)
(y, x - 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>-- use .as_independent() for true independence testing instead
   of .has(). The former considers only symbols in the free
   symbols while the latter considers all symbols</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
I = Integral(x, (x, 1, 2))
I.has(x)
True
x in I.free_symbols
False
I.as_independent(x) == (I, 1)
True
(I + x).as_independent(x) == (I, x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note: when trying to get independent terms, a separation method
might need to be used first. In this case, it is important to keep
track of what you send to this routine so you know how to interpret
the returned values</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import separatevars, log
separatevars(exp(x+y)).as_independent(x)
(exp(y), exp(x))
(x + x<em>y).as_independent(y)
(x, x</em>y)
separatevars(x + x<em>y).as_independent(y)
(x, y + 1)
(x</em>(1 + y)).as_independent(y)
(x, y + 1)
(x<em>(1 + y)).expand(mul=True).as_independent(y)
(x, x</em>y)
a, b=symbols('a b', positive=True)
(log(a*b).expand(log=True)).as_independent(b)
(log(a), log(b))</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_57">See Also</h1>
<p>separatevars
expand_log
sympy.core.add.Add.as_two_terms
sympy.core.mul.Mul.as_two_terms
as_coeff_mul</p>
<h4 id="as_leading_term_4">as_leading_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_leading_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading (nonzero) term of the series expansion of self.</p>
<p>The _eval_as_leading_term routines are used to do this, and they must
always return a non-zero value.</p>
<h1 id="examples_187">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1 + x + x<strong>2).as_leading_term(x)
1
(1/x</strong>2 + x + x<strong>2).as_leading_term(x)
x</strong>(-2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_numer_denom_4">as_numer_denom</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_numer_denom</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Expr, Expr]&#39;</span>
</code></pre></div>
<p>Return the numerator and the denominator of an expression.</p>
<p>expression -&gt; a/b -&gt; a, b</p>
<p>This is just a stub that should be defined by
an object's class methods to get anything else.</p>
<h1 id="see-also_58">See Also</h1>
<p>normal: return <code>a/b</code> instead of <code>(a, b)</code></p>
<h4 id="as_ordered_factors_4">as_ordered_factors</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_factors</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return list of ordered factors (if Mul) else [self].</p>
<h4 id="as_ordered_terms_4">as_ordered_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_ordered_terms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to an ordered list of terms.</p>
<h1 id="examples_188">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, cos
from sympy.abc import x</p>
<p>(sin(x)<strong>2*cos(x) + sin(x)</strong>2 + 1).as_ordered_terms()
[sin(x)<strong>2*cos(x), sin(x)</strong>2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_poly_4">as_poly</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_poly</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Converts <code>self</code> to a polynomial or returns <code>None</code>.</p>
<h1 id="explanation_25">Explanation</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y</p>
<p>print((x<strong>2 + x*y).as_poly())
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x<strong>2 + x*y).as_poly(x, y))
Poly(x</strong>2 + x*y, x, y, domain='ZZ')</p>
<p>print((x**2 + sin(y)).as_poly(x, y))
None</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_powers_dict_4">as_powers_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_powers_dict</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self as a dictionary of factors with each factor being</p>
<p>treated as a power. The keys are the bases of the factors and the
values, the corresponding exponents. The resulting dictionary should
be used with caution if the expression is a Mul and contains non-
commutative factors since the order that they appeared will be lost in
the dictionary.</p>
<h1 id="see-also_59">See Also</h1>
<p>as_ordered_factors: An alternative for noncommutative applications,
                    returning an ordered list of factors.
args_cnc: Similar to as_ordered_factors, but guarantees separation
          of commutative and noncommutative factors.</p>
<h4 id="as_real_imag_4">as_real_imag</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_real_imag</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Performs complex expansion on 'self' and returns a tuple</p>
<p>containing collected both real and imaginary parts. This
method cannot be confused with re() and im() functions,
which does not perform complex expansion at evaluation.</p>
<p>However it is possible to expand both re() and im()
functions and get exactly the same results as with
a single call to this function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, I</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>(x + y*I).as_real_imag()
(x, y)</p>
<p>from sympy.abc import z, w</p>
<p>(z + w*I).as_real_imag()
(re(z) - im(w), re(w) + im(z))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_set_4">as_set</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_set</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrites Boolean expression in terms of real sets.</p>
<h1 id="examples_189">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Eq, Or, And
x = Symbol('x', real=True)
Eq(x, 0).as_set()
{0}
(x &gt; 0).as_set()
Interval.open(0, oo)
And(-2 &lt; x, x &lt; 2).as_set()
Interval.open(-2, 2)
Or(x &lt; -2, 2 &lt; x).as_set()
Union(Interval.open(-oo, -2), Interval.open(2, oo))</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="as_terms_4">as_terms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">as_terms</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Transform an expression to a list of terms. </p>
<h4 id="aseries_4">aseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">aseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">bound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">hir</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Asymptotic Series expansion of self.</p>
<p>This is equivalent to <code>self.series(x, oo, n)</code>.</p>
<h1 id="parameters_24">Parameters</h1>
<p>self : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>hir : Boolean
      Set this parameter to be True to produce hierarchical series.
      It stops the recursion at an early level and may provide nicer
      and more useful results.</p>
<p>bound : Value, Integer
        Use the <code>bound</code> parameter to give limit on rewriting
        coefficients in its normalised form.</p>
<h1 id="examples_190">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, exp
from sympy.abc import x</p>
<p>e = sin(1/x + exp(-x)) - sin(1/x)</p>
<p>e.aseries(x)
(1/(24<em>x</em><em>4) - 1/(2</em>x<strong>2) + 1 + O(x</strong>(-6), (x, oo)))*exp(-x)</p>
<p>e.aseries(x, n=3, hir=True)
-exp(-2<em>x)</em>sin(1/x)/2 + exp(-x)<em>cos(1/x) + O(exp(-3</em>x), (x, oo))</p>
<p>e = exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x)
exp(exp(x)/(1 - 1/x))</p>
<p>e.aseries(x, bound=3) # doctest: +SKIP
exp(exp(x)/x<strong>2)<em>exp(exp(x)/x)</em>exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x</strong>2)*exp(exp(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).aseries(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_12">Returns</h1>
<p>Expr
    Asymptotic series expansion of the expression.</p>
<h1 id="notes_26">Notes</h1>
<p>This algorithm is directly induced from the limit computational algorithm provided by Gruntz.
It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first
to look for the most rapidly varying subexpression w of a given expression f and then expands f
in a series in w. Then same thing is recursively done on the leading coefficient
till we get constant coefficients.</p>
<p>If the most rapidly varying subexpression of a given expression f is f itself,
the algorithm tries to find a normalised representation of the mrv set and rewrites f
using this normalised representation.</p>
<p>If the expansion contains an order term, it will be either <code>O(x ** (-n))</code> or <code>O(w ** (-n))</code>
where <code>w</code> belongs to the most rapidly varying expression of <code>self</code>.</p>
<h1 id="references_8">References</h1>
<p>.. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series.
       In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993.
       pp. 239-244.
.. [2] Gruntz thesis - p90
.. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion</p>
<h1 id="see-also_60">See Also</h1>
<p>Expr.aseries: See the docstring of this function for complete details of this wrapper.</p>
<h4 id="atoms_4">atoms</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">atoms</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">types</span><span class="p">:</span> <span class="s1">&#39;Tbasic | type[Tbasic]&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;set[Basic] | set[Tbasic]&#39;</span>
</code></pre></div>
<p>Returns the atoms that form the current object.</p>
<p>By default, only objects that are truly atomic and cannot
be divided into smaller pieces are returned: symbols, numbers,
and number symbols like I and pi. It is possible to request
atoms of any type, however, as demonstrated below.</p>
<h1 id="examples_191">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import I, pi, sin
from sympy.abc import x, y
(1 + x + 2<em>sin(y + I</em>pi)).atoms()
{1, 2, I, pi, x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>If one or more types are given, the results will contain only
those types of atoms.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Number, NumberSymbol, Symbol
(1 + x + 2<em>sin(y + I</em>pi)).atoms(Symbol)
{x, y}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number)
{1, 2}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol)
{1, 2, pi}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Number, NumberSymbol, I)
{1, 2, I, pi}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that I (imaginary unit) and zoo (complex infinity) are special
types of number symbols and are not part of the NumberSymbol class.</p>
<p>The type can be given implicitly, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(x) # x is a Symbol
{x, y}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Be careful to check your assumptions when using the implicit option
since <code>S(1).is_Integer = True</code> but <code>type(S(1))</code> is <code>One</code>, a special type
of SymPy atom, while <code>type(S(2))</code> is type <code>Integer</code> and will find all
integers in an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(1))
{1}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(S(2))
{1, 2}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, arguments to atoms() can select more than atomic atoms: any
SymPy type (loaded in core/<strong>init</strong>.py) can be listed as an argument
and those types of "atoms" as found in scanning the arguments of the
expression recursively:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function, Mul
from sympy.core.function import AppliedUndef
f = Function('f')
(1 + f(x) + 2<em>sin(y + I</em>pi)).atoms(Function)
{f(x), sin(y + I<em>pi)}
(1 + f(x) + 2</em>sin(y + I*pi)).atoms(AppliedUndef)
{f(x)}</p>
<p>(1 + x + 2<em>sin(y + I</em>pi)).atoms(Mul)
{I<em>pi, 2</em>sin(y + I*pi)}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="cancel_4">cancel</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cancel</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the cancel function in sympy.polys</p>
<h4 id="coeff_4">coeff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">coeff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">_first</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the coefficient from the term(s) containing <code>x**n</code>. If <code>n</code></p>
<p>is zero then all terms independent of <code>x</code> will be returned.</p>
<h1 id="explanation_26">Explanation</h1>
<p>When <code>x</code> is noncommutative, the coefficient to the left (default) or
right of <code>x</code> can be returned. The keyword 'right' is ignored when
<code>x</code> is commutative.</p>
<h1 id="examples_192">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols
from sympy.abc import x, y, z</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have an explicit negative in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x + 2<em>y).coeff(-1)
x
(x - 2</em>y).coeff(-1)
2*y</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms with no Rational coefficient:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + 2<em>y).coeff(1)
x
(3 + 2</em>x + 4<em>x</em>*2).coeff(1)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms independent of x by making n=0; in this case
expr.as_independent(x)[0] is returned (and 0 will be returned instead
of None):</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x, 0)
3
eq = ((x + 1)</strong>3).expand() + 1
eq
x<strong>3 + 3*x</strong>2 + 3*x + 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 2]
eq -= 2
[eq.coeff(x, i) for i in reversed(range(4))]
[1, 3, 3, 0]</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can select terms that have a numerical term in front of them:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-x - 2<em>y).coeff(2)
-y
from sympy import sqrt
(x + sqrt(2)</em>x).coeff(sqrt(2))
x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The matching is exact:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(3 + 2<em>x + 4</em>x<strong>2).coeff(x)
2
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>2)
4
(3 + 2<em>x + 4</em>x</strong>2).coeff(x<strong>3)
0
(z*(x + y)</strong>2).coeff((x + y)<strong>2)
z
(z*(x + y)</strong>2).coeff(x + y)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
from the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + z<em>(x + x</em>y)).coeff(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<p>If such factoring is desired, factor_terms can be used first:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import factor_terms
factor_terms(x + z<em>(x + x</em>y)).coeff(x)
z*(y + 1) + 1</p>
<p>n, m, o = symbols('n m o', commutative=False)
n.coeff(n)
1
(3<em>n).coeff(n)
3
(n</em>m + m<em>n</em>m).coeff(n) # = (1 + m)<em>n</em>m
1 + m
(n<em>m + m</em>n<em>m).coeff(n, right=True) # = (1 + m)</em>n*m
m</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is more than one possible coefficient 0 is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + m</em>n).coeff(n)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is only one possible coefficient, it is returned:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(n<em>m + x</em>m<em>n).coeff(m</em>n)
x
(n<em>m + x</em>m<em>n).coeff(m</em>n, right=1)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_61">See Also</h1>
<p>as_coefficient: separate the expression into a coefficient and factor
as_coeff_Add: separate the additive constant from an expression
as_coeff_Mul: separate the multiplicative constant from an expression
as_independent: separate x-dependent terms/factors from others
sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>
<h4 id="collect_4">collect</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">syms</span><span class="p">,</span>
    <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">distribute_order_term</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the collect function in sympy.simplify</p>
<h4 id="combsimp_4">combsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">combsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the combsimp function in sympy.simplify</p>
<h4 id="compare_4">compare</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compare</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span>
<span class="p">)</span>
</code></pre></div>
<p>Return -1, 0, 1 if the object is less than, equal,</p>
<p>or greater than other in a canonical sense.
Non-Basic are always greater than Basic.
If both names of the classes being compared appear
in the <code>ordering_of_classes</code> then the ordering will
depend on the appearance of the names there.
If either does not appear in that list, then the
comparison is based on the class name.
If the names are the same then a comparison is made
on the length of the hashable content.
Items of the equal-lengthed contents are then
successively compared using the same rules. If there
is never a difference then 0 is returned.</p>
<h1 id="examples_193">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
x.compare(y)
-1
x.compare(x)
0
y.compare(x)
1</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="conjugate_4">conjugate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">conjugate</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the complex conjugate of 'self'.</p>
<h4 id="copy_4">copy</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="could_extract_minus_sign_4">could_extract_minus_sign</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">could_extract_minus_sign</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;bool&#39;</span>
</code></pre></div>
<p>Return True if self has -1 as a leading factor or has</p>
<p>more literal negative signs than positive signs in a sum,
otherwise False.</p>
<h1 id="examples_194">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = x - y
{i.could_extract_minus_sign() for i in (e, -e)}
{False, True}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Though the <code>y - x</code> is considered like <code>-(x - y)</code>, since it
is in a product without a leading factor of -1, the result is
false below:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*(y - x)).could_extract_minus_sign()
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>To put something in canonical form wrt to sign, use <code>signsimp</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import signsimp
signsimp(x<em>(y - x))
-x</em>(x - y)
_.could_extract_minus_sign()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="count_4">count</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span>
<span class="p">)</span>
</code></pre></div>
<p>Count the number of matching subexpressions.</p>
<h4 id="count_ops_4">count_ops</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_ops</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">visual</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for count_ops that returns the operation count.</p>
<h4 id="diff_4">diff</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">diff</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">symbols</span><span class="p">,</span>
    <span class="o">**</span><span class="n">assumptions</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="dir_4">dir</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dir</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">cdir</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="doit_4">doit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">doit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate objects that are not evaluated by default like limits,</p>
<p>integrals, sums and products. All objects of this kind will be
evaluated recursively, unless some species were excluded via 'hints'
or unless the 'deep' hint was set to 'False'.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
from sympy.abc import x</p>
<p>2<em>Integral(x, x)
2</em>Integral(x, x)</p>
<p>(2<em>Integral(x, x)).doit()
x</em>*2</p>
<p>(2<em>Integral(x, x)).doit(deep=False)
2</em>Integral(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="dummy_eq_4">dummy_eq</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dummy_eq</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">symbol</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compare two expressions and handle dummy symbols.</p>
<h1 id="examples_195">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Dummy
from sympy.abc import x, y</p>
<p>u = Dummy('u')</p>
<p>(u<strong>2 + 1).dummy_eq(x</strong>2 + 1)
True
(u<strong>2 + 1) == (x</strong>2 + 1)
False</p>
<p>(u<strong>2 + y).dummy_eq(x</strong>2 + y, x)
True
(u<strong>2 + y).dummy_eq(x</strong>2 + y, y)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="equals_4">equals</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other</span><span class="p">,</span>
    <span class="n">failing_expression</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self == other, False if it does not, or None. If</p>
<p>failing_expression is True then the expression which did not simplify
to a 0 will be returned instead of None.</p>
<h1 id="explanation_27">Explanation</h1>
<p>If <code>self</code> is a Number (or complex number) that is not zero, then
the result is False.</p>
<p>If <code>self</code> is a number and has not evaluated to zero, evalf will be
used to test whether the expression evaluates to zero. If it does so
and the result has significance (i.e. the precision is either -1, for
a Rational result, or is greater than 1) then the evalf value will be
used to return True or False.</p>
<h4 id="evalf_4">evalf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">evalf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_25">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_27">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="expand_4">expand</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">modulus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">power_base</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">power_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">multinomial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Expand an expression using hints.</p>
<p>See the docstring of the expand() function in sympy.core.function for
more information.</p>
<h4 id="extract_additively_4">extract_additively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_additively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span>
<span class="p">)</span>
</code></pre></div>
<p>Return self - c if it's possible to subtract c from self and</p>
<p>make all matching coefficients move towards zero, else return None.</p>
<h1 id="examples_196">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y
e = 2<em>x + 3
e.extract_additively(x + 1)
x + 2
e.extract_additively(3</em>x)
e.extract_additively(4)
(y<em>(x + 1)).extract_additively(x + 1)
((x + 1)</em>(x + 2<em>y + 1) + 3).extract_additively(x + 1)
(x + 1)</em>(x + 2*y) + 3</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_62">See Also</h1>
<p>extract_multiplicatively
coeff
as_coefficient</p>
<h4 id="extract_branch_factor_4">extract_branch_factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_branch_factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">allow_half</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Try to write self as <code>exp_polar(2*pi*I*n)*z</code> in a nice way.</p>
<p>Return (z, n).</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp_polar, I, pi
from sympy.abc import x, y
exp_polar(I<em>pi).extract_branch_factor()
(exp_polar(I</em>pi), 0)
exp_polar(2<em>I</em>pi).extract_branch_factor()
(1, 1)
exp_polar(-pi<em>I).extract_branch_factor()
(exp_polar(I</em>pi), -1)
exp_polar(3<em>pi</em>I + x).extract_branch_factor()
(exp_polar(x + I<em>pi), 1)
(y</em>exp_polar(-5<em>pi</em>I)<em>exp_polar(3</em>pi<em>I + 2</em>pi<em>x)).extract_branch_factor()
(y</em>exp_polar(2<em>pi</em>x), -1)
exp_polar(-I<em>pi/2).extract_branch_factor()
(exp_polar(-I</em>pi/2), 0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If allow_half is True, also extract exp_polar(I*pi):</p>
<blockquote>
<blockquote>
<blockquote>
<p>exp_polar(I<em>pi).extract_branch_factor(allow_half=True)
(1, 1/2)
exp_polar(2</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 1)
exp_polar(3</em>I<em>pi).extract_branch_factor(allow_half=True)
(1, 3/2)
exp_polar(-I</em>pi).extract_branch_factor(allow_half=True)
(1, -1/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="extract_multiplicatively_4">extract_multiplicatively</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_multiplicatively</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Return None if it's not possible to make self in the form</p>
<p>c * something in a nice way, i.e. preserving the properties
of arguments of self.</p>
<h1 id="examples_197">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Rational</p>
<p>x, y = symbols('x,y', real=True)</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em><em>2 * y)
x</em>y**2</p>
<p>((x<em>y)</em><em>3).extract_multiplicatively(x</em>*4 * y)</p>
<p>(2*x).extract_multiplicatively(2)
x</p>
<p>(2*x).extract_multiplicatively(3)</p>
<p>(Rational(1, 2)*x).extract_multiplicatively(3)
x/6</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="factor_4">factor</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">factor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the factor() function in sympy.polys.polytools</p>
<h4 id="find_4">find</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Find all subexpressions matching a query.</p>
<h4 id="find_field_4">find_field</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_field</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s1">&#39;FieldableProtocol&#39;</span><span class="p">,</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;str | int&#39;</span><span class="p">,</span>
    <span class="n">fallback_type</span><span class="p">:</span> <span class="s1">&#39;type | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">init_kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Reference[Any]&#39;</span>
</code></pre></div>
<p>Field within the reference, if possible.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>field</td>
<td>None</td>
<td>the field to search for.</td>
<td>None</td>
</tr>
<tr>
<td>fallback_type</td>
<td>None</td>
<td>the type to use if we do not know a more specific one.</td>
<td>None</td>
</tr>
<tr>
<td>**init_kwargs</td>
<td>None</td>
<td>arguments to use for constructing a new reference (via <code>__make_reference__</code>).</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A field-specific version of this reference.</td>
</tr>
</tbody>
</table>
<h4 id="fourier_series_4">fourier_series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fourier_series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">limits</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute fourier sine/cosine series of self.</p>
<p>See the docstring of the :func:<code>fourier_series</code> in sympy.series.fourier
for more information.</p>
<h4 id="fps_4">fps</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fps</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">hyper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute formal power power series of self.</p>
<p>See the docstring of the :func:<code>fps</code> function in sympy.series.formal for
more information.</p>
<h4 id="gammasimp_4">gammasimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gammasimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the gammasimp function in sympy.simplify</p>
<h4 id="geto_4">getO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr | None&#39;</span>
</code></pre></div>
<p>Returns the additive O(..) symbol if there is one, else None.</p>
<h4 id="getn_4">getn</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">getn</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the order of the expression.</p>
<h1 id="explanation_28">Explanation</h1>
<p>The order is determined either from the O(...) term. If there
is no O(...) term, it returns None.</p>
<h1 id="examples_198">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import O
from sympy.abc import x
(1 + x + O(x**2)).getn()
2
(1 + x).getn()</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_4">has</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether any subexpression matches any of the patterns.</p>
<h1 id="examples_199">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin
from sympy.abc import x, y, z
(x<strong>2 + sin(x*y)).has(z)
False
(x</strong>2 + sin(x*y)).has(x, y, z)
True
x.has(x)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note <code>has</code> is a structural algorithm with no knowledge of
mathematics. Consider the following half-open interval:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Interval
i = Interval.Lopen(0, 5); i
Interval.Lopen(0, 5)
i.args
(0, 5, True, False)
i.has(4)  # there is no "4" in the arguments
False
i.has(0)  # there <em>is</em> a "0" in the arguments
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Instead, use <code>contains</code> to determine whether a number is in the
interval or not:</p>
<blockquote>
<blockquote>
<blockquote>
<p>i.contains(4)
True
i.contains(0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that <code>expr.has(*patterns)</code> is exactly equivalent to
<code>any(expr.has(p) for p in patterns)</code>. In particular, <code>False</code> is
returned when the list of patterns is empty.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x.has()
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_free_4">has_free</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_free</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">patterns</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has object(s) <code>x</code> as a free expression</p>
<p>else False.</p>
<h1 id="examples_200">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral, Function
from sympy.abc import x, y
f = Function('f')
g = Function('g')
expr = Integral(f(x), (f(x), 1, g(y)))
expr.free_symbols
{y}
expr.has_free(g(y))
True
expr.has_free(*(x, f(x)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This works for subexpressions and types, too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.has_free(g)
True
(x + y + 1).has_free(y + 1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="has_xfree_4">has_xfree</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">has_xfree</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;set[Basic]&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self has any of the patterns in s as a</p>
<p>free argument, else False. This is like <code>Basic.has_free</code>
but this will only report exact argument matches.</p>
<h1 id="examples_201">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
from sympy.abc import x, y
f = Function('f')
f(x).has_xfree({f})
False
f(x).has_xfree({f(x)})
True
f(x + 1).has_xfree({x})
True
f(x + 1).has_xfree({x + 1})
True
f(x + y + 1).has_xfree({x + 1})
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="integrate_4">integrate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">integrate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the integrate function in sympy.integrals</p>
<h4 id="invert_4">invert</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">g</span><span class="p">,</span>
    <span class="o">*</span><span class="n">gens</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the multiplicative inverse of <code>self</code> mod <code>g</code></p>
<p>where <code>self</code> (and <code>g</code>) may be symbolic expressions).</p>
<h1 id="see-also_63">See Also</h1>
<p>sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert</p>
<h4 id="is_algebraic_expr_4">is_algebraic_expr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_algebraic_expr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether a given expression is algebraic or not, in the</p>
<p>given symbols, syms. When syms is not given, all free symbols
will be used. The rational function does not have to be in expanded
or in any kind of canonical form.</p>
<p>This function returns False for expressions that are "algebraic
expressions" with symbolic exponents. This is a simple extension to the
is_rational_function, including rational exponentiation.</p>
<h1 id="examples_202">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sqrt
x = Symbol('x', real=True)
sqrt(1 + x).is_rational_function()
False
sqrt(1 + x).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be an algebraic
expression to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import exp, factor
a = sqrt(exp(x)*<em>2 + 2</em>exp(x) + 1)/(exp(x) + 1)
a.is_algebraic_expr(x)
False
factor(a).is_algebraic_expr()
True</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_64">See Also</h1>
<p>is_rational_function</p>
<h1 id="references_9">References</h1>
<p>.. [1] https://en.wikipedia.org/wiki/Algebraic_expression</p>
<h4 id="is_constant_4">is_constant</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">wrt</span><span class="p">,</span>
    <span class="o">**</span><span class="n">flags</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is constant, False if not, or None if</p>
<p>the constancy could not be determined conclusively.</p>
<h1 id="explanation_29">Explanation</h1>
<p>If an expression has no free symbols then it is a constant. If
there are free symbols it is possible that the expression is a
constant, perhaps (but not necessarily) zero. To test such
expressions, a few strategies are tried:</p>
<p>1) numerical evaluation at two random points. If two such evaluations
give two different values and the values have a precision greater than
1 then self is not constant. If the evaluations agree or could not be
obtained with any precision, no decision is made. The numerical testing
is done only if <code>wrt</code> is different than the free symbols.</p>
<p>2) differentiation with respect to variables in 'wrt' (or all free
symbols if omitted) to see if the expression is constant or not. This
will not always lead to an expression that is zero even though an
expression is constant (see added test in test_expr.py). If
all derivatives are zero then self is constant with respect to the
given symbols.</p>
<p>3) finding out zeros of denominator expression with free_symbols.
It will not be constant if there are zeros. It gives more negative
answers for expression that are not constant.</p>
<p>If neither evaluation nor differentiation can prove the expression is
constant, None is returned unless two numerical values happened to be
the same and the flag <code>failing_number</code> is True -- in that case the
numerical value will be returned.</p>
<p>If flag simplify=False is passed, self will not be simplified;
the default is True since self should be simplified before testing.</p>
<h1 id="examples_203">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, Sum, S, pi
from sympy.abc import a, n, x, y
x.is_constant()
False
S(2).is_constant()
True
Sum(x, (x, 1, 10)).is_constant()
True
Sum(x, (x, 1, n)).is_constant()
False
Sum(x, (x, 1, n)).is_constant(y)
True
Sum(x, (x, 1, n)).is_constant(n)
False
Sum(x, (x, 1, n)).is_constant(x)
True
eq = a<em>cos(x)</em><em>2 + a</em>sin(x)**2 - a
eq.is_constant()
True
eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
True</p>
<p>(0<strong>x).is_constant()
False
x.is_constant()
False
(x</strong>x).is_constant()
False
one = cos(x)<strong>2 + sin(x)</strong>2
one.is_constant()
True
((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_hypergeometric_4">is_hypergeometric</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_hypergeometric</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">k</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="is_meromorphic_4">is_meromorphic</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_meromorphic</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">a</span>
<span class="p">)</span>
</code></pre></div>
<p>This tests whether an expression is meromorphic as</p>
<p>a function of the given symbol <code>x</code> at the point <code>a</code>.</p>
<p>This method is intended as a quick test that will return
None if no decision can be made without simplification or
more detailed analysis.</p>
<h1 id="examples_204">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import zoo, log, sin, sqrt
from sympy.abc import x</p>
<p>f = 1/x<strong>2 + 1 - 2*x</strong>3
f.is_meromorphic(x, 0)
True
f.is_meromorphic(x, 1)
True
f.is_meromorphic(x, zoo)
True</p>
<p>g = x**log(3)
g.is_meromorphic(x, 0)
False
g.is_meromorphic(x, 1)
True
g.is_meromorphic(x, zoo)
False</p>
<p>h = sin(1/x)<em>x</em>*2
h.is_meromorphic(x, 0)
False
h.is_meromorphic(x, 1)
True
h.is_meromorphic(x, zoo)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multivalued functions are considered meromorphic when their
branches are meromorphic. Thus most functions are meromorphic
everywhere except at essential singularities and branch points.
In particular, they will be meromorphic also on branch cuts
except at their endpoints.</p>
<blockquote>
<blockquote>
<blockquote>
<p>log(x).is_meromorphic(x, -1)
True
log(x).is_meromorphic(x, 0)
False
sqrt(x).is_meromorphic(x, -1)
True
sqrt(x).is_meromorphic(x, 0)
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="is_polynomial_4">is_polynomial</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_polynomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if self is a polynomial in syms and False otherwise.</p>
<p>This checks if self is an exact polynomial in syms.  This function
returns False for expressions that are "polynomials" with symbolic
exponents.  Thus, you should be able to apply polynomial algorithms to
expressions for which this returns True, and Poly(expr, *syms) should
work if and only if expr.is_polynomial(*syms) returns True. The
polynomial does not have to be in expanded form.  If no symbols are
given, all free symbols in the expression will be used.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', polynomial=True).</p>
<h1 id="examples_205">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, Function
x = Symbol('x')
((x<strong>2 + 1)</strong>4).is_polynomial(x)
True
((x<strong>2 + 1)</strong>4).is_polynomial()
True
(2<strong>x + 1).is_polynomial(x)
False
(2</strong>x + 1).is_polynomial(2**x)
True
f = Function('f')
(f(x) + 1).is_polynomial(x)
False
(f(x) + 1).is_polynomial(f(x))
True
(1/f(x) + 1).is_polynomial(f(x))
False</p>
<p>n = Symbol('n', nonnegative=True, integer=True)
(x**n + 1).is_polynomial(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a polynomial to
become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor, cancel
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)
a.is_polynomial(y)
False
factor(a)
y + 1
factor(a).is_polynomial(y)
True</p>
<p>b = (y*<em>2 + 2</em>y + 1)/(y + 1)
b.is_polynomial(y)
False
cancel(b)
y + 1
cancel(b).is_polynomial(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also .is_rational_function()</p>
<h4 id="is_rational_function_4">is_rational_function</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_rational_function</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">syms</span>
<span class="p">)</span>
</code></pre></div>
<p>Test whether function is a ratio of two polynomials in the given</p>
<p>symbols, syms. When syms is not given, all free symbols will be used.
The rational function does not have to be in expanded or in any kind of
canonical form.</p>
<p>This function returns False for expressions that are "rational
functions" with symbolic exponents.  Thus, you should be able to call
.as_numer_denom() and apply polynomial algorithms to the result for
expressions for which this returns True.</p>
<p>This is not part of the assumptions system.  You cannot do
Symbol('z', rational_function=True).</p>
<h1 id="examples_206">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Symbol, sin
from sympy.abc import x, y</p>
<p>(x/y).is_rational_function()
True</p>
<p>(x**2).is_rational_function()
True</p>
<p>(x/sin(y)).is_rational_function(y)
False</p>
<p>n = Symbol('n', integer=True)
(x**n + 1).is_rational_function(x)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function does not attempt any nontrivial simplifications that may
result in an expression that does not appear to be a rational function
to become one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, factor
y = Symbol('y', positive=True)
a = sqrt(y*<em>2 + 2</em>y + 1)/y
a.is_rational_function(y)
False
factor(a)
(y + 1)/y
factor(a).is_rational_function(y)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>See also is_algebraic_expr().</p>
<h4 id="is_same_4">is_same</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_same</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span>
    <span class="n">b</span><span class="p">,</span>
    <span class="n">approx</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return True if a and b are structurally the same, else False.</p>
<p>If <code>approx</code> is supplied, it will be used to test whether two
numbers are the same or not. By default, only numbers of the
same type will compare equal, so S.Half != Float(0.5).</p>
<h1 id="examples_207">Examples</h1>
<p>In SymPy (unlike Python) two numbers do not compare the same if they are
not of the same type:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S
2.0 == S(2)
False
0.5 == S.Half
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>By supplying a function with which to compare two numbers, such
differences can be ignored. e.g. <code>equal_valued</code> will return True
for decimal numbers having a denominator that is a power of 2,
regardless of precision.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Float
from sympy.core.numbers import equal_valued
(S.Half/4).is_same(Float(0.125, 1), equal_valued)
True
Float(1, 2).is_same(Float(1, 10), equal_valued)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>But decimals without a power of 2 denominator will compare
as not being the same.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Float(0.1, 9).is_same(Float(0.1, 10), equal_valued)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>But arbitrary differences can be ignored by supplying a function
to test the equivalence of two numbers:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import math
Float(0.1, 9).is_same(Float(0.1, 10), math.isclose)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Other objects might compare the same even though types are not the
same. This routine will only return True if two expressions are
identical in terms of class types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import eye, Basic
eye(1) == S(eye(1))  # mutable vs immutable
True
Basic.is_same(eye(1), S(eye(1)))
False</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="leadterm_4">leadterm</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">leadterm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns the leading term a<em>x</em>*b as a tuple (a, b).</p>
<h1 id="examples_208">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(1+x+x<strong>2).leadterm(x)
(1, 0)
(1/x</strong>2+x+x**2).leadterm(x)
(1, -2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="limit_4">limit</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">limit</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">xlim</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Compute limit x-&gt;xlim.</p>
<h4 id="lseries_4">lseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">lseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper for series yielding an iterator of the terms of the series.</p>
<p>Note: an infinite series will yield an infinite iterator. The following,
for exaxmple, will never terminate. It will just keep printing terms
of the sin(x) series::</p>
<p>for term in sin(x).lseries(x):
      print term</p>
<p>The advantage of lseries() over nseries() is that many times you are
just interested in the next term in the series (i.e. the first term for
example), but you do not know how many you should ask for in nseries()
using the "n" parameter.</p>
<p>See also nseries().</p>
<h4 id="match_4">match</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Pattern matching.</p>
<p>Wild symbols match all.</p>
<p>Return <code>None</code> when expression (self) does not match with pattern.
Otherwise return a dictionary such that::</p>
<p>pattern.xreplace(self.match(pattern)) == self</p>
<h1 id="examples_209">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Wild, Sum
from sympy.abc import x, y
p = Wild("p")
q = Wild("q")
r = Wild("r")
e = (x+y)<strong>(x+y)
e.match(p</strong>p)
{p_: x + y}
e.match(p<strong>q)
{p_: x + y, q_: x + y}
e = (2*x)</strong>2
e.match(p<em>q</em><em>r)
{p_: 4, q_: x, r_: 2}
(p</em>q<strong>r).xreplace(e.match(p*q</strong>r))
4<em>x</em>*2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since match is purely structural expressions that are equivalent up to
bound symbols will not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p))))
None</p>
</blockquote>
</blockquote>
</blockquote>
<p>An expression with bound symbols can be matched if the pattern uses
a distinct <code>Wild</code> for each bound symbol:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))
{p_: 2, q_: x}</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>old</code> flag will give the old-style pattern matching where
expressions and patterns are essentially solved to give the match. Both
of the following give None unless <code>old=True</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x - 2).match(p - x, old=True)
{p_: 2<em>x - 2}
(2/x).match(p</em>x, old=True)
{p_: 2/x**2}</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_65">See Also</h1>
<p>matches: pattern.matches(expr) is the same as expr.match(pattern)
xreplace: exact structural replacement
replace: structural replacement with pattern matching
Wild: symbolic placeholders for expressions in pattern matching</p>
<h4 id="matches_4">matches</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">matches</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">,</span>
    <span class="n">repl_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">old</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Helper method for match() that looks for a match between Wild symbols</p>
<p>in self and expressions in expr.</p>
<h1 id="examples_210">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, Wild, Basic
a, b, c = symbols('a b c')
x = Wild('x')
Basic(a + x, x).matches(Basic(a + b, c)) is None
True
Basic(a + x, x).matches(Basic(a + b + c, b + c))
{x_: b + c}</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="n_4">n</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Evaluate the given formula to an accuracy of <em>n</em> digits.</p>
<h1 id="parameters_26">Parameters</h1>
<p>subs : dict, optional
    Substitute numerical values for symbols, e.g.
    <code>subs={x:3, y:1+pi}</code>. The substitutions must be given as a
    dictionary.</p>
<p>maxn : int, optional
    Allow a maximum temporary working precision of maxn digits.</p>
<p>chop : bool or number, optional
    Specifies how to replace tiny real or imaginary parts in
    subresults by exact zeros.</p>
<div class="highlight"><pre><span></span><code>When ``True`` the chop value defaults to standard precision.

Otherwise the chop value is used to determine the
magnitude of &quot;small&quot; for purposes of chopping.

&gt;&gt;&gt; from sympy import N
&gt;&gt;&gt; x = 1e-4
&gt;&gt;&gt; N(x, chop=True)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-5)
0.000100000000000000
&gt;&gt;&gt; N(x, chop=1e-4)
0
</code></pre></div>
<p>strict : bool, optional
    Raise <code>PrecisionExhausted</code> if any subresult fails to
    evaluate to full accuracy, given the available maxprec.</p>
<p>quad : str, optional
    Choose algorithm for numerical quadrature. By default,
    tanh-sinh quadrature is used. For oscillatory
    integrals on an infinite interval, try <code>quad='osc'</code>.</p>
<p>verbose : bool, optional
    Print debug information.</p>
<h1 id="notes_28">Notes</h1>
<p>When Floats are naively substituted into an expression,
precision errors may adversely affect the result. For example,
adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is
then subtracted, the result will be 0.
That is exactly what happens in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x, y, z
values = {x: 1e16, y: 1, z: 1e16}
(x + y - z).subs(values)
0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the subs argument for evalf is the accurate way to
evaluate such an expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x + y - z).evalf(subs=values)
1.00000000000000</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="normal_4">normal</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">normal</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Return the expression as a fraction.</p>
<p>expression -&gt; a/b</p>
<h1 id="see-also_66">See Also</h1>
<p>as_numer_denom: return <code>(a, b)</code> instead of <code>a/b</code></p>
<h4 id="nseries_4">nseries</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nseries</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>
<p>If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
called. This calculates "n" terms in the innermost expressions and
then builds up the final series just by "cross-multiplying" everything
out.</p>
<p>The optional <code>logx</code> parameter can be used to replace any log(x) in the
returned series with a symbolic value to avoid evaluating log(x) at 0. A
symbol to use in place of log(x) should be provided.</p>
<p>Advantage -- it's fast, because we do not have to determine how many
terms we need to calculate in advance.</p>
<p>Disadvantage -- you may end up with less terms than you may have
expected, but the O(x**n) term appended will always be correct and
so the result, though perhaps shorter, will also be correct.</p>
<p>If any of those assumptions is not met, this is treated like a
wrapper to series which will try harder to return the correct
number of terms.</p>
<p>See also lseries().</p>
<h1 id="examples_211">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sin, log, Symbol
from sympy.abc import x, y
sin(x).nseries(x, 0, 6)
x - x<strong>3/6 + x</strong>5/120 + O(x<strong>6)
log(x+1).nseries(x, 0, 5)
x - x</strong>2/2 + x<strong>3/3 - x</strong>4/4 + O(x**5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Handling of the <code>logx</code> parameter --- in the following example the
expansion fails since <code>sin</code> does not have an asymptotic expansion
at -oo (the limit of log(x) as x approaches 0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = sin(log(x))
e.nseries(x, 0, 6)
Traceback (most recent call last):
...
PoleError: ...
...
logx = Symbol('logx')
e.nseries(x, 0, 6, logx=logx)
sin(logx)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the following example, the expansion works but only returns self
unless the <code>logx</code> parameter is used:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>y
e.nseries(x, 0, 2)
x</strong>y
e.nseries(x, 0, 2, logx=logx)
exp(logx*y)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="nsimplify_4">nsimplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nsimplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">constants</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the nsimplify function in sympy.simplify</p>
<h4 id="powsimp_4">powsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">powsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the powsimp function in sympy.simplify</p>
<h4 id="primitive_4">primitive</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">primitive</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;tuple[Number, Expr]&#39;</span>
</code></pre></div>
<p>Return the positive Rational that can be extracted non-recursively</p>
<p>from every term of self (i.e., self is treated like an Add). This is
like the as_coeff_Mul() method but primitive always extracts a positive
Rational (never a negative or a Float).</p>
<h1 id="examples_212">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy.abc import x
(3<em>(x + 1)</em><em>2).primitive()
(3, (x + 1)</em><em>2)
a = (6</em>x + 2); a.primitive()
(2, 3<em>x + 1)
b = (x/2 + 3); b.primitive()
(1/2, x + 6)
(a</em>b).primitive() == (1, a*b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="radsimp_4">radsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">radsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the radsimp function in sympy.simplify</p>
<h4 id="ratsimp_4">ratsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">ratsimp</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>See the ratsimp function in sympy.simplify</p>
<h4 id="rcall_4">rcall</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rcall</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>Apply on the argument recursively through the expression tree.</p>
<p>This method is used to simulate a common abuse of notation for
operators. For instance, in SymPy the following will not work:</p>
<p><code>(x+Lambda(y, 2*y))(z) == x+2*z</code>,</p>
<p>however, you can use:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Lambda
from sympy.abc import x, y, z
(x + Lambda(y, 2<em>y)).rcall(z)
x + 2</em>z</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="refine_4">refine</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">refine</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">assumption</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>See the refine function in sympy.assumptions</p>
<h4 id="removeo_4">removeO</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">removeO</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Expr&#39;</span>
</code></pre></div>
<p>Removes the additive O(..) symbol if there is one</p>
<h4 id="replace_4">replace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="nb">map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exact</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Replace matching subexpressions of <code>self</code> with <code>value</code>.</p>
<p>If <code>map = True</code> then also return the mapping {old: new} where <code>old</code>
was a sub-expression found with query and <code>new</code> is the replacement
value for it. If the expression itself does not match the query, then
the returned value will be <code>self.xreplace(map)</code> otherwise it should
be <code>self.subs(ordered(map.items()))</code>.</p>
<p>Traverses an expression tree and performs replacement of matching
subexpressions from the bottom to the top of the tree. The default
approach is to do the replacement in a simultaneous fashion so
changes made are targeted only once. If this is not desired or causes
problems, <code>simultaneous</code> can be set to False.</p>
<p>In addition, if an expression containing more than one Wild symbol
is being used to match subexpressions and the <code>exact</code> flag is None
it will be set to True so the match will only succeed if all non-zero
values are received for each Wild that appears in the match pattern.
Setting this to False accepts a match of 0; while setting it True
accepts all matches that have a 0 in them. See example below for
cautions.</p>
<p>The list of possible combinations of queries and replacement values
is listed below:</p>
<h1 id="examples_213">Examples</h1>
<p>Initial setup</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import log, sin, cos, tan, Wild, Mul, Add
from sympy.abc import x, y
f = log(sin(x)) + tan(sin(x**2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>1.1. type -&gt; type
    obj.replace(type, newtype)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, replace it with the
result of passing its argument(s) to ``newtype``.

&gt;&gt;&gt; f.replace(sin, cos)
log(cos(x)) + tan(cos(x**2))
&gt;&gt;&gt; sin(x).replace(sin, cos, map=True)
(cos(x), {sin(x): cos(x)})
&gt;&gt;&gt; (x*y).replace(Mul, Add)
x + y
</code></pre></div>
<p>1.2. type -&gt; func
    obj.replace(type, func)</p>
<div class="highlight"><pre><span></span><code>When object of type ``type`` is found, apply ``func`` to its
argument(s). ``func`` must be written to handle the number
of arguments of ``type``.

&gt;&gt;&gt; f.replace(sin, lambda arg: sin(2*arg))
log(sin(2*x)) + tan(sin(2*x**2))
&gt;&gt;&gt; (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))
sin(2*x*y)
</code></pre></div>
<p>2.1. pattern -&gt; expr
    obj.replace(pattern(wild), expr(wild))</p>
<div class="highlight"><pre><span></span><code>Replace subexpressions matching ``pattern`` with the expression
written in terms of the Wild symbols in ``pattern``.

&gt;&gt;&gt; a, b = map(Wild, &#39;ab&#39;)
&gt;&gt;&gt; f.replace(sin(a), tan(a))
log(tan(x)) + tan(tan(x**2))
&gt;&gt;&gt; f.replace(sin(a), tan(a/2))
log(tan(x/2)) + tan(tan(x**2/2))
&gt;&gt;&gt; f.replace(sin(a), a)
log(x) + tan(x**2)
&gt;&gt;&gt; (x*y).replace(a*x, a)
y

Matching is exact by default when more than one Wild symbol
is used: matching fails unless the match gives non-zero
values for all Wild symbols:

&gt;&gt;&gt; (2*x + y).replace(a*x + b, b - a)
y - 2
&gt;&gt;&gt; (2*x).replace(a*x + b, b - a)
2*x

When set to False, the results may be non-intuitive:

&gt;&gt;&gt; (2*x).replace(a*x + b, b - a, exact=False)
2/x
</code></pre></div>
<p>2.2. pattern -&gt; func
    obj.replace(pattern(wild), lambda wild: expr(wild))</p>
<div class="highlight"><pre><span></span><code>All behavior is the same as in 2.1 but now a function in terms of
pattern variables is used rather than an expression:

&gt;&gt;&gt; f.replace(sin(a), lambda a: sin(2*a))
log(sin(2*x)) + tan(sin(2*x**2))
</code></pre></div>
<p>3.1. func -&gt; func
    obj.replace(filter, func)</p>
<div class="highlight"><pre><span></span><code>Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``
is True.

&gt;&gt;&gt; g = 2*sin(x**3)
&gt;&gt;&gt; g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)
4*sin(x**9)
</code></pre></div>
<p>The expression itself is also targeted by the query but is done in
such a fashion that changes are not made twice.</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; e = x*(x*y + 1)
&gt;&gt;&gt; e.replace(lambda x: x.is_Mul, lambda x: 2*x)
2*x*(2*x*y + 1)
</code></pre></div>
<p>When matching a single symbol, <code>exact</code> will default to True, but
this may or may not be the behavior that is desired:</p>
<p>Here, we want <code>exact=False</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Function
f = Function('f')
e = f(1) + f(0)
q = f(a), lambda a: f(a + 1)
e.replace(<em>q, exact=False)
f(1) + f(2)
e.replace(</em>q, exact=True)
f(0) + f(2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>But here, the nature of matching makes selecting
the right setting tricky:</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = x<strong>(1 + y)
(x</strong>(1 + y)).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=False)
x
(x<strong>(1 + y)).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=True)
x</strong>(-x - y + 1)
(x<strong>y).replace(x</strong>(1 + a), lambda a: x<strong>-a, exact=False)
x
(x</strong>y).replace(x<strong>(1 + a), lambda a: x</strong>-a, exact=True)
x**(1 - y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is probably better to use a different form of the query
that describes the target expression more precisely:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1 + x<strong>(1 + y)).replace(
... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,
... lambda x: x.base</strong>(1 - (x.exp - 1)))
...
x**(1 - y) + 1</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_67">See Also</h1>
<p>subs: substitution of subexpressions as defined by the objects
      themselves.
xreplace: exact node replacement in expr tree; also capable of
          using matching rules</p>
<h4 id="rewrite_4">rewrite</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rewrite</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">hints</span>
<span class="p">)</span>
</code></pre></div>
<p>Rewrite <em>self</em> using a defined rule.</p>
<p>Rewriting transforms an expression to another, which is mathematically
equivalent but structurally different. For example you can rewrite
trigonometric functions as complex exponentials or combinatorial
functions as gamma function.</p>
<p>This method takes a <em>pattern</em> and a <em>rule</em> as positional arguments.
<em>pattern</em> is optional parameter which defines the types of expressions
that will be transformed. If it is not passed, all possible expressions
will be rewritten. <em>rule</em> defines how the expression will be rewritten.</p>
<h1 id="parameters_27">Parameters</h1>
<p>args : Expr
    A <em>rule</em>, or <em>pattern</em> and <em>rule</em>.
    - <em>pattern</em> is a type or an iterable of types.
    - <em>rule</em> can be any object.</p>
<p>deep : bool, optional
    If <code>True</code>, subexpressions are recursively transformed. Default is
    <code>True</code>.</p>
<h1 id="examples_214">Examples</h1>
<p>If <em>pattern</em> is unspecified, all possible expressions are transformed.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, sin, exp, I
from sympy.abc import x
expr = cos(x) + I<em>sin(x)
expr.rewrite(exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Pattern can be a type or an iterable of types.</p>
<blockquote>
<blockquote>
<blockquote>
<p>expr.rewrite(sin, exp)
exp(I<em>x)/2 + cos(x) - exp(-I</em>x)/2
expr.rewrite([cos,], exp)
exp(I<em>x)/2 + I</em>sin(x) + exp(-I<em>x)/2
expr.rewrite([cos, sin], exp)
exp(I</em>x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Rewriting behavior can be implemented by defining <code>_eval_rewrite()</code>
method.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Expr, sqrt, pi
class MySin(Expr):
...     def _eval_rewrite(self, rule, args, <strong>hints):
...         x, = args
...         if rule == cos:
...             return cos(pi/2 - x, evaluate=False)
...         if rule == sqrt:
...             return sqrt(1 - cos(x)</strong>2)
MySin(MySin(x)).rewrite(cos)
cos(-cos(-x + pi/2) + pi/2)
MySin(x).rewrite(sqrt)
sqrt(1 - cos(x)**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Defining <code>_eval_rewrite_as_[...]()</code> method is supported for backwards
compatibility reason. This may be removed in the future and using it is
discouraged.</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MySin(Expr):
...     def _eval_rewrite_as_cos(self, <em>args, </em>*hints):
...         x, = args
...         return cos(pi/2 - x, evaluate=False)
MySin(x).rewrite(cos)
cos(-x + pi/2)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="round_4">round</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return x rounded to the given decimal place.</p>
<p>If a complex number would results, apply round to the real
and imaginary components of the number.</p>
<h1 id="examples_215">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, E, I, S, Number
pi.round()
3
pi.round(2)
3.14
(2<em>pi + E</em>I).round()
6 + 3*I</p>
</blockquote>
</blockquote>
</blockquote>
<p>The round method has a chopping effect:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(2<em>pi + I/10).round()
6
(pi/10 + 2</em>I).round()
2<em>I
(pi/10 + E</em>I).round(2)
0.31 + 2.72*I</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="notes_29">Notes</h1>
<p>The Python <code>round</code> function uses the SymPy <code>round</code> method so it
will always return a SymPy number (not a Python float or int):</p>
<blockquote>
<blockquote>
<blockquote>
<p>isinstance(round(S(123), -2), Number)
True</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="separate_4">separate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">separate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">force</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>See the separate function in sympy.simplify</p>
<h4 id="series_4">series</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">series</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
    <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cdir</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</code></pre></div>
<p>Series expansion of "self" around <code>x = x0</code> yielding either terms of</p>
<p>the series one by one (the lazy series given when n=None), else
all the terms at once when n != None.</p>
<p>Returns the series expansion of "self" around the point <code>x = x0</code>
with respect to <code>x</code> up to <code>O((x - x0)**n, x, x0)</code> (default n is 6).</p>
<p>If <code>x=None</code> and <code>self</code> is univariate, the univariate symbol will
be supplied, otherwise an error will be raised.</p>
<h1 id="parameters_28">Parameters</h1>
<p>expr : Expression
       The expression whose series is to be expanded.</p>
<p>x : Symbol
    It is the variable of the expression to be calculated.</p>
<p>x0 : Value
     The value around which <code>x</code> is calculated. Can be any value
     from <code>-oo</code> to <code>oo</code>.</p>
<p>n : Value
    The value used to represent the order in terms of <code>x**n</code>,
    up to which the series is to be expanded.</p>
<p>dir : String, optional
      The series-expansion can be bi-directional. If <code>dir="+"</code>,
      then (x-&gt;x0+). If <code>dir="-", then (x-&gt;x0-). For infinite</code>x0<code>(</code>oo<code>or</code>-oo<code>), the</code>dir<code>argument is determined
      from the direction of the infinity (i.e.,</code>dir="-"<code>for</code>oo``).</p>
<p>logx : optional
       It is used to replace any log(x) in the returned series with a
       symbolic value rather than evaluating the actual value.</p>
<p>cdir : optional
       It stands for complex direction, and indicates the direction
       from which the expansion needs to be evaluated.</p>
<h1 id="examples_216">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import cos, exp, tan
from sympy.abc import x, y
cos(x).series()
1 - x<strong>2/2 + x</strong>4/24 + O(x<strong>6)
cos(x).series(n=4)
1 - x</strong>2/2 + O(x<strong>4)
cos(x).series(x, x0=1, n=2)
cos(1) - (x - 1)*sin(1) + O((x - 1)</strong>2, (x, 1))
e = cos(x + exp(y))
e.series(y, n=2)
cos(x + 1) - y<em>sin(x + 1) + O(y</em><em>2)
e.series(x, n=2)
cos(exp(y)) - x</em>sin(exp(y)) + O(x**2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>n=None</code> then a generator of the series terms will be returned.</p>
<blockquote>
<blockquote>
<blockquote>
<p>term=cos(x).series(n=None)
[next(term) for i in range(2)]
[1, -x**2/2]</p>
</blockquote>
</blockquote>
</blockquote>
<p>For <code>dir=+</code> (default) the series is calculated from the right and
for <code>dir=-</code> the series from the left. For smooth functions this
flag will not alter the results.</p>
<blockquote>
<blockquote>
<blockquote>
<p>abs(x).series(dir="+")
x
abs(x).series(dir="-")
-x
f = tan(x)
f.series(x, 2, 6, "+")
tan(2) + (1 + tan(2)<strong>2)*(x - 2) + (x - 2)</strong>2<em>(tan(2)</em><em>3 + tan(2)) +
(x - 2)</em><em>3</em>(1/3 + 4<em>tan(2)</em><em>2/3 + tan(2)</em><em>4) + (x - 2)</em><em>4</em>(tan(2)<strong>5 +
5*tan(2)</strong>3/3 + 2<em>tan(2)/3) + (x - 2)</em><em>5</em>(2/15 + 17<em>tan(2)</em><em>2/15 +
2</em>tan(2)<strong>4 + tan(2)</strong>6) + O((x - 2)**6, (x, 2))</p>
<p>f.series(x, 2, 3, "-")
tan(2) + (2 - x)<em>(-tan(2)</em><em>2 - 1) + (2 - x)</em><em>2</em>(tan(2)<strong>3 + tan(2))
+ O((x - 2)</strong>3, (x, 2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>For rational expressions this method may return original expression without the Order term.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).series(x, n=8)
1/x</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="returns_13">Returns</h1>
<p>Expr : Expression
    Series expansion of the expression about x0</p>
<h1 id="raises_4">Raises</h1>
<p>TypeError
    If "n" and "x0" are infinity objects</p>
<p>PoleError
    If "x0" is an infinity object</p>
<h4 id="simplify_4">simplify</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>See the simplify function in sympy.simplify</p>
<h4 id="sort_key_4">sort_key</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sort_key</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Return a sort key.</p>
<h1 id="examples_217">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import S, I</p>
<p>sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())
[1/2, -I, I]</p>
<p>S("[x, 1/x, 1/x<strong>2, x</strong>2, x<strong>(1/2), x</strong>(1/4), x<strong>(3/2)]")
[x, 1/x, x</strong>(-2), x<strong>2, sqrt(x), x</strong>(1/4), x<strong>(3/2)]
sorted(_, key=lambda x: x.sort_key())
[x</strong>(-2), 1/x, x<strong>(1/4), sqrt(x), x, x</strong>(3/2), x**2]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="subs_4">subs</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">subs</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">arg1</span><span class="p">:</span> <span class="s1">&#39;Mapping[Basic | complex, Basic | complex] | Iterable[tuple[Basic | complex, Basic | complex]] | Basic | complex&#39;</span><span class="p">,</span>
    <span class="n">arg2</span><span class="p">:</span> <span class="s1">&#39;Basic | complex | None&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Basic&#39;</span>
</code></pre></div>
<p>Substitutes old for new in an expression after sympifying args.</p>
<p><code>args</code> is either:
  - two arguments, e.g. foo.subs(old, new)
  - one iterable argument, e.g. foo.subs(iterable). The iterable may be
     o an iterable container with (old, new) pairs. In this case the
       replacements are processed in the order given with successive
       patterns possibly affecting replacements already made.
     o a dict or set whose key/value items correspond to old/new pairs.
       In this case the old/new pairs will be sorted by op count and in
       case of a tie, by number of args and the default_sort_key. The
       resulting sorted list is then processed as an iterable container
       (see previous).</p>
<p>If the keyword <code>simultaneous</code> is True, the subexpressions will not be
evaluated until all the substitutions have been made.</p>
<h1 id="examples_218">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import pi, exp, limit, oo
from sympy.abc import x, y
(1 + x<em>y).subs(x, pi)
pi</em>y + 1
(1 + x<em>y).subs({x:pi, y:2})
1 + 2</em>pi
(1 + x<em>y).subs([(x, pi), (y, 2)])
1 + 2</em>pi
reps = [(y, x<strong>2), (x, 2)]
(x + y).subs(reps)
6
(x + y).subs(reversed(reps))
x</strong>2 + 2</p>
<p>(x<strong>2 + x</strong>4).subs(x<strong>2, y)
y</strong>2 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To replace only the x<strong>2 but not the x</strong>4, use xreplace:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<strong>2 + x</strong>4).xreplace({x<strong>2: y})
x</strong>4 + y</p>
</blockquote>
</blockquote>
</blockquote>
<p>To delay evaluation until all substitutions have been made,
set the keyword <code>simultaneous</code> to True:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x/y).subs([(x, 0), (y, 0)])
0
(x/y).subs([(x, 0), (y, 0)], simultaneous=True)
nan</p>
</blockquote>
</blockquote>
</blockquote>
<p>This has the added feature of not allowing subsequent substitutions
to affect those already made:</p>
<blockquote>
<blockquote>
<blockquote>
<p>((x + y)/y).subs({x + y: y, y: x + y})
1
((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
y/(x + y)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In order to obtain a canonical result, unordered iterables are
sorted by count_op length, number of arguments and by the
default_sort_key to break any ties. All other iterables are left
unsorted.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import sqrt, sin, cos
from sympy.abc import a, b, c, d, e</p>
<p>A = (sqrt(sin(2<em>x)), a)
B = (sin(2</em>x), b)
C = (cos(2*x), c)
D = (x, d)
E = (exp(x), e)</p>
<p>expr = sqrt(sin(2<em>x))</em>sin(exp(x)<em>x)</em>cos(2<em>x) + sin(2</em>x)</p>
<p>expr.subs(dict([A, B, C, D, E]))
a<em>c</em>sin(d*e) + b</p>
</blockquote>
</blockquote>
</blockquote>
<p>The resulting expression represents a literal replacement of the
old arguments with the new arguments. This may not reflect the
limiting behavior of the expression:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x*<em>3 - 3</em>x).subs({x: oo})
nan</p>
<p>limit(x*<em>3 - 3</em>x, x, oo)
oo</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the substitution will be followed by numerical
evaluation, it is better to pass the substitution to
evalf as</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).evalf(subs={x: 3.0}, n=21)
0.333333333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<p>rather than</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1/x).subs({x: 3.0}).evalf(21)
0.333333333333333314830</p>
</blockquote>
</blockquote>
</blockquote>
<p>as the former will ensure that the desired level of precision is
obtained.</p>
<h1 id="see-also_68">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
xreplace: exact node replacement in expr tree; also capable of
          using matching rules
sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision</p>
<h4 id="taylor_term_4">taylor_term</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">taylor_term</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="o">*</span><span class="n">previous_terms</span>
<span class="p">)</span>
</code></pre></div>
<p>General method for the taylor term.</p>
<p>This method is slow, because it differentiates n-times. Subclasses can
redefine it to make it faster by using the "previous_terms".</p>
<h4 id="to_nnf_4">to_nnf</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_nnf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="together_4">together</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">together</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>See the together function in sympy.polys</p>
<h4 id="transpose_4">transpose</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="trigsimp_4">trigsimp</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">trigsimp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">**</span><span class="n">args</span>
<span class="p">)</span>
</code></pre></div>
<p>See the trigsimp function in sympy.simplify</p>
<h4 id="xreplace_4">xreplace</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">xreplace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">rule</span><span class="p">,</span>
    <span class="n">hack2</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Replace occurrences of objects within the expression.</p>
<h1 id="parameters_29">Parameters</h1>
<p>rule : dict-like
    Expresses a replacement rule</p>
<h1 id="returns_14">Returns</h1>
<p>xreplace : the result of the replacement</p>
<h1 id="examples_219">Examples</h1>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import symbols, pi, exp
x, y, z = symbols('x y z')
(1 + x<em>y).xreplace({x: pi})
pi</em>y + 1
(1 + x<em>y).xreplace({x: pi, y: 2})
1 + 2</em>pi</p>
</blockquote>
</blockquote>
</blockquote>
<p>Replacements occur only if an entire node in the expression tree is
matched:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(x<em>y + z).xreplace({x</em>y: pi})
z + pi
(x<em>y</em>z).xreplace({x<em>y: pi})
x</em>y<em>z
(2</em>x).xreplace({2<em>x: y, x: z})
y
(2</em>2<em>x).xreplace({2</em>x: y, x: z})
4*z
(x + y + 2).xreplace({x + y: 2})
x + y + 2
(x + 2 + exp(x + 2)).xreplace({x + 2: y})
x + exp(y) + 2</p>
</blockquote>
</blockquote>
</blockquote>
<p>xreplace does not differentiate between free and bound symbols. In the
following, subs(x, y) would not change x since it is a bound symbol,
but xreplace does:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from sympy import Integral
Integral(x, (x, 1, 2<em>x)).xreplace({x: y})
Integral(y, (y, 1, 2</em>y))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Trying to replace x with an expression raises an error:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Integral(x, (x, 1, 2<em>x)).xreplace({x: 2</em>y}) # doctest: +SKIP
ValueError: Invalid limits given: ((2<em>y, 1, 4</em>y),)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="see-also_69">See Also</h1>
<p>replace: replacement capable of doing wildcard-like matching,
         parsing of match, and conditional replacements
subs: substitution of subexpressions as defined by the objects
      themselves.</p>
<h3 id="task">Task</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;str&#39;</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="s1">&#39;Lazy&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Named wrapper of a lazy-evaluatable function.</p>
<p>Wraps a lazy-evaluatable function (<code>dewret.workflow.Lazy</code>) with any
metadata needed to render it later. At present, this is the name.</p>
<h4 id="attributes_5">Attributes</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>None</td>
<td>Name of the lazy function as it will appear in the output workflow text.</td>
<td>None</td>
</tr>
<tr>
<td>target</td>
<td>None</td>
<td>Callable that is wrapped.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h3 id="unsettype">UnsetType</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">UnsetType</span><span class="p">(</span>
    <span class="n">raw_type</span><span class="p">:</span> <span class="s1">&#39;type[T]&#39;</span>
<span class="p">)</span>
</code></pre></div>
<p>Unset variable with a specific type.</p>
<h4 id="attributes_6">Attributes</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>type</strong></td>
<td>None</td>
<td>type of the variable.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="ancestors-in-mro_12">Ancestors (in MRO)</h4>
<ul>
<li>dewret.utils.Unset</li>
<li>typing.Generic</li>
</ul>
<h3 id="workflow">Workflow</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Workflow</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;str | None&#39;</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Overarching workflow concept.</p>
<p>Represents a whole workflow, as a singleton maintaining all
state information needed ahead of rendering. It is built up
as the lazy-evaluations are finally evaluated.</p>
<h4 id="attributes_7">Attributes</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>steps</td>
<td>None</td>
<td>the sequence of calls to lazy-evaluable functions,<br>built as they are evaluated.</td>
<td>None</td>
</tr>
<tr>
<td>tasks</td>
<td>None</td>
<td>the mapping of names used in the <code>steps</code> to the actual<br><code>Task</code> wrappers they represent.</td>
<td>None</td>
</tr>
<tr>
<td>result</td>
<td>None</td>
<td>target reference to evaluate, if yet present.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="static-methods_5">Static methods</h4>
<h4 id="assimilate">assimilate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">assimilate</span><span class="p">(</span>
    <span class="o">*</span><span class="n">workflow_args</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;&#39;Workflow&#39;&quot;</span>
</code></pre></div>
<p>Combine two Workflows into one Workflow.</p>
<p>Takes two workflows and unifies them by combining steps
and tasks. If it sees mismatched identifiers for the same
component, it will error.
This could happen if the hashing function is flawed
or some Python magic to do with Targets being passed.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>workflow_args</td>
<td>None</td>
<td>workflows to use as base</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="from_result">from_result</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">from_result</span><span class="p">(</span>
    <span class="n">result</span><span class="p">:</span> <span class="s1">&#39;StepReference[Any] | list[StepReference[Any]] | tuple[StepReference[Any], ...]&#39;</span><span class="p">,</span>
    <span class="n">simplify_ids</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nested</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Workflow&#39;</span>
</code></pre></div>
<p>Create from a desired result.</p>
<p>Starts from a result, and builds a workflow to output it.</p>
<h4 id="instance-variables_10">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">has_result</span>
</code></pre></div>
<p>Confirms whether this workflow has a non-empty result.</p>
<p>Either None or an empty list/tuple are considered empty for this purpose.</p>
<p>Returns: True if the workflow has a result, False otherwise.</p>
<div class="highlight"><pre><span></span><code><span class="nb">id</span>
</code></pre></div>
<p>Consistent ID based off the step IDs.</p>
<div class="highlight"><pre><span></span><code><span class="n">indexed_steps</span>
</code></pre></div>
<p>Steps mapped by ID.</p>
<p>Forces generation of IDs. Note that this effectively
freezes the steps, so it should not be used until we
are confident the steps are all ready to be hashed.</p>
<div class="highlight"><pre><span></span><code><span class="n">name</span>
</code></pre></div>
<p>Get the name of the workflow.</p>
<div class="highlight"><pre><span></span><code><span class="n">result_type</span>
</code></pre></div>
<p>Overall return type of this workflow.</p>
<div class="highlight"><pre><span></span><code><span class="n">steps</span>
</code></pre></div>
<p>Get deduplicated steps.</p>
<p>Returns: steps for looping over without duplicates.</p>
<h4 id="methods_10">Methods</h4>
<h4 id="add_nested_step">add_nested_step</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">add_nested_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;str&#39;</span><span class="p">,</span>
    <span class="n">subworkflow</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
    <span class="n">return_type</span><span class="p">:</span> <span class="s1">&#39;type | None&#39;</span><span class="p">,</span>
    <span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;dict[str, Any]&#39;</span><span class="p">,</span>
    <span class="n">positional_args</span><span class="p">:</span> <span class="s1">&#39;dict[str, bool] | None&#39;</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;StepReference[Any]&#39;</span>
</code></pre></div>
<p>Append a nested step.</p>
<p>Calls a subworkflow.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>None</td>
<td>name of the subworkflow.</td>
<td>None</td>
</tr>
<tr>
<td>subworkflow</td>
<td>None</td>
<td>the subworkflow itself.</td>
<td>None</td>
</tr>
<tr>
<td>return_type</td>
<td>None</td>
<td>a forced type for the return, or None.</td>
<td>None</td>
</tr>
<tr>
<td>kwargs</td>
<td>None</td>
<td>any key-value arguments to pass in the call.</td>
<td>None</td>
</tr>
<tr>
<td>positional_args</td>
<td>None</td>
<td>a mapping of arguments to bools, True if the argument is positional or otherwise False.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="add_step">add_step</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">add_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">fn</span><span class="p">:</span> <span class="s1">&#39;Lazy&#39;</span><span class="p">,</span>
    <span class="n">kwargs</span><span class="p">:</span> <span class="s1">&#39;dict[str, Raw | Reference[Any]]&#39;</span><span class="p">,</span>
    <span class="n">raw_as_parameter</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">is_factory</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">positional_args</span><span class="p">:</span> <span class="s1">&#39;dict[str, bool] | None&#39;</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;StepReference[Any]&#39;</span>
</code></pre></div>
<p>Append a step.</p>
<p>Adds a step, for running a target with key-value arguments,
to the workflow.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>fn</td>
<td>None</td>
<td>the target function to turn into a step.</td>
<td>None</td>
</tr>
<tr>
<td>kwargs</td>
<td>None</td>
<td>any key-value arguments to pass in the call.</td>
<td>None</td>
</tr>
<tr>
<td>raw_as_parameter</td>
<td>None</td>
<td>whether to turn any discovered raw arguments into workflow parameters.</td>
<td>None</td>
</tr>
<tr>
<td>is_factory</td>
<td>None</td>
<td>whether this step should be a Factory.</td>
<td>None</td>
</tr>
<tr>
<td>positional_args</td>
<td>None</td>
<td>a mapping of arguments to bools, True if the argument is positional or otherwise False.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="find_factories">find_factories</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_factories</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;dict[str, FactoryCall]&#39;</span>
</code></pre></div>
<p>Steps that are factory calls.</p>
<h4 id="find_parameters">find_parameters</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_parameters</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">include_factory_calls</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;set[Parameter[Any]]&#39;</span>
</code></pre></div>
<p>Crawl steps for parameter references.</p>
<p>As the workflow does not hold its own list of parameters, this
dynamically finds them.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>Set of all references to parameters across the steps.</td>
</tr>
</tbody>
</table>
<h4 id="register_task">register_task</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">register_task</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">fn</span><span class="p">:</span> <span class="s1">&#39;Lazy&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Task&#39;</span>
</code></pre></div>
<p>Note the existence of a lazy-evaluatable function, and wrap it as a <code>Task</code>.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>fn</td>
<td>None</td>
<td>the wrapped function.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A new <code>Task</code> that wraps the function, and is retained in the <code>Workflow.tasks</code><br>dict.</td>
</tr>
</tbody>
</table>
<h4 id="remap">remap</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">remap</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">step_id</span><span class="p">:</span> <span class="s1">&#39;str&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;str&#39;</span>
</code></pre></div>
<p>Apply name simplification if requested.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>step_id</td>
<td>None</td>
<td>step to check.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>Same ID or a remapped name.</td>
</tr>
</tbody>
</table>
<h4 id="set_result">set_result</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set_result</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">result</span><span class="p">:</span> <span class="s1">&#39;Basic | list[Basic] | tuple[Basic]&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;None&#39;</span>
</code></pre></div>
<p>Choose the result step.</p>
<p>Sets a step as being the result for the entire workflow.
When we evaluate a dynamic workflow, the engine (e.g. dask)
creates a graph to realize the result of a single collection.
Similarly, in the static case, we need to have a result that
drives the calculation.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>result</td>
<td>None</td>
<td>reference to the chosen step.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="simplify_ids">simplify_ids</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simplify_ids</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">infix</span><span class="p">:</span> <span class="s1">&#39;list[str] | None&#39;</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;None&#39;</span>
</code></pre></div>
<p>Work out mapping to simple ints from hashes.</p>
<p>Goes through and numbers each step by the order of use of its task.</p>
<h3 id="workflowlinkedcomponent">WorkflowLinkedComponent</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WorkflowLinkedComponent</span><span class="p">(</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>Protocol for objects dynamically tied to a <code>Workflow</code>.</p>
<h4 id="ancestors-in-mro_13">Ancestors (in MRO)</h4>
<ul>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        
<footer class="md-footer">
    
      <nav class="md-footer__inner md-grid" aria-label="Footer">
        
          
          <a href="../utils/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Utils" rel="prev">
            <div class="md-footer__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
            </div>
            <div class="md-footer__title">
              <div class="md-ellipsis">
                <span class="md-footer__direction">
                  Previous
                </span>
                Utils
              </div>
            </div>
          </a>
        
        
          
          <a href="../backends/backend_dask/" class="md-footer__link md-footer__link--next" aria-label="Next: Backend Dask" rel="next">
            <div class="md-footer__title">
              <div class="md-ellipsis">
                <span class="md-footer__direction">
                  Next
                </span>
                Backend Dask
              </div>
            </div>
            <div class="md-footer__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
            </div>
          </a>
        
      </nav>
    
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
            
            Powered by
            <a href="http://timothycrosley.github.io/portray">portray.</a>
            You too can
            <a href="http://timothycrosley.github.io/portray">
              portray</a>
            your Python project well using automatic documentation.
          </div>
        
      </div>
    </div>
  </footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.5bf1dace.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.078830c0.min.js"></script>
      
    
  </body>
</html>